import class gameuiPersonalLinkSwitcherEvent extends Event
{
	import var isAdvanced : Bool;
}

import class RPGManager extends IScriptable
{
	public import static function GetItemData( gi : GameInstance, owner : GameObject, itemID : ItemID ) : weak< gameItemData >;
	public import static function GetInnerItemDataQuality( itemData : InnerItemData ) : gamedataQuality;
	public import static function GetItemDataQuality( itemData : weak< gameItemData > ) : gamedataQuality;
	public import static function GetFloatItemQuality( qualityStat : Float ) : gamedataQuality;
	public import static function IsInnerItemDataIconic( itemData : InnerItemData ) : Bool;
	public import static function IsItemDataIconic( itemData : weak< gameItemData > ) : Bool;
	public import static function IsItemBroken( itemData : gameItemData ) : Bool;
	public import static function IsPercentageStat( stat : gamedataStatType ) : Bool;
	public import static function ApplyAbilityArray( owner : weak< GameObject >, abilities : array< weak< GameplayAbility_Record > > );
	public import static function ShouldFlipNegativeValue( record : weak< Stat_Record > ) : Bool;
	public import static function ShouldSlotBeAvailable( owner : weak< GameObject >, item : ItemID, attachmentSlotRecord : weak< AttachmentSlot_Record > ) : Bool;
	public import static function CalculateStatModifiers( modifiers : array< weak< StatModifier_Record > >, context : GameInstance, root : weak< GameObject >, targetID : StatsObjectID, optional instigator : StatsObjectID, optional itemStatsID : StatsObjectID ) : Float;
	public import static function CalculateAdditiveModifiers( modifiers : array< weak< StatModifier_Record > >, context : GameInstance, root : weak< GameObject >, targetID : StatsObjectID, optional instigator : StatsObjectID, optional itemStatsID : StatsObjectID ) : Float;
	public import static function CalculateMultiplierModifiers( modifiers : array< weak< StatModifier_Record > >, context : GameInstance, root : weak< GameObject >, targetID : StatsObjectID, optional instigator : StatsObjectID, optional itemStatsID : StatsObjectID ) : Float;
	public import static function CalculateAdditiveMultiplierModifiers( modifiers : array< weak< StatModifier_Record > >, context : GameInstance, root : weak< GameObject >, targetID : StatsObjectID, optional instigator : StatsObjectID, optional itemStatsID : StatsObjectID ) : Float;
	public import static function CalculateStatModifier( modifier : weak< StatModifier_Record >, context : GameInstance, root : weak< GameObject >, targetID : StatsObjectID, optional instigator : StatsObjectID, optional itemStatsID : StatsObjectID ) : Float;
	public import static function CalculateConstantModifier( modifier : weak< ConstantStatModifier_Record > ) : Float;
	public import static function CalculateRandomModifier( modifier : weak< RandomStatModifier_Record > ) : Float;
	public import static function CalculateCurveModifier( modifier : weak< CurveStatModifier_Record >, context : GameInstance, root : weak< GameObject >, targetID : StatsObjectID, optional instigator : StatsObjectID, optional itemStatsID : StatsObjectID ) : Float;
	public import static function CalculateCombinedModifier( modifier : weak< CombinedStatModifier_Record >, context : GameInstance, root : weak< GameObject >, targetID : StatsObjectID, optional instigator : StatsObjectID, optional itemStatsID : StatsObjectID ) : Float;
	public import static function GetRefObjectID( refObjectName : CName, context : GameInstance, root : weak< GameObject >, targetID : StatsObjectID, optional instigator : StatsObjectID, optional itemStatsID : StatsObjectID ) : StatsObjectID;
	public import static function CalculateBuyPrice( context : GameInstance, vendor : weak< GameObject >, itemID : ItemID, multiplier : Float ) : Int32;
	public import static function CalculateSellPrice( context : GameInstance, vendor : weak< GameObject >, itemID : ItemID ) : Int32;
	public import static function CalculateSellPriceItemData( context : GameInstance, vendor : weak< GameObject >, itemData : gameItemData ) : Int32;

	public static function CalculateStatModifiers( addValue : Float, multValue : Float, addMultValue : Float, modifiers : array< weak< StatModifier_Record > >, context : GameInstance, root : weak< GameObject >, targetID : StatsObjectID, optional instigator : StatsObjectID, optional itemStatsID : StatsObjectID ) : Float
	{
		var additiveMods : array< weak< StatModifier_Record > >;
		var multiplierMods : array< weak< StatModifier_Record > >;
		var addMultMods : array< weak< StatModifier_Record > >;
		var i : Int32;
		var modType : CName;
		for( i = 0; i < modifiers.Size(); i += 1 )
		{
			modType = modifiers[ i ].ModifierType();
			switch( modType )
			{
				case 'Additive':
					additiveMods.PushBack( modifiers[ i ] );
				break;
				case 'Multiplier':
					multiplierMods.PushBack( modifiers[ i ] );
				break;
				case 'AdditiveMultiplier':
					addMultMods.PushBack( modifiers[ i ] );
				break;
				default:
					break;
			}
		}
		addValue += CalculateAdditiveModifiers( additiveMods, context, root, targetID, instigator, itemStatsID );
		multValue *= CalculateMultiplierModifiers( multiplierMods, context, root, targetID, instigator, itemStatsID );
		addMultValue += CalculateAdditiveMultiplierModifiers( addMultMods, context, root, targetID, instigator, itemStatsID );
		return ( addValue * multValue ) * addMultValue;
	}

	public static function InjectStatModifier( gi : GameInstance, obj : GameObject, modifier : gameStatModifierData )
	{
		GameInstance.GetStatsSystem( gi ).AddModifier( obj.GetEntityID(), modifier );
	}

	public static function InjectStatModifierToItem( gi : GameInstance, itemData : gameItemData, modifier : gameStatModifierData )
	{
		GameInstance.GetStatsSystem( gi ).AddModifier( itemData.GetStatsObjectID(), modifier );
	}

	public static function IsDamageStat( stat : gamedataStatType ) : Bool
	{
		return ( ( ( ( stat == gamedataStatType.PhysicalDamage || stat == gamedataStatType.ThermalDamage ) || stat == gamedataStatType.ChemicalDamage ) || stat == gamedataStatType.ElectricDamage ) || stat == gamedataStatType.DamagePerHit ) || stat == gamedataStatType.EffectiveDamagePerHit;
	}

	public static function GetStatValueFromObject( gi : GameInstance, object : weak< GameObject >, stat : gamedataStatType ) : Float
	{
		return GameInstance.GetStatsSystem( gi ).GetStatValue( object.GetEntityID(), stat );
	}

	public static function CheckPrereqs( prereqs : array< weak< IPrereq_Record > >, target : weak< GameObject >, optional referenceStatsID : StatsObjectID ) : Bool
	{
		var prereq : IPrereq;
		var statPrereq : StatPrereq;
		var i : Int32;
		for( i = 0; i < prereqs.Size(); i += 1 )
		{
			prereq = IPrereq.CreatePrereq( prereqs[ i ].GetID() );
			statPrereq = ( ( StatPrereq )( prereq ) );
			if( statPrereq && StatsObjectID.IsDefined( referenceStatsID ) )
			{
				if( !( statPrereq.IsFulfilled( target.GetGame(), target, referenceStatsID ) ) )
				{
					return false;
				}
			}
			else
			{
				if( !( prereq.IsFulfilled( target.GetGame(), target ) ) )
				{
					return false;
				}
			}
		}
		return true;
	}

	public static function CheckPrereq( prereqRecord : weak< IPrereq_Record >, target : weak< GameObject >, optional referenceStatsID : StatsObjectID ) : Bool
	{
		var prereq : IPrereq;
		var statPrereq : StatPrereq;
		prereq = IPrereq.CreatePrereq( prereqRecord.GetID() );
		statPrereq = ( ( StatPrereq )( prereq ) );
		if( statPrereq && StatsObjectID.IsDefined( referenceStatsID ) )
		{
			if( !( statPrereq.IsFulfilled( target.GetGame(), target, referenceStatsID ) ) )
			{
				return false;
			}
		}
		else
		{
			if( !( prereq.IsFulfilled( target.GetGame(), target ) ) )
			{
				return false;
			}
		}
		return true;
	}

	public static function CheckPerkPrereqs( itemData : weak< gameItemData >, context : weak< GameObject >, out perkRecord : weak< Perk_Record > ) : Bool
	{
		var i : Int32;
		var prereqs : array< weak< IPrereq_Record > >;
		var perkPrereq : weak< PerkPrereq_Record >;
		var prereqClassName : String;
		var perkType : gamedataPerkType;
		GetItemRecord( itemData.GetID() ).EquipPrereqs( prereqs );
		for( i = 0; i < prereqs.Size(); i += 1 )
		{
			perkPrereq = ( ( PerkPrereq_Record )( prereqs[ i ] ) );
			if( perkPrereq )
			{
				prereqClassName = perkPrereq.Perk();
				perkRecord = TweakDBInterface.GetPerkRecord( TDBID.Create( "Perks." + prereqClassName ) );
				perkType = perkRecord.Type();
				if( perkRecord && !( PlayerDevelopmentSystem.GetData( context ).HasPerk( perkType ) ) )
				{
					return true;
				}
			}
		}
		return false;
	}

	public static function CheckCraftedItemPerkPrereq( itemData : weak< gameItemData >, context : weak< GameObject >, out prereqName : String ) : Bool
	{
		var perkRecord : weak< Perk_Record >;
		if( !( IsItemCrafted( itemData ) ) )
		{
			return false;
		}
		else
		{
			if( CheckPerkPrereqs( itemData, context, perkRecord ) )
			{
				prereqName = perkRecord.Loc_name_key();
				return true;
			}
			else
			{
				return false;
			}
		}
	}

	public static function GetEquipRequirements( owner : GameObject, itemData : gameItemData ) : array< SItemStackRequirementData >
	{
		var i : Int32;
		var prereqs : array< weak< IPrereq_Record > >;
		var statPrereqs : array< StatPrereq_Record >;
		var data : SItemStackRequirementData;
		var datas : array< SItemStackRequirementData >;
		var itemRecord : weak< Item_Record >;
		itemRecord = GetItemRecord( itemData.GetID() );
		itemRecord.EquipPrereqs( prereqs );
		if( itemRecord.UsesVariants() )
		{
			itemRecord.GetVariantsItem( itemData.GetVariant() ).VariantPrereqs( prereqs );
		}
		statPrereqs = GetNestedPrereqs( prereqs );
		for( i = 0; i < statPrereqs.Size(); i += 1 )
		{
			data.statType = ( ( gamedataStatType )( ( ( Int32 )( EnumValueFromName( 'gamedataStatType', statPrereqs[ i ].StatType() ) ) ) ) );
			if( statPrereqs[ i ].GetStatModifiersCount() > 0 )
			{
				data.requiredValue = GameInstance.GetStatsSystem( owner.GetGame() ).GetStatPrereqModifiersValue( itemData.GetStatsObjectID(), statPrereqs[ i ].GetID() );
			}
			else
			{
				data.requiredValue = statPrereqs[ i ].ValueToCheck();
			}
			datas.PushBack( data );
		}
		return datas;
	}

	private static function GetNestedPrereqs( prereqs : array< weak< IPrereq_Record > > ) : array< StatPrereq_Record >
	{
		var i, j : Int32;
		var statPrereq : StatPrereq_Record;
		var multiPrereq : MultiPrereq_Record;
		var statPrereqs, temps : array< StatPrereq_Record >;
		var nestedPrereqs : array< weak< IPrereq_Record > >;
		for( i = 0; i < prereqs.Size(); i += 1 )
		{
			multiPrereq = ( ( MultiPrereq_Record )( prereqs[ i ] ) );
			if( multiPrereq )
			{
				nestedPrereqs.Clear();
				multiPrereq.NestedPrereqs( nestedPrereqs );
				temps = GetNestedPrereqs( nestedPrereqs );
				for( j = 0; j < temps.Size(); j += 1 )
				{
					statPrereqs.PushBack( temps[ j ] );
				}
			}
			else
			{
				statPrereq = ( ( StatPrereq_Record )( prereqs[ i ] ) );
				if( statPrereq )
				{
					statPrereqs.PushBack( statPrereq );
				}
			}
		}
		return statPrereqs;
	}

	public static function GetRarityMultiplier( puppet : weak< NPCPuppet >, curveName : CName ) : Float
	{
		var rarity : gamedataNPCRarity;
		var statsDataSystem : StatsDataSystem;
		var multiplier : Float;
		var powerLevel : Float;
		multiplier = 1.0;
		rarity = puppet.GetPuppetRarity().Type();
		statsDataSystem = GameInstance.GetStatsDataSystem( puppet.GetGame() );
		powerLevel = GameInstance.GetStatsSystem( puppet.GetGame() ).GetStatValue( puppet.GetEntityID(), gamedataStatType.PowerLevel );
		switch( rarity )
		{
			case gamedataNPCRarity.Trash:
				multiplier = statsDataSystem.GetValueFromCurve( 'puppet_preset_trash_mods', powerLevel, curveName );
			break;
			case gamedataNPCRarity.Weak:
				multiplier = statsDataSystem.GetValueFromCurve( 'puppet_preset_weak_mods', powerLevel, curveName );
			break;
			case gamedataNPCRarity.Rare:
				multiplier = statsDataSystem.GetValueFromCurve( 'puppet_preset_rare_mods', powerLevel, curveName );
			break;
			case gamedataNPCRarity.Elite:
				multiplier = statsDataSystem.GetValueFromCurve( 'puppet_preset_elite_mods', powerLevel, curveName );
			break;
			case gamedataNPCRarity.Officer:
				multiplier = statsDataSystem.GetValueFromCurve( 'puppet_preset_officer_mods', powerLevel, curveName );
			break;
			case gamedataNPCRarity.Normal:
				multiplier = statsDataSystem.GetValueFromCurve( 'puppet_preset_normal_mods', powerLevel, curveName );
			break;
			case gamedataNPCRarity.Boss:
				multiplier = statsDataSystem.GetValueFromCurve( 'puppet_preset_boss_mods', powerLevel, curveName );
			break;
			default:
				multiplier = 1.0;
			break;
		}
		return multiplier;
	}

	public static function ResistancesList() : array< gamedataStatType >
	{
		var resistances : array< gamedataStatType >;
		resistances.PushBack( gamedataStatType.PhysicalResistance );
		resistances.PushBack( gamedataStatType.ChemicalResistance );
		resistances.PushBack( gamedataStatType.ThermalResistance );
		resistances.PushBack( gamedataStatType.ElectricResistance );
		return resistances;
	}

	public static function ApplyAbility( owner : weak< GameObject >, ability : weak< GameplayAbility_Record > )
	{
		var GLP : GameplayLogicPackageSystem;
		GLP = GameInstance.GetGameplayLogicPackageSystem( owner.GetGame() );
		GLP.RemovePackage( owner, ability.AbilityPackage().GetID() );
		GLP.ApplyPackage( owner, owner, ability.AbilityPackage().GetID() );
	}

	public static function RemoveAbility( owner : weak< GameObject >, ability : weak< GameplayAbility_Record > )
	{
		var GLP : GameplayLogicPackageSystem;
		GLP = GameInstance.GetGameplayLogicPackageSystem( owner.GetGame() );
		GLP.RemovePackage( owner, ability.AbilityPackage().GetID() );
	}

	public static function ApplyAbilityGroup( owner : weak< GameObject >, group : weak< GameplayAbilityGroup_Record > )
	{
		var abilities : array< weak< GameplayAbility_Record > >;
		if( group.GetAbilitiesCount() > 0 )
		{
			group.Abilities( abilities );
			RPGManager.ApplyAbilityArray( owner, abilities );
		}
	}

	public static function RemoveAbilityGroup( owner : weak< GameObject >, group : weak< GameplayAbilityGroup_Record > )
	{
		var i : Int32;
		var abilities : array< weak< GameplayAbility_Record > >;
		group.Abilities( abilities );
		for( i = 0; i < abilities.Size(); i += 1 )
		{
			RPGManager.RemoveAbility( owner, abilities[ i ] );
		}
	}

	public static function ApplyGLP( owner : weak< GameObject >, package : weak< GameplayLogicPackage_Record > )
	{
		var appliedPackages : array< TweakDBID >;
		var glpSys : GameplayLogicPackageSystem;
		glpSys = GameInstance.GetGameplayLogicPackageSystem( owner.GetGame() );
		glpSys.GetAppliedPackages( owner, appliedPackages );
		if( !( appliedPackages.Contains( package.GetID() ) ) || package.Stackable() )
		{
			glpSys.ApplyPackage( owner, owner, package.GetID() );
		}
	}

	public static function RemoveGLP( owner : weak< GameObject >, package : weak< GameplayLogicPackage_Record > )
	{
		var appliedPackages : array< TweakDBID >;
		var glpSys : GameplayLogicPackageSystem;
		glpSys = GameInstance.GetGameplayLogicPackageSystem( owner.GetGame() );
		glpSys.GetAppliedPackages( owner, appliedPackages );
		if( appliedPackages.Contains( package.GetID() ) )
		{
			glpSys.RemovePackage( owner, package.GetID() );
		}
	}

	public static function ApplyGLPArray( owner : weak< GameObject >, arr : array< weak< GameplayLogicPackage_Record > >, optional ignoreAppliedPackages : Bool )
	{
		var i : Int32;
		var appliedPackages : array< TweakDBID >;
		var glpSys : GameplayLogicPackageSystem;
		glpSys = GameInstance.GetGameplayLogicPackageSystem( owner.GetGame() );
		if( ignoreAppliedPackages )
		{
			for( i = 0; i < arr.Size(); i += 1 )
			{
				glpSys.ApplyPackage( owner, owner, arr[ i ].GetID() );
			}
		}
		else
		{
			glpSys.GetAppliedPackages( owner, appliedPackages );
			for( i = 0; i < arr.Size(); i += 1 )
			{
				if( arr[ i ].Stackable() || !( appliedPackages.Contains( arr[ i ].GetID() ) ) )
				{
					glpSys.ApplyPackage( owner, owner, arr[ i ].GetID() );
				}
			}
		}
	}

	public static function ApplyEffectorsArray( owner : weak< GameObject >, arr : array< weak< Effector_Record > > )
	{
		var i : Int32;
		var ES : EffectorSystem;
		ES = GameInstance.GetEffectorSystem( owner.GetGame() );
		for( i = 0; i < arr.Size(); i += 1 )
		{
			ES.ApplyEffector( owner.GetEntityID(), owner, arr[ i ].GetID() );
		}
	}

	public static function RemoveEffectorsArray( owner : weak< GameObject >, arr : array< weak< Effector_Record > > )
	{
		var i : Int32;
		var ES : EffectorSystem;
		ES = GameInstance.GetEffectorSystem( owner.GetGame() );
		for( i = 0; i < arr.Size(); i += 1 )
		{
			ES.RemoveEffector( owner.GetEntityID(), arr[ i ].GetID() );
		}
	}

	public static function ApplyStatModifierGroups( owner : weak< GameObject >, arr : array< weak< StatModifierGroup_Record > > )
	{
		var i : Int32;
		var modGroupID : Uint64;
		var SS : StatsSystem;
		SS = GameInstance.GetStatsSystem( owner.GetGame() );
		for( i = 0; i < arr.Size(); i += 1 )
		{
			modGroupID = TDBID.ToNumber( arr[ i ].GetID() );
			SS.DefineModifierGroupFromRecord( modGroupID, arr[ i ].GetID() );
			SS.ApplyModifierGroup( owner.GetEntityID(), modGroupID );
		}
	}

	public static function RemoveStatModifierGroups( owner : weak< GameObject >, arr : array< weak< StatModifierGroup_Record > > )
	{
		var i : Int32;
		var modGroupID : Uint64;
		var SS : StatsSystem;
		SS = GameInstance.GetStatsSystem( owner.GetGame() );
		for( i = 0; i < arr.Size(); i += 1 )
		{
			modGroupID = TDBID.ToNumber( arr[ i ].GetID() );
			SS.RemoveModifierGroup( owner.GetEntityID(), modGroupID );
		}
	}

	public static function GetLevelPercentage( obj : GameObject ) : Int32
	{
		var exp : Int32;
		exp = PlayerDevelopmentSystem.GetData( obj ).GetExperiencePercentage();
		return exp;
	}

	public static function GetItemQualityFromRecord( itemRecord : Item_Record ) : gamedataQuality
	{
		var quality : gamedataQuality;
		quality = itemRecord.Quality().Type();
		if( quality != gamedataQuality.Random )
		{
			return quality;
		}
		return gamedataQuality.Invalid;
	}

	public static function GetBumpedQuality( quality : gamedataQuality ) : gamedataQuality
	{
		switch( quality )
		{
			case gamedataQuality.Common:
				return gamedataQuality.Uncommon;
			case gamedataQuality.Uncommon:
				return gamedataQuality.Rare;
			case gamedataQuality.Rare:
				return gamedataQuality.Epic;
			case gamedataQuality.Epic:
				return gamedataQuality.Legendary;
			default:
				return quality;
		}
	}

	public static function GetItemQuality( itemData : InnerItemData ) : gamedataQuality
	{
		return GetItemQuality( InnerItemData.GetStatValueByType( itemData, gamedataStatType.Quality ) );
	}

	public static function ItemQualityNameToValue( q : CName ) : Float
	{
		var val : Float;
		switch( q )
		{
			case 'Common':
				val = 0.0;
			break;
			case 'Uncommon':
				val = 1.0;
			break;
			case 'Rare':
				val = 2.0;
			break;
			case 'Epic':
				val = 3.0;
			break;
			case 'Legendary':
				val = 4.0;
			break;
			default:
				val = 0.0;
			break;
		}
		return val;
	}

	public static function SetQualityBasedOnCraftingSkill( object : weak< GameObject > ) : CName
	{
		var craftingValue : Float;
		var scalingValue : Float;
		var quality : CName;
		craftingValue = GameInstance.GetStatsSystem( object.GetGame() ).GetStatValue( object.GetEntityID(), gamedataStatType.Crafting );
		scalingValue = GameInstance.GetStatsDataSystem( object.GetGame() ).GetValueFromCurve( 'random_distributions', craftingValue, 'crafting_to_random_quality_items' );
		switch( scalingValue )
		{
			case 0.0:
				quality = 'Common';
			break;
			case 1.0:
				quality = 'Uncommon';
			break;
			case 2.0:
				quality = 'Rare';
			break;
			case 3.0:
				quality = 'Epic';
			break;
			case 4.0:
				quality = 'Legendary';
			break;
			default:
				quality = 'Common';
			break;
		}
		return quality;
	}

	public static function GetNextItemQuality( itemData : weak< gameItemData > ) : gamedataQuality
	{
		if( itemData )
		{
			return GetItemQuality( itemData.GetStatValueByType( gamedataStatType.Quality ) + 1.0 );
		}
		return gamedataQuality.Invalid;
	}

	public static function GetCraftingNextLevelBasedOnRandomQuality( quality : gamedataQuality ) : Int32
	{
		var craftingLevel : Int32;
		switch( quality )
		{
			case gamedataQuality.Uncommon:
				craftingLevel = 4;
			break;
			case gamedataQuality.Rare:
				craftingLevel = 9;
			break;
			case gamedataQuality.Epic:
				craftingLevel = 14;
			break;
			case gamedataQuality.Legendary:
				craftingLevel = 18;
			break;
			default:
				craftingLevel = -1;
			break;
		}
		return craftingLevel;
	}

	public static function GetItemQuality( itemData : weak< gameItemData > ) : gamedataQuality
	{
		if( itemData )
		{
			return GetItemQuality( itemData.GetStatValueByType( gamedataStatType.Quality ) );
		}
		return gamedataQuality.Invalid;
	}

	public static function IsItemIconic( itemData : weak< gameItemData > ) : Bool
	{
		return itemData.GetStatValueByType( gamedataStatType.IsItemIconic ) > 0.0;
	}

	public static function IsItemIconic( itemData : InnerItemData ) : Bool
	{
		return InnerItemData.GetStatValueByType( itemData, gamedataStatType.IsItemIconic ) > 0.0;
	}

	public static function IsItemMaxLevel( itemData : weak< gameItemData > ) : Bool
	{
		var tempStat : Float;
		tempStat = itemData.GetStatValueByType( gamedataStatType.ItemLevel );
		return tempStat >= 500.0;
	}

	public static function IsItemWeapon( itemID : ItemID ) : Bool
	{
		return RPGManager.GetItemCategory( itemID ) == gamedataItemCategory.Weapon;
	}

	public static function IsItemClothing( itemID : ItemID ) : Bool
	{
		return RPGManager.GetItemCategory( itemID ) == gamedataItemCategory.Clothing;
	}

	public static function IsItemGadget( itemID : ItemID ) : Bool
	{
		return RPGManager.GetItemCategory( itemID ) == gamedataItemCategory.Gadget;
	}

	public static function IsItemProgram( itemID : ItemID ) : Bool
	{
		return RPGManager.GetItemType( itemID ) == gamedataItemType.Prt_Program;
	}

	public static function IsItemTypeCyberwareWeapon( type : gamedataItemType ) : Bool
	{
		switch( type )
		{
			case gamedataItemType.Cyb_MantisBlades:
			case gamedataItemType.Cyb_NanoWires:
			case gamedataItemType.Cyb_StrongArms:
				return true;
			default:
				return false;
		}
	}

	public static function GetItemQuality( qualityStat : Float ) : gamedataQuality
	{
		var qualityInt : Int32;
		qualityInt = RoundF( qualityStat );
		switch( qualityInt )
		{
			case 0:
				return gamedataQuality.Common;
			case 1:
				return gamedataQuality.Uncommon;
			case 2:
				return gamedataQuality.Rare;
			case 3:
				return gamedataQuality.Epic;
			case 4:
				return gamedataQuality.Legendary;
			default:
				return gamedataQuality.Common;
		}
	}

	public static function GetCraftingMaterialRecord( quality : gamedataQuality, optional alternateVariant : Bool ) : Item_Record
	{
		var record : Item_Record;
		switch( quality )
		{
			case gamedataQuality.Common:
				record = TweakDBInterface.GetItemRecord( T"Items.CommonMaterial1" );
			break;
			case gamedataQuality.Uncommon:
				record = TweakDBInterface.GetItemRecord( T"Items.UncommonMaterial1" );
			break;
			case gamedataQuality.Rare:
				if( alternateVariant )
				{
					record = TweakDBInterface.GetItemRecord( T"Items.RareMaterial1" );
				}
				else
				{
					record = TweakDBInterface.GetItemRecord( T"Items.RareMaterial2" );
				}
			break;
			case gamedataQuality.Epic:
				if( alternateVariant )
				{
					record = TweakDBInterface.GetItemRecord( T"Items.EpicMaterial1" );
				}
				else
				{
					record = TweakDBInterface.GetItemRecord( T"Items.EpicMaterial2" );
				}
			break;
			case gamedataQuality.Legendary:
				if( alternateVariant )
				{
					record = TweakDBInterface.GetItemRecord( T"Items.LegendaryMaterial1" );
				}
				else
				{
					record = TweakDBInterface.GetItemRecord( T"Items.LegendaryMaterial2" );
				}
			break;
			default:
				return record;
		}
		return record;
	}

	public static function GetAvailableSlotsForQuality( itemData : weak< gameItemData >, quality : gamedataQuality ) : Float
	{
		switch( quality )
		{
			case gamedataQuality.Common:
				return 0.0;
			break;
			case gamedataQuality.Uncommon:
				return 0.0;
			break;
			case gamedataQuality.Rare:
				return 1.0;
			break;
			case gamedataQuality.Epic:
				return 2.0;
			break;
			case gamedataQuality.Legendary:
				return 3.0;
			break;
			default:
				return 0.0;
		}
		return -1.0;
	}

	public static function GetListOfRandomStatsFromEvolutionType( evolution : gamedataWeaponEvolution ) : array< weak< Stat_Record > >
	{
		var record : weak< UIStatsMap_Record >;
		var statMap : array< weak< Stat_Record > >;
		var tempStr : String;
		if( evolution == gamedataWeaponEvolution.Invalid )
		{
			record = TweakDBInterface.GetUIStatsMapRecord( T"UIMaps.WeaponGeneral" );
		}
		else
		{
			tempStr = "UIMaps.";
			tempStr += EnumValueToString( "gamedataWeaponEvolution", ( ( Int32 )( evolution ) ) );
			record = TweakDBInterface.GetUIStatsMapRecord( TDBID.Create( tempStr ) );
		}
		record.PrimaryStats( statMap );
		return statMap;
	}

	public static function GetDominatingDamageType( gi : GameInstance, itemData : weak< gameItemData > ) : gamedataDamageType
	{
		var i : Int32;
		var dmgIndex : Int32;
		var highestValue : Float;
		var tempStat : Float;
		var statsSystem : StatsSystem;
		highestValue = 0.0;
		statsSystem = GameInstance.GetStatsSystem( gi );
		for( i = 0; i < ( ( Int32 )( gamedataDamageType.Count ) ); i += 1 )
		{
			tempStat = statsSystem.GetStatValueFromDamageType( itemData.GetStatsObjectID(), ( ( gamedataDamageType )( i ) ) );
			if( tempStat > highestValue )
			{
				highestValue = tempStat;
				dmgIndex = i;
			}
		}
		return ( ( gamedataDamageType )( dmgIndex ) );
	}

	public static function SetDroppedWeaponQuality( npc : weak< ScriptedPuppet >, itemData : weak< gameItemData > )
	{
		var SS : StatsSystem;
		var mod : gameStatModifierData;
		var quality : Float;
		if( !( npc ) )
		{
			return;
		}
		SS = GameInstance.GetStatsSystem( npc.GetGame() );
		if( RandF() < 0.89999998 )
		{
			quality = 0.0;
		}
		else
		{
			quality = 1.0;
		}
		SS.RemoveAllModifiers( itemData.GetStatsObjectID(), gamedataStatType.Quality, true );
		mod = CreateStatModifier( gamedataStatType.Quality, gameStatModifierType.Additive, quality );
		SS.AddSavedModifier( itemData.GetStatsObjectID(), mod );
		ScriptedPuppet.EvaluateLootQualityByTask( npc );
	}

	public static function ForceItemQuality( obj : weak< GameObject >, itemData : weak< gameItemData >, forcedQuality : CName )
	{
		var SS : StatsSystem;
		var value : Float;
		var mod : gameStatModifierData;
		if( !( obj ) )
		{
			return;
		}
		SS = GameInstance.GetStatsSystem( obj.GetGame() );
		value = RPGManager.GetItemQualityFromName( forcedQuality );
		if( itemData.GetStatValueByType( gamedataStatType.Quality ) == value )
		{
			return;
		}
		mod = CreateStatModifier( gamedataStatType.Quality, gameStatModifierType.Additive, value );
		SS.RemoveAllModifiers( itemData.GetStatsObjectID(), gamedataStatType.Quality, true );
		SS.RemoveAllModifiers( itemData.GetStatsObjectID(), gamedataStatType.RandomCurveInput, true );
		SS.AddSavedModifier( itemData.GetStatsObjectID(), mod );
		mod = CreateStatModifier( gamedataStatType.RandomCurveInput, gameStatModifierType.Multiplier, 0.0 );
		SS.AddSavedModifier( itemData.GetStatsObjectID(), mod );
	}

	public static function ProcessOnLootedPackages( owner : weak< GameObject >, itemID : ItemID )
	{
		var i : Int32;
		var glp : GameplayLogicPackageSystem;
		var packages : array< weak< GameplayLogicPackage_Record > >;
		RPGManager.GetItemRecord( itemID ).OnLooted( packages );
		glp = GameInstance.GetGameplayLogicPackageSystem( owner.GetGame() );
		for( i = 0; i < packages.Size(); i += 1 )
		{
			glp.ApplyPackage( owner, owner, packages[ i ].GetID() );
		}
	}

	public static function GetItemQualityFromName( qualityName : CName ) : Float
	{
		switch( qualityName )
		{
			case 'Common':
				return 0.0;
			case 'Uncommon':
				return 1.0;
			case 'Rare':
				return 2.0;
			case 'Epic':
				return 3.0;
			case 'Legendary':
				return 4.0;
			default:
				return 0.0;
		}
	}

	public static function HasItem( obj : weak< GameObject >, id : TweakDBID ) : Bool
	{
		var itemID : ItemID;
		itemID = ItemID.CreateQuery( id );
		return GameInstance.GetTransactionSystem( obj.GetGame() ).HasItem( obj, itemID );
	}

	public static function HasItem( obj : weak< GameObject >, id : ItemID ) : Bool
	{
		return GameInstance.GetTransactionSystem( obj.GetGame() ).HasItem( obj, id );
	}

	public static function GetItemType( itemID : ItemID ) : gamedataItemType
	{
		if( ItemID.IsValid( itemID ) )
		{
			return TweakDBInterface.GetItemRecord( ItemID.GetTDBID( itemID ) ).ItemType().Type();
		}
		return gamedataItemType.Invalid;
	}

	public static function IsClothingMod( itemID : ItemID ) : Bool
	{
		if( ItemID.IsValid( itemID ) )
		{
			return IsClothingMod( RPGManager.GetItemType( itemID ) );
		}
		else
		{
			return false;
		}
	}

	public static function IsClothingMod( type : gamedataItemType ) : Bool
	{
		switch( type )
		{
			case gamedataItemType.Prt_FabricEnhancer:
				return true;
			case gamedataItemType.Prt_HeadFabricEnhancer:
				return true;
			case gamedataItemType.Prt_FaceFabricEnhancer:
				return true;
			case gamedataItemType.Prt_TorsoFabricEnhancer:
				return true;
			case gamedataItemType.Prt_OuterTorsoFabricEnhancer:
				return true;
			case gamedataItemType.Prt_PantsFabricEnhancer:
				return true;
			case gamedataItemType.Prt_BootsFabricEnhancer:
				return true;
			default:
				return false;
		}
	}

	public static function GetItemCategory( itemID : ItemID ) : gamedataItemCategory
	{
		var itemRecord : Item_Record;
		var itemCategory : weak< ItemCategory_Record >;
		if( ItemID.IsValid( itemID ) )
		{
			itemRecord = TweakDBInterface.GetItemRecord( ItemID.GetTDBID( itemID ) );
			if( itemRecord )
			{
				itemCategory = itemRecord.ItemCategory();
				if( itemCategory )
				{
					return itemCategory.Type();
				}
			}
		}
		return gamedataItemCategory.Invalid;
	}

	public static function GetWeaponEvolution( itemID : ItemID ) : gamedataWeaponEvolution
	{
		var itemRecord : WeaponItem_Record;
		var weaponEvolution : weak< WeaponEvolution_Record >;
		if( ItemID.IsValid( itemID ) )
		{
			itemRecord = TweakDBInterface.GetWeaponItemRecord( ItemID.GetTDBID( itemID ) );
			if( itemRecord )
			{
				weaponEvolution = itemRecord.Evolution();
				if( weaponEvolution )
				{
					return weaponEvolution.Type();
				}
			}
		}
		return gamedataWeaponEvolution.Invalid;
	}

	public static function GetItemWeight( itemData : gameItemData ) : Float
	{
		if( itemData )
		{
			return itemData.GetStatValueByType( gamedataStatType.Weight );
		}
		return 0.0;
	}

	public static function GetItemStackWeight( owner : weak< GameObject >, itemData : weak< gameItemData > ) : Float
	{
		var quantity : Float;
		var weight : Float;
		quantity = ( ( Float )( GameInstance.GetTransactionSystem( owner.GetGame() ).GetItemQuantity( owner, itemData.GetID() ) ) );
		weight = GetItemWeight( itemData );
		return quantity * weight;
	}

	public static function IsItemSingleInstance( itemData : weak< gameItemData > ) : Bool
	{
		return GetItemRecord( itemData.GetID() ).IsSingleInstance();
	}

	public static function GetItemFromInventory( object : GameObject, item : TweakDBID ) : ItemID
	{
		var i : Int32;
		var items : array< weak< gameItemData > >;
		var TS : TransactionSystem;
		TS = GameInstance.GetTransactionSystem( object.GetGame() );
		TS.GetItemList( object, items );
		for( i = i; i < items.Size(); i += 1 )
		{
			if( ItemID.GetTDBID( items[ i ].GetID() ) == item )
			{
				return items[ i ].GetID();
			}
		}
		return ItemID.None();
	}

	public static function GetAttachmentSlotIDs() : array< TweakDBID >
	{
		var arr : array< TweakDBID >;
		arr.PushBack( T"AttachmentSlots.Scope" );
		arr.PushBack( T"AttachmentSlots.ScopeRail" );
		arr.PushBack( T"AttachmentSlots.PowerModule" );
		return arr;
	}

	public static function GetModsSlotIDs( type : gamedataItemType ) : array< TweakDBID >
	{
		var arr : array< TweakDBID >;
		switch( type )
		{
			case gamedataItemType.Clo_Head:
				arr.PushBack( T"AttachmentSlots.HeadFabricEnhancer1" );
			arr.PushBack( T"AttachmentSlots.HeadFabricEnhancer2" );
			arr.PushBack( T"AttachmentSlots.HeadFabricEnhancer3" );
			arr.PushBack( T"AttachmentSlots.HeadFabricEnhancer4" );
			break;
			case gamedataItemType.Clo_Feet:
				arr.PushBack( T"AttachmentSlots.FootFabricEnhancer1" );
			arr.PushBack( T"AttachmentSlots.FootFabricEnhancer2" );
			arr.PushBack( T"AttachmentSlots.FootFabricEnhancer3" );
			arr.PushBack( T"AttachmentSlots.FootFabricEnhancer4" );
			break;
			case gamedataItemType.Clo_Face:
				arr.PushBack( T"AttachmentSlots.FaceFabricEnhancer1" );
			arr.PushBack( T"AttachmentSlots.FaceFabricEnhancer2" );
			arr.PushBack( T"AttachmentSlots.FaceFabricEnhancer3" );
			arr.PushBack( T"AttachmentSlots.FaceFabricEnhancer4" );
			break;
			case gamedataItemType.Clo_InnerChest:
				arr.PushBack( T"AttachmentSlots.InnerChestFabricEnhancer1" );
			arr.PushBack( T"AttachmentSlots.InnerChestFabricEnhancer2" );
			arr.PushBack( T"AttachmentSlots.InnerChestFabricEnhancer3" );
			break;
			case gamedataItemType.Clo_Legs:
				arr.PushBack( T"AttachmentSlots.LegsFabricEnhancer1" );
			arr.PushBack( T"AttachmentSlots.LegsFabricEnhancer2" );
			arr.PushBack( T"AttachmentSlots.LegsFabricEnhancer3" );
			arr.PushBack( T"AttachmentSlots.LegsFabricEnhancer4" );
			break;
			case gamedataItemType.Clo_OuterChest:
				arr.PushBack( T"AttachmentSlots.OuterChestFabricEnhancer1" );
			arr.PushBack( T"AttachmentSlots.OuterChestFabricEnhancer2" );
			arr.PushBack( T"AttachmentSlots.OuterChestFabricEnhancer3" );
			break;
			case gamedataItemType.Wea_AssaultRifle:
			case gamedataItemType.Wea_Handgun:
			case gamedataItemType.Wea_PrecisionRifle:
			case gamedataItemType.Wea_Revolver:
			case gamedataItemType.Wea_Rifle:
			case gamedataItemType.Wea_SniperRifle:
			case gamedataItemType.Wea_SubmachineGun:
			case gamedataItemType.Wea_LightMachineGun:
			case gamedataItemType.Wea_Shotgun:
			case gamedataItemType.Wea_ShotgunDual:
				arr.PushBack( T"AttachmentSlots.GenericWeaponMod1" );
			arr.PushBack( T"AttachmentSlots.GenericWeaponMod2" );
			arr.PushBack( T"AttachmentSlots.GenericWeaponMod3" );
			arr.PushBack( T"AttachmentSlots.GenericWeaponMod4" );
			return arr;
			case gamedataItemType.Wea_Katana:
			case gamedataItemType.Wea_Hammer:
			case gamedataItemType.Wea_Knife:
			case gamedataItemType.Wea_LongBlade:
			case gamedataItemType.Wea_OneHandedClub:
			case gamedataItemType.Wea_TwoHandedClub:
			case gamedataItemType.Wea_ShortBlade:
			case gamedataItemType.Wea_Axe:
			case gamedataItemType.Wea_Chainsword:
			case gamedataItemType.Wea_Machete:
				arr.PushBack( T"AttachmentSlots.MeleeWeaponMod1" );
			arr.PushBack( T"AttachmentSlots.MeleeWeaponMod2" );
			arr.PushBack( T"AttachmentSlots.MeleeWeaponMod3" );
			return arr;
		}
		return arr;
	}

	public static function IsInventoryEmpty( object : weak< GameObject > ) : Bool
	{
		var items : array< weak< gameItemData > >;
		GameInstance.GetTransactionSystem( object.GetGame() ).GetItemList( object, items );
		return items.Size() <= 0;
	}

	public static function ProcessReadAction( choice : InteractionChoiceEvent )
	{
		var lootActionWrapper : LootChoiceActionWrapper;
		lootActionWrapper = LootChoiceActionWrapper.Unwrap( choice );
		if( LootChoiceActionWrapper.IsValid( lootActionWrapper ) )
		{
			if( lootActionWrapper.action == 'Read' )
			{
				ItemActionsHelper.ReadItem( choice.activator, lootActionWrapper.itemId );
			}
		}
	}

	public static function ToggleLootHighlight( obj : weak< GameObject >, enable : Bool )
	{
		var recordID : TweakDBID;
		recordID = T"Effectors.LootHighlightEffector";
		if( enable )
		{
			GameInstance.GetEffectorSystem( obj.GetGame() ).ApplyEffector( obj.GetEntityID(), obj, recordID );
		}
		else
		{
			GameInstance.GetEffectorSystem( obj.GetGame() ).RemoveEffector( obj.GetEntityID(), recordID );
		}
	}

	public static function CreateStatModifier( statType : gamedataStatType, modType : gameStatModifierType, value : Float ) : gameStatModifierData
	{
		var newMod : gameConstantStatModifierData;
		newMod = new gameConstantStatModifierData;
		newMod.statType = statType;
		newMod.modifierType = modType;
		newMod.value = value;
		return newMod;
	}

	public static function CreateStatModifierUsingCurve( statType : gamedataStatType, modType : gameStatModifierType, refStat : gamedataStatType, curveName : CName, columnName : CName ) : gameStatModifierData
	{
		var newMod : gameCurveStatModifierData;
		newMod = new gameCurveStatModifierData;
		newMod.statType = statType;
		newMod.curveStat = refStat;
		newMod.modifierType = modType;
		newMod.curveName = curveName;
		newMod.columnName = columnName;
		return newMod;
	}

	public static function CreateCombinedStatModifier( statType : gamedataStatType, modType : gameStatModifierType, refStat : gamedataStatType, opSymbol : gameCombinedStatOperation, value : Float, refObject : gameStatObjectsRelation ) : gameStatModifierData
	{
		var newMod : gameCombinedStatModifierData;
		newMod = new gameCombinedStatModifierData;
		newMod.statType = statType;
		newMod.modifierType = modType;
		newMod.value = value;
		newMod.refStatType = refStat;
		newMod.operation = opSymbol;
		newMod.refObject = refObject;
		return newMod;
	}

	public static function CreateCurveModifier( statRecord : CurveStatModifier_Record ) : gameStatModifierData
	{
		var newMod : gameCurveStatModifierData;
		newMod = new gameCurveStatModifierData;
		newMod.statType = statRecord.StatType().StatType();
		newMod.modifierType = ( ( gameStatModifierType )( ( ( Int32 )( EnumValueFromName( 'gameStatModifierType', statRecord.ModifierType() ) ) ) ) );
		newMod.curveName = StringToName( statRecord.Id() );
		newMod.columnName = StringToName( statRecord.Column() );
		newMod.curveStat = statRecord.RefStat().StatType();
		return newMod;
	}

	public static function StatRecordToModifier( statRecord : StatModifier_Record ) : gameStatModifierData
	{
		var statType : gamedataStatType;
		var modType : gameStatModifierType;
		var value : Float;
		var curveMod : CurveStatModifier_Record;
		var constMod : ConstantStatModifier_Record;
		constMod = ( ( ConstantStatModifier_Record )( statRecord ) );
		curveMod = ( ( CurveStatModifier_Record )( statRecord ) );
		if( constMod )
		{
			statType = constMod.StatType().StatType();
			modType = ( ( gameStatModifierType )( ( ( Int32 )( EnumValueFromName( 'gameStatModifierType', constMod.ModifierType() ) ) ) ) );
			value = constMod.Value();
			return CreateStatModifier( statType, modType, value );
		}
		else if( curveMod )
		{
			return CreateCurveModifier( curveMod );
		}
		else
		{
			return CreateStatModifier( gamedataStatType.Quantity, gameStatModifierType.Additive, 0.0 );
		}
	}

	public static function GetPowerLevelFromContentAssignment( gi : GameInstance, contentAssignmentID : TweakDBID ) : Float
	{
		var constantModRecord : weak< ConstantStatModifier_Record >;
		var curveModRecord : weak< CurveStatModifier_Record >;
		var contentAssignment : weak< ContentAssignment_Record >;
		contentAssignment = TweakDBInterface.GetContentAssignmentRecord( contentAssignmentID );
		if( contentAssignment )
		{
			constantModRecord = ( ( ConstantStatModifier_Record )( contentAssignment.PowerLevelMod() ) );
			curveModRecord = ( ( CurveStatModifier_Record )( contentAssignment.PowerLevelMod() ) );
			if( constantModRecord )
			{
				return constantModRecord.Value();
			}
			else if( curveModRecord )
			{
				return GameInstance.GetStatsDataSystem( gi ).GetMinValueFromCurve( StringToName( curveModRecord.Id() ), StringToName( curveModRecord.Column() ) );
			}
			else
			{
				return ( ( Float )( GameInstance.GetLevelAssignmentSystem( gi ).GetLevelAssignment( contentAssignment.GetID() ) ) );
			}
		}
		return 0.0;
	}

	public static function CheckDifficultyToStatValue( gi : GameInstance, skill : gamedataStatType, difficulty : EGameplayChallengeLevel, id : EntityID ) : Int32
	{
		var checkPowerLevel : Float;
		var entity : weak< Entity >;
		var device : weak< Device >;
		var vehicle : weak< VehicleObject >;
		entity = GameInstance.FindEntityByID( gi, id );
		device = ( ( Device )( entity ) );
		vehicle = ( ( VehicleObject )( entity ) );
		if( device )
		{
			checkPowerLevel = RPGManager.GetPowerLevelFromContentAssignment( gi, device.GetContentScale() );
		}
		if( vehicle )
		{
			checkPowerLevel = RPGManager.GetStatValueFromObject( gi, vehicle, gamedataStatType.PowerLevel );
		}
		return RPGManager.GetCheckValue( gi, checkPowerLevel, difficulty );
	}

	public static function GetCheckValue( gi : GameInstance, powerLevel : Float, difficulty : EGameplayChallengeLevel ) : Int32
	{
		var curveName : CName;
		switch( difficulty )
		{
			case EGameplayChallengeLevel.NONE:
				curveName = 'none_difficulty';
			break;
			case EGameplayChallengeLevel.EASY:
				curveName = 'easy_difficulty';
			break;
			case EGameplayChallengeLevel.MEDIUM:
				curveName = 'medium_difficulty';
			break;
			case EGameplayChallengeLevel.HARD:
				curveName = 'hard_difficulty';
			break;
			case EGameplayChallengeLevel.IMPOSSIBLE:
				curveName = 'impossible_difficulty';
			break;
		}
		return RoundMath( GameInstance.GetStatsDataSystem( gi ).GetValueFromCurve( 'attribute_checks', powerLevel, curveName ) );
	}

	public static function CheckDifficultyToPerkLevel( perk : gamedataPerkType, difficulty : EGameplayChallengeLevel, id : EntityID ) : Int32
	{
		return ( ( Int32 )( difficulty ) );
	}

	public static function GetBuildScore( player : GameObject, buildToCheck : PlayerBuild_Record ) : Int32
	{
		var attribute : gamedataStatType;
		var buildType : gamedataPlayerBuild;
		var statsSystem : StatsSystem;
		buildType = buildToCheck.Type();
		statsSystem = GameInstance.GetStatsSystem( player.GetGame() );
		switch( buildType )
		{
			case gamedataPlayerBuild.Netrunner:
				attribute = gamedataStatType.Intelligence;
			break;
			case gamedataPlayerBuild.Solo:
				attribute = gamedataStatType.Strength;
			break;
			case gamedataPlayerBuild.Techie:
				attribute = gamedataStatType.TechnicalAbility;
			break;
			case gamedataPlayerBuild.Reflexes:
				attribute = gamedataStatType.Reflexes;
			break;
			case gamedataPlayerBuild.Cool:
				attribute = gamedataStatType.Cool;
			break;
		}
		return ( ( Int32 )( statsSystem.GetStatValue( player.GetEntityID(), attribute ) ) );
	}

	public static function GetBluelineBuildCheckValue( player : GameObject, contentAssignment : ContentAssignment_Record, difficulty : EGameplayChallengeLevel ) : Int32
	{
		var checkPowerLevel : Float;
		checkPowerLevel = RPGManager.GetPowerLevelFromContentAssignment( player.GetGame(), contentAssignment.GetID() );
		return RPGManager.GetCheckValue( player.GetGame(), checkPowerLevel, difficulty );
	}

	public static function GetBluelinePaymentValue( player : GameObject, contentAssignment : ContentAssignment_Record, difficulty : EGameplayChallengeLevel ) : Int32
	{
		var paymentPowerLevel : Float;
		var scaledPaymentValue : Float;
		var playerMoney : Int32;
		var base : Float;
		var quotient : Float;
		var digitCount : Int32;
		var overrideValue : Int32;
		var upToAmountCheck : Bool;
		paymentPowerLevel = RPGManager.GetPowerLevelFromContentAssignment( player.GetGame(), contentAssignment.GetID() );
		scaledPaymentValue = GameInstance.GetStatsDataSystem( player.GetGame() ).GetValueFromCurve( 'price_curves', paymentPowerLevel, 'power_level_to_payment_check' );
		switch( difficulty )
		{
			case EGameplayChallengeLevel.NONE:
				scaledPaymentValue = 1.0;
			break;
			case EGameplayChallengeLevel.EASY:
				scaledPaymentValue *= 0.25;
			break;
			case EGameplayChallengeLevel.HARD:
				scaledPaymentValue *= 2.0;
			break;
			case EGameplayChallengeLevel.IMPOSSIBLE:
				scaledPaymentValue *= 10.0;
			break;
			default:
				break;
		}
		quotient = scaledPaymentValue;
		while( ( quotient > 1.0 ) && ( digitCount < 10 ) )
		{
			digitCount += 1;
			base = PowF( 10.0, ( ( Float )( digitCount ) ) );
			quotient = scaledPaymentValue / base;
		}
		base = PowF( 10.0, ( ( Float )( CeilF( ( ( Float )( digitCount ) ) / 2.0 ) ) ) );
		scaledPaymentValue /= base;
		scaledPaymentValue = ( ( Float )( RoundMath( scaledPaymentValue ) ) );
		scaledPaymentValue *= base;
		overrideValue = TweakDBInterface.GetInt( contentAssignment.GetID() + T".overrideValue", 0 );
		if( overrideValue > 0 )
		{
			scaledPaymentValue = ( ( Float )( overrideValue ) );
		}
		upToAmountCheck = TweakDBInterface.GetBool( contentAssignment.GetID() + T".upToCheck", false );
		if( upToAmountCheck )
		{
			playerMoney = GameInstance.GetTransactionSystem( player.GetGame() ).GetItemQuantity( player, MarketSystem.Money() );
			if( playerMoney < ( ( Int32 )( scaledPaymentValue ) ) )
			{
				scaledPaymentValue = ( ( Float )( playerMoney ) );
			}
		}
		return RoundF( scaledPaymentValue );
	}

	public static function GetStatRecord( type : gamedataStatType ) : Stat_Record
	{
		return TweakDBInterface.GetStatRecord( TDBID.Create( "BaseStats." + EnumValueToString( "gamedataStatType", ( ( Int32 )( type ) ) ) ) );
	}

	public static function GetProficiencyRecord( type : gamedataProficiencyType ) : Proficiency_Record
	{
		return TweakDBInterface.GetProficiencyRecord( TDBID.Create( "Proficiencies." + EnumValueToString( "gamedataProficiencyType", ( ( Int32 )( type ) ) ) ) );
	}

	public static function GetTraitRecord( type : gamedataTraitType ) : Trait_Record
	{
		return TweakDBInterface.GetTraitRecord( TDBID.Create( "Traits." + EnumValueToString( "gamedataTraitType", ( ( Int32 )( type ) ) ) ) );
	}

	public static function GetResistanceTypeFromDamageType( damageType : gamedataDamageType ) : gamedataStatType
	{
		switch( damageType )
		{
			case gamedataDamageType.Physical:
				return gamedataStatType.PhysicalResistance;
			case gamedataDamageType.Thermal:
				return gamedataStatType.ThermalResistance;
			case gamedataDamageType.Chemical:
				return gamedataStatType.ChemicalResistance;
			case gamedataDamageType.Electric:
				return gamedataStatType.ElectricResistance;
			default:
				return gamedataStatType.Invalid;
		}
	}

	public static function CalculatePowerDifferential( target : GameObject ) : EPowerDifferential
	{
		var statSys : StatsSystem;
		var player : weak< GameObject >;
		var playerLevel : Float;
		var targetLevel : Float;
		var levelDifferential : Int32;
		statSys = GameInstance.GetStatsSystem( target.GetGame() );
		player = GameInstance.GetPlayerSystem( target.GetGame() ).GetLocalPlayerControlledGameObject();
		playerLevel = statSys.GetStatValue( player.GetEntityID(), gamedataStatType.Level );
		targetLevel = statSys.GetStatValue( target.GetEntityID(), gamedataStatType.Level );
		levelDifferential = RoundMath( playerLevel - targetLevel );
		if( levelDifferential <= ( ( Int32 )( EPowerDifferential.IMPOSSIBLE ) ) )
		{
			if( GameObject.GetAttitudeBetween( player, target ) == EAIAttitude.AIA_Friendly )
			{
				return EPowerDifferential.HARD;
			}
			else
			{
				return EPowerDifferential.IMPOSSIBLE;
			}
		}
		else if( ( levelDifferential > ( ( Int32 )( EPowerDifferential.IMPOSSIBLE ) ) ) && ( levelDifferential <= ( ( Int32 )( EPowerDifferential.HARD ) ) ) )
		{
			return EPowerDifferential.HARD;
		}
		else if( ( levelDifferential > ( ( Int32 )( EPowerDifferential.HARD ) ) ) && ( levelDifferential <= ( ( Int32 )( EPowerDifferential.NORMAL ) ) ) )
		{
			return EPowerDifferential.NORMAL;
		}
		else if( ( levelDifferential > ( ( Int32 )( EPowerDifferential.NORMAL ) ) ) && ( levelDifferential <= ( ( Int32 )( EPowerDifferential.EASY ) ) ) )
		{
			return EPowerDifferential.EASY;
		}
		else
		{
			return EPowerDifferential.TRASH;
		}
	}

	public static function CalculatePowerDifferential( level : Int32 ) : EPowerDifferential
	{
		if( level <= ( ( Int32 )( EPowerDifferential.IMPOSSIBLE ) ) )
		{
			return EPowerDifferential.IMPOSSIBLE;
		}
		else if( ( level > ( ( Int32 )( EPowerDifferential.IMPOSSIBLE ) ) ) && ( level <= ( ( Int32 )( EPowerDifferential.HARD ) ) ) )
		{
			return EPowerDifferential.HARD;
		}
		else if( ( level > ( ( Int32 )( EPowerDifferential.HARD ) ) ) && ( level <= ( ( Int32 )( EPowerDifferential.NORMAL ) ) ) )
		{
			return EPowerDifferential.NORMAL;
		}
		else if( ( level > ( ( Int32 )( EPowerDifferential.NORMAL ) ) ) && ( level <= ( ( Int32 )( EPowerDifferential.EASY ) ) ) )
		{
			return EPowerDifferential.EASY;
		}
		else
		{
			return EPowerDifferential.TRASH;
		}
	}

	public static function CalculateThreatValue( obj : GameObject ) : Float
	{
		var threatVal : Float;
		var statsSystem : StatsSystem;
		var player : StatsObjectID;
		var npc : StatsObjectID;
		var npcPowerLevel : Float;
		var playerPowerLevel : Float;
		var normPowerLevelDiff : Float;
		var maxPowerLevel : Float;
		var minPowerLevel : Float;
		statsSystem = GameInstance.GetStatsSystem( obj.GetGame() );
		player = GetPlayer( obj.GetGame() ).GetEntityID();
		npc = obj.GetEntityID();
		threatVal = 0.0;
		maxPowerLevel = 60.0;
		minPowerLevel = 0.0;
		npcPowerLevel = statsSystem.GetStatValue( npc, gamedataStatType.PowerLevel );
		playerPowerLevel = statsSystem.GetStatValue( player, gamedataStatType.PowerLevel );
		normPowerLevelDiff = MathHelper.NormalizeF( npcPowerLevel - playerPowerLevel, maxPowerLevel - minPowerLevel, minPowerLevel - maxPowerLevel );
		threatVal = normPowerLevelDiff;
		return threatVal;
	}

	public static function GetScannerResistanceDetails( obj : GameObject, statType : gamedataStatType, optional player : GameObject ) : ScannerStatDetails
	{
		var currentResist : Float;
		var statsSystem : StatsSystem;
		var scanStatDetails : ScannerStatDetails;
		var powerLevelDiff : Float;
		var executorLevel : Float;
		var targetLevel : Float;
		var extraCost : Float;
		statsSystem = GameInstance.GetStatsSystem( obj.GetGame() );
		currentResist = statsSystem.GetStatValue( obj.GetEntityID(), statType );
		if( statType == gamedataStatType.HackingResistance && player )
		{
			scanStatDetails.baseValue = currentResist;
			executorLevel = statsSystem.GetStatValue( player.GetEntityID(), gamedataStatType.PowerLevel );
			targetLevel = statsSystem.GetStatValue( obj.GetEntityID(), gamedataStatType.PowerLevel );
			powerLevelDiff = ( ( Float )( RoundMath( executorLevel ) - RoundF( targetLevel ) ) );
			extraCost = GameInstance.GetStatsDataSystem( player.GetGame() ).GetValueFromCurve( 'puppet_dynamic_scaling', powerLevelDiff, 'pl_diff_to_memory_cost_modifier' );
			currentResist += extraCost;
		}
		scanStatDetails.statType = statType;
		scanStatDetails.value = currentResist;
		return scanStatDetails;
	}

	public static function GetCharacterWeakspotCount( puppet : gamePuppet ) : Int32
	{
		var weakspots : array< weak< Weakspot_Record > >;
		TweakDBInterface.GetCharacterRecord( puppet.GetRecordID() ).Weakspots( weakspots );
		return weakspots.Size();
	}

	public static function GetStatValues( obj : GameObject, stats : array< gamedataStatType > ) : array< gameStatTotalValue >
	{
		var statsSystem : StatsSystem;
		var statInfos : array< gameStatTotalValue >;
		var statInfo : gameStatTotalValue;
		var i : Int32;
		statsSystem = GameInstance.GetStatsSystem( obj.GetGame() );
		for( i = 0; i < stats.Size(); i += 1 )
		{
			statInfo.value = statsSystem.GetStatValue( obj.GetEntityID(), stats[ i ] );
			statInfo.statType = stats[ i ];
			statInfos.PushBack( statInfo );
		}
		return statInfos;
	}

	public static function GetMinStats( obj : GameObject, stats : array< gamedataStatType > ) : array< gameStatTotalValue >
	{
		var i : Int32;
		var statInfos : array< gameStatTotalValue >;
		var minStats : array< gameStatTotalValue >;
		var minValue : Float;
		statInfos = GetStatValues( obj, stats );
		minValue = MathHelper.PositiveInfinity();
		for( i = 0; i < statInfos.Size(); i += 1 )
		{
			if( statInfos[ i ].value < minValue )
			{
				minValue = statInfos[ i ].value;
				minStats.Clear();
				minStats.PushBack( statInfos[ i ] );
			}
			else if( statInfos[ i ].value == minValue )
			{
				minStats.PushBack( statInfos[ i ] );
			}
		}
		return minStats;
	}

	public static function GetMaxStats( obj : GameObject, stats : array< gamedataStatType > ) : array< gameStatTotalValue >
	{
		var i : Int32;
		var statInfos : array< gameStatTotalValue >;
		var maxStats : array< gameStatTotalValue >;
		var maxValue : Float;
		statInfos = GetStatValues( obj, stats );
		maxValue = MathHelper.NegativeInfinity();
		for( i = 0; i < statInfos.Size(); i += 1 )
		{
			if( statInfos[ i ].value > maxValue )
			{
				maxValue = statInfos[ i ].value;
				maxStats.Clear();
				maxStats.PushBack( statInfos[ i ] );
			}
			else if( statInfos[ i ].value == maxValue )
			{
				maxStats.PushBack( statInfos[ i ] );
			}
		}
		return maxStats;
	}

	public static function GetLowestResistances( obj : GameObject ) : array< gameStatTotalValue >
	{
		return GetMinStats( obj, ResistancesList() );
	}

	public static function GetHighestResistances( obj : GameObject ) : array< gameStatTotalValue >
	{
		return GetMaxStats( obj, ResistancesList() );
	}

	public static function CanPlayerCraftFromInventory( obj : weak< GameObject > ) : Bool
	{
		var val : Float;
		val = GameInstance.GetStatsSystem( obj.GetGame() ).GetStatValue( obj.GetEntityID(), gamedataStatType.CanCraftFromInventory );
		return val > 0.0;
	}

	public static function CanPlayerUpgradeFromInventory( obj : weak< GameObject > ) : Bool
	{
		var val : Float;
		val = GameInstance.GetStatsSystem( obj.GetGame() ).GetStatValue( obj.GetEntityID(), gamedataStatType.CanUpgradeFromInventory );
		return val > 0.0;
	}

	public static function AwardExperienceFromDamage( hitEvent : gameHitEvent, damagePercentage : Float )
	{
		var attackData : AttackData;
		var queueExpRequests : array< QueueCombatExperience >;
		var queueExpRequest : QueueCombatExperience;
		var inst : GameInstance;
		var expAwarded : Bool;
		var playerDevSystem : PlayerDevelopmentSystem;
		var i : Int32;
		var targetPuppet : weak< ScriptedPuppet >;
		var targetPowerLevel : Float;
		var curveSetName : CName;
		var weaponRecord : weak< Item_Record >;
		var attackSource : weak< ItemObject >;
		var playerXPmultiplier : Float;
		attackData = hitEvent.attackData;
		curveSetName = 'activity_to_proficiency_xp';
		inst = hitEvent.target.GetGame();
		playerDevSystem = ( ( PlayerDevelopmentSystem )( GameInstance.GetScriptableSystemsContainer( inst ).Get( 'PlayerDevelopmentSystem' ) ) );
		expAwarded = true;
		targetPuppet = ( ( ScriptedPuppet )( hitEvent.target ) );
		if( !( targetPuppet ) )
		{
			return;
		}
		if( targetPuppet.IsActive() && targetPuppet.AwardsExperience() )
		{
			targetPowerLevel = GameInstance.GetStatsSystem( inst ).GetStatValue( targetPuppet.GetEntityID(), gamedataStatType.PowerLevel );
			playerXPmultiplier = GameInstance.GetStatsSystem( inst ).GetStatValue( GetPlayer( inst ).GetEntityID(), gamedataStatType.XPbonusMultiplier );
			queueExpRequest = new QueueCombatExperience;
			queueExpRequest.owner = GameInstance.GetPlayerSystem( inst ).GetLocalPlayerControlledGameObject();
			if( attackData.GetInstigator().IsPlayer() && !( hitEvent.target.IsPlayer() ) )
			{
				weaponRecord = TweakDBInterface.GetItemRecord( ItemID.GetTDBID( attackData.GetWeapon().GetItemID() ) );
				switch( weaponRecord.ItemType().Type() )
				{
					case gamedataItemType.Wea_Katana:
					case gamedataItemType.Wea_LongBlade:
					case gamedataItemType.Wea_ShortBlade:
					case gamedataItemType.Wea_Knife:
					case gamedataItemType.Wea_Axe:
					case gamedataItemType.Wea_Chainsword:
					case gamedataItemType.Wea_Machete:
					case gamedataItemType.Cyb_MantisBlades:
					case gamedataItemType.Cyb_NanoWires:
						queueExpRequest.m_experienceType = gamedataProficiencyType.Kenjutsu;
					queueExpRequest.m_amount = GameInstance.GetStatsDataSystem( inst ).GetValueFromCurve( curveSetName, targetPowerLevel, 'kenjutsu_damage_to_xp' );
					break;
					case gamedataItemType.Wea_TwoHandedClub:
					case gamedataItemType.Wea_Hammer:
					case gamedataItemType.Wea_OneHandedClub:
					case gamedataItemType.Wea_Melee:
					case gamedataItemType.Wea_Fists:
					case gamedataItemType.Cyb_StrongArms:
						queueExpRequest.m_experienceType = gamedataProficiencyType.Brawling;
					queueExpRequest.m_amount = GameInstance.GetStatsDataSystem( inst ).GetValueFromCurve( curveSetName, targetPowerLevel, 'brawling_damage_to_xp' );
					break;
					case gamedataItemType.Wea_Handgun:
					case gamedataItemType.Wea_Revolver:
						queueExpRequest.m_experienceType = gamedataProficiencyType.Gunslinger;
					queueExpRequest.m_amount = GameInstance.GetStatsDataSystem( inst ).GetValueFromCurve( curveSetName, targetPowerLevel, 'gunslinger_damage_to_xp' );
					break;
					case gamedataItemType.Wea_Rifle:
					case gamedataItemType.Wea_SniperRifle:
					case gamedataItemType.Wea_PrecisionRifle:
					case gamedataItemType.Wea_AssaultRifle:
					case gamedataItemType.Wea_SubmachineGun:
						queueExpRequest.m_experienceType = gamedataProficiencyType.Assault;
					queueExpRequest.m_amount = GameInstance.GetStatsDataSystem( inst ).GetValueFromCurve( curveSetName, targetPowerLevel, 'assault_damage_to_xp' );
					break;
					case gamedataItemType.Wea_Shotgun:
					case gamedataItemType.Wea_ShotgunDual:
					case gamedataItemType.Wea_HeavyMachineGun:
					case gamedataItemType.Wea_LightMachineGun:
					case gamedataItemType.Cyb_Launcher:
						queueExpRequest.m_experienceType = gamedataProficiencyType.Demolition;
					queueExpRequest.m_amount = GameInstance.GetStatsDataSystem( inst ).GetValueFromCurve( curveSetName, targetPowerLevel, 'demolition_damage_to_xp' );
					break;
					default:
						expAwarded = false;
					break;
				}
				if( attackData.HasFlag( hitFlag.WeakspotHit ) || attackData.HasFlag( hitFlag.Headshot ) )
				{
					queueExpRequest.m_amount *= 1.20000005;
				}
				if( expAwarded )
				{
					if( StatusEffectSystem.ObjectHasStatusEffectWithTag( attackData.GetInstigator(), 'TrainingGuns' ) && attackData.GetWeapon().IsRanged() )
					{
						queueExpRequest.m_amount *= 2.0;
					}
					if( StatusEffectSystem.ObjectHasStatusEffectWithTag( attackData.GetInstigator(), 'TrainingMelee' ) && attackData.GetWeapon().IsMelee() )
					{
						queueExpRequest.m_amount *= 2.0;
					}
					queueExpRequests.PushBack( queueExpRequest );
				}
				attackSource = ( ( ItemObject )( attackData.GetSource() ) );
				if( attackSource && RPGManager.GetItemRecord( attackSource.GetItemID() ).ItemType().Type() == gamedataItemType.Gad_Grenade )
				{
					queueExpRequest = new QueueCombatExperience;
					queueExpRequest.owner = GetPlayer( inst );
					queueExpRequest.m_experienceType = gamedataProficiencyType.Engineering;
					queueExpRequest.m_amount = GameInstance.GetStatsDataSystem( inst ).GetValueFromCurve( curveSetName, targetPowerLevel, 'engineering_damage_to_xp' );
					queueExpRequests.PushBack( queueExpRequest );
				}
				if( hitEvent.hasPiercedTechSurface )
				{
					queueExpRequest = new QueueCombatExperience;
					queueExpRequest.owner = GetPlayer( inst );
					queueExpRequest.m_experienceType = gamedataProficiencyType.Engineering;
					queueExpRequest.m_amount = GameInstance.GetStatsDataSystem( inst ).GetValueFromCurve( curveSetName, targetPowerLevel, 'engineering_damage_to_xp' );
					queueExpRequests.PushBack( queueExpRequest );
				}
				if( hitEvent.attackData.GetAttackDefinition().GetRecord().GetID() == T"Attacks.SuperheroLanding" )
				{
					queueExpRequest = new QueueCombatExperience;
					queueExpRequest.owner = GetPlayer( inst );
					queueExpRequest.m_experienceType = gamedataProficiencyType.Brawling;
					queueExpRequest.m_amount = GameInstance.GetStatsDataSystem( inst ).GetValueFromCurve( curveSetName, targetPowerLevel, 'assassination_damage_to_xp' );
					queueExpRequests.PushBack( queueExpRequest );
				}
				if( hitEvent.attackData.HasFlag( hitFlag.StealthHit ) )
				{
					queueExpRequest = new QueueCombatExperience;
					queueExpRequest.owner = GetPlayer( inst );
					queueExpRequest.m_experienceType = gamedataProficiencyType.Stealth;
					queueExpRequest.m_amount = GameInstance.GetStatsDataSystem( inst ).GetValueFromCurve( curveSetName, targetPowerLevel, 'assassination_damage_to_xp' );
					queueExpRequests.PushBack( queueExpRequest );
				}
			}
			for( i = 0; i < queueExpRequests.Size(); i += 1 )
			{
				queueExpRequest = queueExpRequests[ i ];
				queueExpRequest.m_amount *= RPGManager.GetRarityMultiplier( ( ( NPCPuppet )( hitEvent.target ) ), 'power_level_to_dmg_xp_mult' );
				queueExpRequest.m_amount *= damagePercentage;
				queueExpRequest.m_amount *= playerXPmultiplier;
				queueExpRequest.m_entity = targetPuppet.GetEntityID();
				playerDevSystem.QueueRequest( queueExpRequest );
			}
		}
	}

	public static function GiveReward( gi : GameInstance, rewardID : TweakDBID, optional target : StatsObjectID, optional moneyMultiplier : Float )
	{
		var i : Int32;
		var quantity : Int32;
		var rewardName : String;
		var rewardRecord : RewardBase_Record;
		var itemArr : array< weak< InventoryItem_Record > >;
		var expArr : array< weak< XPPoints_Record > >;
		var currencyArr : array< weak< CurrencyReward_Record > >;
		var quantityMods : array< weak< StatModifier_Record > >;
		var recipesArr : array< weak< Item_Record > >;
		var achievementsArr : array< weak< Achievement_Record > >;
		var photoModeItmsArr : array< weak< PhotoModeItem_Record > >;
		var expEvt : ExperiencePointsEvent;
		var transSys : TransactionSystem;
		var visualizer : DebugVisualizerSystem;
		var expType : gamedataProficiencyType;
		var player : PlayerPuppet;
		var addRecipeRequest : AddRecipeRequest;
		var craftingSystem : CraftingSystem;
		var NCPDJobDone : NCPDJobDoneEvent;
		var itemID : ItemID;
		var powerDiff : EPowerDifferential;
		var contentAssignment : TweakDBID;
		var experienceValue : Float;
		var playerLevel : Float;
		var playerXPmultiplier : Float;
		var streetCredXPmultiplier : Float;
		var contentLevel : Int32;
		var levelDiff : Int32;
		var currencyItemID : ItemID;
		var moneyQuantity : Int32;
		craftingSystem = ( ( CraftingSystem )( GameInstance.GetScriptableSystemsContainer( gi ).Get( 'CraftingSystem' ) ) );
		transSys = GameInstance.GetTransactionSystem( gi );
		visualizer = GameInstance.GetDebugVisualizerSystem( gi );
		rewardRecord = TweakDBInterface.GetRewardBaseRecord( rewardID );
		if( !( rewardRecord ) )
		{
			Log( "GiveReward(): No reward def record passed!" );
			return;
		}
		player = ( ( PlayerPuppet )( GameInstance.GetPlayerSystem( gi ).GetLocalPlayerControlledGameObject() ) );
		NCPDJobDone = new NCPDJobDoneEvent;
		rewardName = rewardRecord.Name();
		if( rewardName != "" )
		{
			visualizer.DrawText( Vector4( 5.0, 350.0, 0.0, 0.0 ), rewardName, gameDebugViewETextAlignment.Left, Color( 255, 128, 0, 255 ), 1.5 );
		}
		else
		{
			rewardName = "GiveReward(): No reward name found";
			visualizer.DrawText( Vector4( 5.0, 350.0, 0.0, 0.0 ), rewardName, gameDebugViewETextAlignment.Left, Color( 255, 128, 0, 255 ), 1.5 );
		}
		rewardRecord.Items( itemArr );
		for( i = 0; i < itemArr.Size(); i += 1 )
		{
			quantity = itemArr[ i ].Quantity();
			itemID = ItemID.FromTDBID( itemArr[ i ].Item().GetID() );
			transSys.GiveItem( player, ItemID.FromTDBID( itemArr[ i ].Item().GetID() ), quantity );
			GameInstance.GetTelemetrySystem( player.GetGame() ).LogItemReward( player, itemID );
		}
		rewardRecord.Recipes( recipesArr );
		for( i = 0; i < recipesArr.Size(); i += 1 )
		{
			addRecipeRequest = new AddRecipeRequest;
			addRecipeRequest.owner = player;
			addRecipeRequest.amount = 1;
			addRecipeRequest.recipe = recipesArr[ i ].GetID();
			craftingSystem.QueueRequest( addRecipeRequest );
			GameInstance.GetTelemetrySystem( player.GetGame() ).LogItemReward( player, ItemID.FromTDBID( recipesArr[ i ].GetID() ) );
		}
		rewardRecord.Experience( expArr );
		playerXPmultiplier = GameInstance.GetStatsSystem( player.GetGame() ).GetStatValue( player.GetEntityID(), gamedataStatType.XPbonusMultiplier );
		streetCredXPmultiplier = GameInstance.GetStatsSystem( player.GetGame() ).GetStatValue( player.GetEntityID(), gamedataStatType.StreetCredXPBonusMultiplier ) / 100.0;
		for( i = 0; i < expArr.Size(); i += 1 )
		{
			expEvt = new ExperiencePointsEvent;
			quantityMods.Clear();
			expArr[ i ].QuantityModifiers( quantityMods );
			experienceValue = RPGManager.CalculateStatModifiers( quantityMods, player.GetGame(), player, target );
			expType = expArr[ i ].Type().Type();
			expEvt.type = expType;
			expEvt.isDebug = false;
			if( expType != gamedataProficiencyType.Level && expType != gamedataProficiencyType.StreetCred )
			{
				experienceValue *= playerXPmultiplier;
			}
			else if( expType == gamedataProficiencyType.StreetCred )
			{
				experienceValue *= ( 1.0 + streetCredXPmultiplier );
			}
			contentAssignment = TweakDBInterface.GetForeignKey( rewardID + T".contentAssignment", T"" );
			if( TDBID.IsValid( contentAssignment ) )
			{
				playerLevel = GameInstance.GetStatsSystem( player.GetGame() ).GetStatValue( player.GetEntityID(), gamedataStatType.PowerLevel );
				contentLevel = GameInstance.GetLevelAssignmentSystem( player.GetGame() ).GetLevelAssignment( contentAssignment );
				levelDiff = RoundMath( playerLevel - ( ( Float )( contentLevel ) ) );
				powerDiff = CalculatePowerDifferential( levelDiff );
				switch( powerDiff )
				{
					case EPowerDifferential.TRASH:
						experienceValue *= 0.80000001;
					break;
					case EPowerDifferential.EASY:
						experienceValue *= 0.89999998;
					break;
					case EPowerDifferential.HARD:
						experienceValue *= 1.10000002;
					break;
					case EPowerDifferential.IMPOSSIBLE:
						experienceValue *= 1.20000005;
					break;
					default:
						break;
				}
			}
			expEvt.amount = ( ( Int32 )( experienceValue ) );
			GameInstance.GetTelemetrySystem( gi ).LogXPReward( expArr[ i ].GetID(), expEvt.amount, expEvt.type );
			player.QueueEvent( expEvt );
			if( expType == gamedataProficiencyType.Level )
			{
				NCPDJobDone.levelXPAwarded = expEvt.amount;
			}
			else if( expType == gamedataProficiencyType.StreetCred )
			{
				NCPDJobDone.streetCredXPAwarded = expEvt.amount;
			}
		}
		moneyQuantity = 0;
		rewardRecord.CurrencyPackage( currencyArr );
		for( i = 0; i < currencyArr.Size(); i += 1 )
		{
			quantityMods.Clear();
			currencyArr[ i ].QuantityModifiers( quantityMods );
			quantity = ( ( Int32 )( RPGManager.CalculateStatModifiers( quantityMods, player.GetGame(), player, target ) ) );
			if( quantity > 0 )
			{
				quantity = ( ( moneyMultiplier > 0.0 ) ? ( ( ( Int32 )( ( ( Float )( quantity ) ) * moneyMultiplier ) ) ) : ( quantity ) );
				currencyItemID = ItemID.FromTDBID( currencyArr[ i ].Currency().GetID() );
				transSys.GiveItem( player, currencyItemID, quantity );
				if( currencyItemID == MarketSystem.Money() )
				{
					moneyQuantity += quantity;
				}
			}
		}
		rewardRecord.Achievement( achievementsArr );
		for( i = 0; i < achievementsArr.Size(); i += 1 )
		{
			SendAddAchievementRequest( gi, achievementsArr[ i ].Type(), achievementsArr[ i ] );
		}
		rewardRecord.PhotoModeItem( photoModeItmsArr );
		for( i = 0; i < photoModeItmsArr.Size(); i += 1 )
		{
			SendPhotoModeItemUnlockRequest( gi, photoModeItmsArr[ i ] );
		}
		if( StrBeginsWith( rewardName, "ma_" ) )
		{
			GameInstance.GetUISystem( gi ).QueueEvent( NCPDJobDone );
		}
		GameInstance.GetTelemetrySystem( gi ).LogRewardGiven( StringToName( rewardName ), rewardID, moneyQuantity );
	}

	public static function AwardXP( gi : GameInstance, amount : Float, type : gamedataProficiencyType )
	{
		var xpEvent : ExperiencePointsEvent;
		var statsSystem : StatsSystem;
		var playerXPmultiplier : Float;
		var awardXP : Float;
		statsSystem = GameInstance.GetStatsSystem( gi );
		playerXPmultiplier = statsSystem.GetStatValue( GetPlayer( gi ).GetEntityID(), gamedataStatType.XPbonusMultiplier );
		awardXP = amount * playerXPmultiplier;
		xpEvent = new ExperiencePointsEvent;
		xpEvent.amount = ( ( Int32 )( awardXP ) );
		xpEvent.type = type;
		GetPlayer( gi ).QueueEvent( xpEvent );
	}

	private static function SendAddAchievementRequest( gi : GameInstance, achievement : gamedataAchievement, achievementRecord : weak< Achievement_Record > )
	{
		var request : AddAchievementRequest;
		request = new AddAchievementRequest;
		request.achievement = achievement;
		request.achievementRecord = achievementRecord;
		GameInstance.GetScriptableSystemsContainer( gi ).Get( 'DataTrackingSystem' ).QueueRequest( request );
	}

	private static function SendPhotoModeItemUnlockRequest( gi : GameInstance, photoModeItm : weak< PhotoModeItem_Record > )
	{
		var tweakID : TweakDBID;
		tweakID = photoModeItm.GetID();
		GameInstance.GetPhotoModeSystem( gi ).UnlockPhotoModeItem( tweakID );
	}

	public static function GiveScavengeReward( gi : GameInstance, rewardID : TweakDBID, scavengeTargetEntityID : EntityID )
	{
		GiveReward( gi, rewardID );
	}

	public static function PrepareGameEffectAttack( gi : GameInstance, instigator : GameObject, source : GameObject, attackName : TweakDBID, optional position : Vector4, optional hitFlags : array< SHitFlag >, optional target : GameObject, optional tickRateOverride : Float ) : Attack_GameEffect
	{
		var attack : Attack_GameEffect;
		var attackRecord : Attack_GameEffect_Record;
		var attackContext : AttackInitContext;
		var attackEffect : EffectInstance;
		var statMods : array< gameStatModifierData >;
		var sharedData : EffectData;
		var effectDef : EffectSharedDataDef;
		attackRecord = ( ( Attack_GameEffect_Record )( TweakDBInterface.GetAttackRecord( attackName ) ) );
		if( attackRecord )
		{
			attackContext.record = attackRecord;
			attackContext.instigator = instigator;
			attackContext.source = source;
			attack = ( ( Attack_GameEffect )( IAttack.Create( attackContext ) ) );
			attackEffect = attack.PrepareAttack( instigator );
			attack.GetStatModList( statMods );
			if( position == Vector4.EmptyVector() )
			{
				position = source.GetWorldPosition();
			}
			sharedData = attackEffect.GetSharedData();
			effectDef = GetAllBlackboardDefs().EffectSharedData;
			EffectData.SetFloat( sharedData, effectDef.radius, attackRecord.Range() );
			EffectData.SetVector( sharedData, effectDef.position, position );
			EffectData.SetVariant( sharedData, effectDef.attack, ( ( IAttack )( attack ) ) );
			EffectData.SetVariant( sharedData, effectDef.attackStatModList, statMods );
			EffectData.SetVariant( sharedData, effectDef.flags, hitFlags );
			EffectData.SetEntity( sharedData, effectDef.entity, target );
			if( tickRateOverride > 0.0 )
			{
				EffectData.SetFloat( sharedData, effectDef.tickRateOverride, tickRateOverride );
			}
			EffectData.SetName( sharedData, effectDef.slotName, 'Head' );
			return attack;
		}
		return attack;
	}

	public static function ExtractItemsOfEquipArea( type : gamedataEquipmentArea, input : array< weak< gameItemData > >, out output : array< weak< gameItemData > > ) : Bool
	{
		var i : Int32;
		var itemsFound : Bool;
		for( i = 0; i < input.Size(); i += 1 )
		{
			if( TweakDBInterface.GetItemRecord( ItemID.GetTDBID( input[ i ].GetID() ) ).EquipArea().Type() == type )
			{
				output.PushBack( input[ i ] );
				itemsFound = true;
			}
		}
		return itemsFound;
	}

	public static function GetAmmoCount( owner : GameObject, itemID : ItemID ) : String
	{
		var itemRecord : Item_Record;
		var weaponRecord : WeaponItem_Record;
		var category : gamedataItemCategory;
		var ammoQuery : ItemID;
		var ammoCount : Int32;
		var transSystem : TransactionSystem;
		transSystem = GameInstance.GetTransactionSystem( owner.GetGame() );
		itemRecord = TweakDBInterface.GetItemRecord( ItemID.GetTDBID( itemID ) );
		category = itemRecord.ItemCategory().Type();
		if( category == gamedataItemCategory.Gadget || category == gamedataItemCategory.Consumable )
		{
			ammoQuery = ItemID.CreateQuery( ItemID.GetTDBID( itemID ) );
			ammoCount = transSystem.GetItemQuantity( owner, ammoQuery );
			return ( ( String )( ammoCount ) );
		}
		else if( category == gamedataItemCategory.Weapon )
		{
			weaponRecord = ( ( WeaponItem_Record )( itemRecord ) );
			ammoQuery = ItemID.CreateQuery( weaponRecord.Ammo().GetID() );
			ammoCount = transSystem.GetItemQuantity( owner, ammoQuery );
		}
		if( ammoCount > 0 )
		{
			return ( ( String )( ammoCount ) );
		}
		else
		{
			return "";
		}
	}

	public static function GetAmmoCountValue( owner : GameObject, itemID : ItemID ) : Int32
	{
		var itemRecord : Item_Record;
		var weaponRecord : WeaponItem_Record;
		var category : gamedataItemCategory;
		var ammoQuery : ItemID;
		var ammoCount : Int32;
		var transSystem : TransactionSystem;
		transSystem = GameInstance.GetTransactionSystem( owner.GetGame() );
		itemRecord = TweakDBInterface.GetItemRecord( ItemID.GetTDBID( itemID ) );
		if( itemRecord )
		{
			category = itemRecord.ItemCategory().Type();
		}
		if( category == gamedataItemCategory.Gadget || category == gamedataItemCategory.Consumable )
		{
			ammoQuery = ItemID.CreateQuery( ItemID.GetTDBID( itemID ) );
			ammoCount = transSystem.GetItemQuantity( owner, ammoQuery );
			return ammoCount;
		}
		else if( category == gamedataItemCategory.Weapon && itemRecord )
		{
			weaponRecord = ( ( WeaponItem_Record )( itemRecord ) );
			ammoQuery = ItemID.CreateQuery( weaponRecord.Ammo().GetID() );
			ammoCount = transSystem.GetItemQuantity( owner, ammoQuery );
		}
		return ammoCount;
	}

	public static function GetWeaponAmmoTDBID( weaponID : ItemID ) : TweakDBID
	{
		return TweakDBInterface.GetWeaponItemRecord( ItemID.GetTDBID( weaponID ) ).Ammo().GetID();
	}

	public static function GetItemRecord( itemID : ItemID ) : Item_Record
	{
		return TweakDBInterface.GetItemRecord( ItemID.GetTDBID( itemID ) );
	}

	public static function GetAttachmentSlotID( slot : String ) : TweakDBID
	{
		return TDBID.Create( "AttachmentSlots." + slot );
	}

	public static function ForceEquipItemOnPlayer( puppet : GameObject, itemTDBID : TweakDBID, addToInv : Bool )
	{
		var itemID : ItemID;
		var equipRequest : EquipRequest;
		if( ( puppet == NULL ) || !( ( ( PlayerPuppet )( puppet ) ) ) )
		{
			return;
		}
		itemID = ItemID.FromTDBID( itemTDBID );
		equipRequest = new EquipRequest;
		equipRequest.itemID = itemID;
		equipRequest.owner = puppet;
		equipRequest.addToInventory = addToInv;
		GameInstance.GetScriptableSystemsContainer( puppet.GetGame() ).Get( 'EquipmentSystem' ).QueueRequest( equipRequest );
	}

	public static function GetItemActions( itemID : ItemID ) : array< weak< ObjectAction_Record > >
	{
		var actions : array< weak< ObjectAction_Record > >;
		TweakDBInterface.GetItemRecord( ItemID.GetTDBID( itemID ) ).ObjectActions( actions );
		return actions;
	}

	public static function IsTechPierceEnabled( gi : GameInstance, owner : GameObject, itemID : ItemID ) : Bool
	{
		return GameInstance.GetTransactionSystem( gi ).GetItemData( owner, itemID ).GetStatValueByType( gamedataStatType.TechPierceEnabled ) > 0.0;
	}

	public static function IsRicochetChanceEnabled( gi : GameInstance, owner : GameObject, itemID : ItemID ) : Bool
	{
		var itemData : gameItemData;
		itemData = GameInstance.GetTransactionSystem( gi ).GetItemData( owner, itemID );
		if( itemData )
		{
			return itemData.GetStatValueByType( gamedataStatType.RicochetChance ) > 0.0;
		}
		return false;
	}

	public static function HasSmartLinkRequirement( itemData : gameItemData ) : Bool
	{
		if( itemData )
		{
			return itemData.GetStatValueByType( gamedataStatType.ItemRequiresSmartLink ) > 0.0;
		}
		return false;
	}

	public static function CanPartBeUnequipped( itemID : ItemID ) : Bool
	{
		var type : gamedataItemType;
		type = RPGManager.GetItemType( itemID );
		return ( type != gamedataItemType.Prt_Mod && type != gamedataItemType.Prt_FabricEnhancer ) && type != gamedataItemType.Prt_Fragment;
	}

	public static function CanItemBeDropped( puppet : GameObject, itemData : gameItemData ) : Bool
	{
		var blackboard : IBlackboard;
		var consumableBeingUsed : ItemID;
		blackboard = GameInstance.GetBlackboardSystem( puppet.GetGame() ).Get( GetAllBlackboardDefs().UI_QuickSlotsData );
		consumableBeingUsed = ( ( ItemID )( blackboard.GetVariant( GetAllBlackboardDefs().UI_QuickSlotsData.consumableBeingUsed ) ) );
		if( itemData )
		{
			if( ItemID.IsValid( consumableBeingUsed ) && ( TweakDBInterface.GetConsumableItemRecord( ItemID.GetTDBID( itemData.GetID() ) ) == TweakDBInterface.GetConsumableItemRecord( ItemID.GetTDBID( consumableBeingUsed ) ) ) )
			{
				return false;
			}
			return ( !( itemData.HasTag( 'Quest' ) ) && !( itemData.HasTag( 'UnequipBlocked' ) ) ) && ItemActionsHelper.GetDropAction( itemData.GetID() );
		}
		return false;
	}

	public static function CanItemBeDisassembled( gameInstance : GameInstance, itemID : ItemID ) : Bool
	{
		var CS : CraftingSystem;
		CS = CraftingSystem.GetInstance( gameInstance );
		return CS.CanItemBeDisassembled( GetPlayer( gameInstance ), itemID );
	}

	public static function HasDownloadFundsAction( itemID : ItemID ) : Bool
	{
		var i : Int32;
		var actions : array< weak< ObjectAction_Record > >;
		actions = RPGManager.GetItemActions( itemID );
		for( i = 0; i < actions.Size(); i += 1 )
		{
			if( actions[ i ].ActionName() == 'DownloadFunds' )
			{
				return true;
			}
		}
		return false;
	}

	public static function CanDownloadFunds( gi : GameInstance, itemID : ItemID ) : Bool
	{
		var i : Int32;
		var fact : CName;
		var actions : array< weak< ObjectAction_Record > >;
		actions = RPGManager.GetItemActions( itemID );
		for( i = 0; i < actions.Size(); i += 1 )
		{
			if( actions[ i ].ActionName() == 'DownloadFunds' )
			{
				fact = TweakDBInterface.GetCName( actions[ i ].GetID() + T".factToCheck", '' );
				if( IsNameValid( fact ) && ( GetFact( gi, fact ) <= 0 ) )
				{
					return true;
				}
			}
		}
		return false;
	}

	public static function CanItemBeDisassembled( gameInstance : GameInstance, itemData : weak< gameItemData > ) : Bool
	{
		var CS : CraftingSystem;
		var blackboard : IBlackboard;
		var consumableBeingUsed : ItemID;
		blackboard = GameInstance.GetBlackboardSystem( gameInstance ).Get( GetAllBlackboardDefs().UI_QuickSlotsData );
		consumableBeingUsed = ( ( ItemID )( blackboard.GetVariant( GetAllBlackboardDefs().UI_QuickSlotsData.consumableBeingUsed ) ) );
		if( itemData )
		{
			if( ItemID.IsValid( consumableBeingUsed ) && ( TweakDBInterface.GetConsumableItemRecord( ItemID.GetTDBID( itemData.GetID() ) ) == TweakDBInterface.GetConsumableItemRecord( ItemID.GetTDBID( consumableBeingUsed ) ) ) )
			{
				return false;
			}
			CS = CraftingSystem.GetInstance( gameInstance );
			return CS.CanItemBeDisassembled( itemData );
		}
		return false;
	}

	public static function IsItemEquipped( owner : weak< GameObject >, itemID : ItemID ) : Bool
	{
		var ES : EquipmentSystem;
		var result : Bool;
		ES = EquipmentSystem.GetInstance( owner );
		result = ES.IsEquipped( owner, itemID );
		return result;
	}

	public static function IsItemCrafted( itemData : weak< gameItemData > ) : Bool
	{
		var value : Float;
		value = itemData.GetStatValueByType( gamedataStatType.IsItemCrafted );
		return value > 0.0;
	}

	public static function IsItemCrafted( gi : GameInstance, itemId : ItemID ) : Bool
	{
		var value : Float;
		var statsID : StatsObjectID;
		statsID = ( ( StatsObjectID )( itemId ) );
		value = GameInstance.GetStatsSystem( gi ).GetStatValue( statsID, gamedataStatType.IsItemCrafted );
		return value > 0.0;
	}

	public static function ConsumeItem( obj : weak< GameObject >, evt : InteractionChoiceEvent ) : Bool
	{
		var itemQuantity : Int32;
		var lootActionWrapper : LootChoiceActionWrapper;
		var request : EquipmentSystemWeaponManipulationRequest;
		var eqs : EquipmentSystem;
		var blackboard : IBlackboard;
		var gameInstance : GameInstance;
		var transactionSystem : TransactionSystem;
		var itemType : gamedataItemType;
		lootActionWrapper = LootChoiceActionWrapper.Unwrap( evt );
		gameInstance = obj.GetGame();
		transactionSystem = GameInstance.GetTransactionSystem( gameInstance );
		if( lootActionWrapper.action == 'Consume' )
		{
			itemQuantity = GameInstance.GetTransactionSystem( gameInstance ).GetItemQuantity( obj, lootActionWrapper.itemId );
			transactionSystem.TransferItem( obj, evt.activator, lootActionWrapper.itemId, itemQuantity );
			itemType = GetItemType( lootActionWrapper.itemId );
			if( itemType == gamedataItemType.Con_Inhaler || itemType == gamedataItemType.Con_Injector )
			{
				blackboard = GameInstance.GetBlackboardSystem( gameInstance ).Get( GetAllBlackboardDefs().UI_QuickSlotsData );
				blackboard.SetVariant( GetAllBlackboardDefs().UI_QuickSlotsData.containerConsumable, lootActionWrapper.itemId );
				eqs = ( ( EquipmentSystem )( GameInstance.GetScriptableSystemsContainer( gameInstance ).Get( 'EquipmentSystem' ) ) );
				request = new EquipmentSystemWeaponManipulationRequest;
				request.owner = evt.activator;
				request.requestType = EquipmentManipulationAction.RequestConsumable;
				eqs.QueueRequest( request );
			}
			else
			{
				ItemActionsHelper.ConsumeItem( evt.activator, lootActionWrapper.itemId, true );
				return true;
			}
		}
		else if( lootActionWrapper.action == 'Eat' )
		{
			itemQuantity = GameInstance.GetTransactionSystem( gameInstance ).GetItemQuantity( obj, lootActionWrapper.itemId );
			transactionSystem.TransferItem( obj, evt.activator, lootActionWrapper.itemId, itemQuantity );
			ItemActionsHelper.EatItem( evt.activator, lootActionWrapper.itemId, true );
			return true;
		}
		else if( lootActionWrapper.action == 'Drink' )
		{
			itemQuantity = GameInstance.GetTransactionSystem( gameInstance ).GetItemQuantity( obj, lootActionWrapper.itemId );
			transactionSystem.TransferItem( obj, evt.activator, lootActionWrapper.itemId, itemQuantity );
			ItemActionsHelper.DrinkItem( evt.activator, lootActionWrapper.itemId, true );
			return true;
		}
		return false;
	}

	public static function IsWeaponMelee( type : gamedataItemType ) : Bool
	{
		return ( ( ( ( ( ( ( ( ( type == gamedataItemType.Wea_Fists || type == gamedataItemType.Wea_Knife ) || type == gamedataItemType.Wea_Katana ) || type == gamedataItemType.Wea_OneHandedClub ) || type == gamedataItemType.Wea_LongBlade ) || type == gamedataItemType.Wea_ShortBlade ) || type == gamedataItemType.Wea_Melee ) || type == gamedataItemType.Wea_Axe ) || type == gamedataItemType.Wea_Chainsword ) || type == gamedataItemType.Wea_Machete ) || type == gamedataItemType.Wea_Hammer;
	}

	public static function BreakItem( gi : GameInstance, owner : GameObject, itemID : ItemID ) : Bool
	{
		var chance : Float;
		var rand : Float;
		var itemData : weak< gameItemData >;
		itemData = GameInstance.GetTransactionSystem( gi ).GetItemData( owner, itemID );
		if( !( itemData ) )
		{
			return false;
		}
		if( RPGManager.GetItemDataQuality( itemData ) == gamedataQuality.Common )
		{
			chance = TDB.GetFloat( T"GlobalStats.ChanceForItemToBeBroken.value", 1.0 );
			rand = RandF();
			if( rand < chance )
			{
				return true;
			}
		}
		return false;
	}

	public static function DropManyItems( gameInstance : GameInstance, obj : weak< GameObject >, items : array< ItemModParams > )
	{
		var i : Int32;
		var dropList : array< DropInstruction >;
		var LM : LootManager;
		for( i = 0; i < items.Size(); i += 1 )
		{
			dropList.PushBack( DropInstruction.Create( items[ i ].itemID, items[ i ].quantity ) );
		}
		LM = GameInstance.GetLootManager( gameInstance );
		LM.SpawnItemDropOfManyItems( obj, dropList, 'playerDropBag', obj.GetWorldPosition() );
	}

	public static function GetRandomizedHealingConsumable( puppet : weak< ScriptedPuppet > ) : TweakDBID
	{
		var rand : Int32;
		var list : array< TweakDBID >;
		list.PushBack( T"Items.FirstAidWhiffV0" );
		list.PushBack( T"Items.BonesMcCoy70V0" );
		rand = RandRange( 0, list.Size() + 1 );
		return list[ rand ];
	}

	public static function GetRandomizedGadget( puppet : weak< ScriptedPuppet > ) : TweakDBID
	{
		var rand : Int32;
		var list : array< TweakDBID >;
		rand = RandRange( 0, list.Size() + 1 );
		return list[ rand ];
	}

	public static function ForceUnequipItemFromPlayer( puppet : GameObject, slotTDBID : TweakDBID, removeItem : Bool )
	{
		var itemID : ItemID;
		var transactionSys : TransactionSystem;
		if( ( puppet == NULL ) && !( ( ( PlayerPuppet )( puppet ) ) ) )
		{
			return;
		}
		if( !( TDBID.IsValid( slotTDBID ) ) )
		{
			return;
		}
		transactionSys = GameInstance.GetTransactionSystem( puppet.GetGame() );
		itemID = transactionSys.GetItemInSlot( puppet, slotTDBID ).GetItemID();
		transactionSys.RemoveItemFromSlot( puppet, slotTDBID, true );
		if( removeItem )
		{
			transactionSys.RemoveItem( puppet, itemID, 1 );
		}
	}

	public static function ToggleHolsteredArmAppearance( puppet : GameObject, setHoleInArm : Bool )
	{
		var itemObj : ItemObject;
		var player : PlayerPuppet;
		var switchEvent : gameuiPersonalLinkSwitcherEvent;
		player = ( ( PlayerPuppet )( puppet ) );
		if( !( player ) )
		{
			return;
		}
		switchEvent = new gameuiPersonalLinkSwitcherEvent;
		switchEvent.isAdvanced = setHoleInArm;
		itemObj = GameInstance.GetTransactionSystem( player.GetGame() ).GetItemInSlot( player, RPGManager.GetAttachmentSlotID( "RightArm" ) );
		if( itemObj )
		{
			itemObj.QueueEvent( switchEvent );
		}
	}

	public static function TogglePersonalLinkAppearance( puppet : GameObject )
	{
		var itemObj : ItemObject;
		var player : PlayerPuppet;
		var meshEvent : entAppearanceEvent;
		player = ( ( PlayerPuppet )( puppet ) );
		if( !( player ) )
		{
			return;
		}
		itemObj = GameInstance.GetTransactionSystem( player.GetGame() ).GetItemInSlot( player, RPGManager.GetAttachmentSlotID( "PersonalLink" ) );
		if( ItemID.GetTDBID( EquipmentSystem.GetData( player ).GetActiveItem( gamedataEquipmentArea.RightArm ) ) == T"Items.HolsteredStrongArms" )
		{
			meshEvent = new entAppearanceEvent;
			meshEvent.appearanceName = 'only_plug';
			itemObj.QueueEvent( meshEvent );
			return;
		}
	}

	public static function HasStatFlag( owner : weak< GameObject >, flag : gamedataStatType ) : Bool
	{
		if( !( owner ) || !( owner.IsAttached() ) )
		{
			return false;
		}
		return GameInstance.GetStatsSystem( owner.GetGame() ).GetStatBoolValue( owner.GetEntityID(), flag );
	}

	public static function GetPlayerQuickHackList( player : weak< PlayerPuppet > ) : array< TweakDBID >
	{
		var i : Int32;
		var actionIDs : array< TweakDBID >;
		var playerActions : array< PlayerQuickhackData >;
		playerActions = GetPlayerQuickHackListWithQuality( player );
		for( i = 0; i < playerActions.Size(); i += 1 )
		{
			actionIDs.PushBack( playerActions[ i ].actionRecord.GetID() );
		}
		return actionIDs;
	}

	public static function GetPlayerQuickHackListWithQuality( player : weak< PlayerPuppet > ) : array< PlayerQuickhackData >
	{
		var systemReplacementID : ItemID;
		var parts : array< SPartSlots >;
		var i, i1 : Int32;
		var itemRecord : weak< Item_Record >;
		var actions : array< weak< ObjectAction_Record > >;
		var quickhackDataArray : array< PlayerQuickhackData >;
		var quickhackData : PlayerQuickhackData;
		var quickhackDataEmpty : PlayerQuickhackData;
		quickhackDataArray = player.GetCachedQuickHackList();
		if( quickhackDataArray.Size() > 0 )
		{
			return quickhackDataArray;
		}
		systemReplacementID = EquipmentSystem.GetData( player ).GetActiveItem( gamedataEquipmentArea.SystemReplacementCW );
		itemRecord = RPGManager.GetItemRecord( systemReplacementID );
		if( EquipmentSystem.IsCyberdeckEquipped( player ) )
		{
			itemRecord.ObjectActions( actions );
			for( i = 0; i < actions.Size(); i += 1 )
			{
				quickhackData = quickhackDataEmpty;
				quickhackData.actionRecord = actions[ i ];
				quickhackData.quality = itemRecord.Quality().Value();
				quickhackDataArray.PushBack( quickhackData );
			}
			parts = ItemModificationSystem.GetAllSlots( player, systemReplacementID );
			for( i = 0; i < parts.Size(); i += 1 )
			{
				actions.Clear();
				itemRecord = RPGManager.GetItemRecord( parts[ i ].installedPart );
				if( itemRecord )
				{
					itemRecord.ObjectActions( actions );
					for( i1 = 0; i1 < actions.Size(); i1 += 1 )
					{
						if( actions[ i1 ].ObjectActionType().Type() == gamedataObjectActionType.DeviceQuickHack || actions[ i1 ].ObjectActionType().Type() == gamedataObjectActionType.PuppetQuickHack )
						{
							quickhackData = quickhackDataEmpty;
							quickhackData.actionRecord = actions[ i1 ];
							quickhackData.quality = itemRecord.Quality().Value();
							quickhackDataArray.PushBack( quickhackData );
						}
					}
				}
			}
		}
		actions.Clear();
		itemRecord = RPGManager.GetItemRecord( EquipmentSystem.GetData( player ).GetActiveItem( gamedataEquipmentArea.Splinter ) );
		if( itemRecord )
		{
			itemRecord.ObjectActions( actions );
			for( i = 0; i < actions.Size(); i += 1 )
			{
				if( actions[ i ].ObjectActionType().Type() == gamedataObjectActionType.DeviceQuickHack || actions[ i ].ObjectActionType().Type() == gamedataObjectActionType.PuppetQuickHack )
				{
					quickhackData = quickhackDataEmpty;
					quickhackData.actionRecord = actions[ i ];
					quickhackDataArray.PushBack( quickhackData );
				}
			}
		}
		RemoveDuplicatedHacks( quickhackDataArray );
		PlayerPuppet.ChacheQuickHackList( player, quickhackDataArray );
		return quickhackDataArray;
	}

	private static function RemoveDuplicatedHacks( commands : ref< array< PlayerQuickhackData > > )
	{
		var i, i1 : Int32;
		var indexesToRemove : array< Int32 >;
		for( i = commands.Size() - 1; i >= 0; i -= 1 )
		{
			for( i1 = 0; i1 < i; i1 += 1 )
			{
				if( commands[ i ].actionRecord.ActionName() == commands[ i1 ].actionRecord.ActionName() && commands[ i ].actionRecord.ObjectActionType().Type() == commands[ i1 ].actionRecord.ObjectActionType().Type() )
				{
					if( commands[ i ].actionRecord.Priority() >= commands[ i1 ].actionRecord.Priority() )
					{
						indexesToRemove.PushBack( i1 );
					}
					else
					{
						indexesToRemove.PushBack( i );
					}
				}
			}
		}
		for( i = 0; i < indexesToRemove.Size(); i += 1 )
		{
			commands.Erase( indexesToRemove[ i ] );
		}
	}

	private static function RemoveDuplicatedHacks( deck : ref< array< weak< ObjectAction_Record > > >, splinter : ref< array< weak< ObjectAction_Record > > > )
	{
		var i, i1 : Int32;
		for( i = deck.Size() - 1; i >= 0; i -= 1 )
		{
			for( i1 = splinter.Size() - 1; i1 >= 0; i1 -= 1 )
			{
				if( deck[ i ].ActionName() == splinter[ i1 ].ActionName() )
				{
					if( deck[ i ].Priority() >= splinter[ i1 ].Priority() )
					{
						splinter.Erase( i1 );
					}
					else
					{
						deck.Erase( i );
					}
				}
			}
		}
	}

	public static function GetPlayerCurrentHealthPercent( gi : GameInstance ) : Float
	{
		var player : weak< PlayerPuppet >;
		player = ( ( PlayerPuppet )( GameInstance.GetPlayerSystem( gi ).GetLocalPlayerControlledGameObject() ) );
		if( player )
		{
			return GameInstance.GetStatPoolsSystem( gi ).GetStatPoolValue( player.GetEntityID(), gamedataStatPoolType.Health, true );
		}
		return -1.0;
	}

	public static function GetStockItemRequirement( game : GameInstance, record : weak< VendorItem_Record >, itemStatsID : StatsObjectID ) : SItemStackRequirementData
	{
		var statPrereq : StatPrereq_Record;
		var data : SItemStackRequirementData;
		statPrereq = ( ( StatPrereq_Record )( record.AvailabilityPrereq() ) );
		if( statPrereq )
		{
			data.statType = ( ( gamedataStatType )( ( ( Int32 )( EnumValueFromName( 'gamedataStatType', statPrereq.StatType() ) ) ) ) );
			if( StatsObjectID.IsDefined( itemStatsID ) && ( statPrereq.GetStatModifiersCount() > 0 ) )
			{
				data.requiredValue = GameInstance.GetStatsSystem( game ).GetStatPrereqModifiersValue( itemStatsID, statPrereq.GetID() );
			}
			else
			{
				data.requiredValue = statPrereq.ValueToCheck();
			}
		}
		else
		{
			data.statType = gamedataStatType.Invalid;
			data.requiredValue = -1.0;
		}
		return data;
	}

	public static function HealPuppetAfterQuickhack( gi : GameInstance, executor : GameObject )
	{
		var statSystem : StatsSystem;
		statSystem = GameInstance.GetStatsSystem( gi );
		if( statSystem.GetStatBoolValue( ( ( ScriptedPuppet )( executor ) ).GetEntityID(), gamedataStatType.CanQuickhackHealPuppet ) )
		{
			GameInstance.GetStatusEffectSystem( gi ).ApplyStatusEffect( ( ( ScriptedPuppet )( executor ) ).GetEntityID(), T"BaseStatusEffect.QuickhackConsumableHealing" );
		}
	}

	public static function ForceEquipStrongArms( player : PlayerPuppet ) : Bool
	{
		var TS : TransactionSystem;
		var armsCW : ItemID;
		var record : WeaponItem_Record;
		if( !( player ) )
		{
			return false;
		}
		TS = GameInstance.GetTransactionSystem( player.GetGame() );
		armsCW = EquipmentSystem.GetData( player ).GetActiveItem( gamedataEquipmentArea.ArmsCW );
		if( !( TS ) || !( ItemID.IsValid( armsCW ) ) )
		{
			return false;
		}
		record = TweakDBInterface.GetWeaponItemRecord( ItemID.GetTDBID( armsCW ) );
		if( record && record.ItemType().Type() == gamedataItemType.Cyb_StrongArms )
		{
			if( TS.IsSlotEmpty( player, T"AttachmentSlots.WeaponRight" ) && !( TS.IsSlotEmpty( player, T"AttachmentSlots.RightArm" ) ) )
			{
				TS.RemoveItemFromSlot( player, T"AttachmentSlots.RightArm" );
				TS.AddItemToSlot( player, T"AttachmentSlots.RightArm", armsCW );
				return true;
			}
		}
		return false;
	}

	public static function ForceUnequipStrongArms( player : PlayerPuppet ) : Bool
	{
		var TS : TransactionSystem;
		var armsCW : ItemID;
		var record : WeaponItem_Record;
		if( !( player ) )
		{
			return false;
		}
		TS = GameInstance.GetTransactionSystem( player.GetGame() );
		armsCW = EquipmentSystem.GetData( player ).GetActiveItem( gamedataEquipmentArea.ArmsCW );
		if( !( TS ) || !( ItemID.IsValid( armsCW ) ) )
		{
			return false;
		}
		record = TweakDBInterface.GetWeaponItemRecord( ItemID.GetTDBID( armsCW ) );
		if( record && record.ItemType().Type() == gamedataItemType.Cyb_StrongArms )
		{
			armsCW = ItemID.CreateQuery( record.HolsteredItem().GetID() );
			if( ItemID.IsValid( armsCW ) )
			{
				TS.RemoveItemFromSlot( player, T"AttachmentSlots.RightArm" );
				TS.AddItemToSlot( player, T"AttachmentSlots.RightArm", armsCW );
				return true;
			}
		}
		return false;
	}

	public static function ForceEquipPersonalLink( player : PlayerPuppet ) : Bool
	{
		var TS : TransactionSystem;
		var itemID : ItemID;
		var playerStateMachineBlackboard : IBlackboard;
		var playerPuppet : weak< PlayerPuppet >;
		if( !( player ) )
		{
			return false;
		}
		TS = GameInstance.GetTransactionSystem( player.GetGame() );
		itemID = ItemID.CreateQuery( T"Items.personal_link" );
		if( !( TS ) || !( ItemID.IsValid( itemID ) ) )
		{
			return false;
		}
		if( !( TS.HasItem( player, itemID ) ) )
		{
			TS.GiveItem( player, itemID, 1 );
		}
		TS.RemoveItemFromSlot( player, T"AttachmentSlots.PersonalLink" );
		TS.AddItemToSlot( player, T"AttachmentSlots.PersonalLink", itemID );
		playerPuppet = ( ( PlayerPuppet )( GameInstance.GetPlayerSystem( player.GetGame() ).GetLocalPlayerControlledGameObject() ) );
		playerStateMachineBlackboard = GameInstance.GetBlackboardSystem( player.GetGame() ).GetLocalInstanced( playerPuppet.GetEntityID(), GetAllBlackboardDefs().PlayerStateMachine );
		playerStateMachineBlackboard.SetBool( GetAllBlackboardDefs().PlayerStateMachine.IsInteractingViaPersonalLink, true );
		return true;
	}

	public static function ForceUnequipPersonalLink( player : PlayerPuppet ) : Bool
	{
		var TS : TransactionSystem;
		var playerStateMachineBlackboard : IBlackboard;
		var playerPuppet : weak< PlayerPuppet >;
		if( !( player ) )
		{
			return false;
		}
		TS = GameInstance.GetTransactionSystem( player.GetGame() );
		if( !( TS ) )
		{
			return false;
		}
		TS.RemoveItemFromSlot( player, T"AttachmentSlots.PersonalLink" );
		playerPuppet = ( ( PlayerPuppet )( GameInstance.GetPlayerSystem( player.GetGame() ).GetLocalPlayerControlledGameObject() ) );
		playerStateMachineBlackboard = GameInstance.GetBlackboardSystem( player.GetGame() ).GetLocalInstanced( playerPuppet.GetEntityID(), GetAllBlackboardDefs().PlayerStateMachine );
		playerStateMachineBlackboard.SetBool( GetAllBlackboardDefs().PlayerStateMachine.IsInteractingViaPersonalLink, false );
		return true;
	}

}

abstract class MathHelper
{

	public constexpr static function PositiveInfinity() : Float
	{
		return 100000000.0;
	}

	public constexpr static function NegativeInfinity() : Float
	{
		return -100000000.0;
	}

	public constexpr static function EulerNumber() : Float
	{
		return 2.71828175;
	}

	public static function IsFloatInRange( value : Float, min : Float, max : Float, optional leftClosed : Bool, optional rightClosed : Bool ) : Bool
	{
		if( leftClosed && rightClosed )
		{
			return ( value >= min ) && ( value <= max );
		}
		if( leftClosed && !( rightClosed ) )
		{
			return ( value >= min ) && ( value < max );
		}
		if( !( leftClosed ) && rightClosed )
		{
			return ( value > min ) && ( value <= max );
		}
		return ( value > min ) && ( value < max );
	}

	public static function NormalizeF( value : Float, min : Float, max : Float ) : Float
	{
		var numerator : Float;
		var denominator : Float;
		numerator = value - min;
		denominator = max - min;
		return numerator / denominator;
	}

	public static function RandFromNormalDist( optional mean : Float, optional stdDev : Float ) : Float
	{
		var output : Float;
		var uniform1, uniform2 : Float;
		var randStandardNormal : Float;
		if( stdDev == 0.0 )
		{
			stdDev = 1.0;
		}
		uniform1 = RandF();
		uniform2 = RandF();
		randStandardNormal = SqrtF( -2.0 * LogF( uniform1 ) ) * CosF( ( 2.0 * Pi() ) * uniform2 );
		output = ( randStandardNormal * stdDev ) + mean;
		return output;
	}

}

class StatusEffectTriggerListener extends CustomValueStatPoolsListener
{
	var m_owner : weak< GameObject >;
	var m_statusEffect : TweakDBID;
	var m_statPoolType : gamedataStatPoolType;
	var m_instigator : weak< GameObject >;

	protected event OnStatPoolMinValueReached( value : Float )
	{
		var puppet : ScriptedPuppet;
		var gameInstance : GameInstance;
		puppet = ( ( ScriptedPuppet )( m_owner ) );
		if( puppet )
		{
			gameInstance = puppet.GetGame();
			GameInstance.GetStatusEffectSystem( gameInstance ).ApplyStatusEffect( puppet.GetEntityID(), m_statusEffect, GameObject.GetTDBID( m_instigator ), m_instigator.GetEntityID() );
			GameInstance.GetStatPoolsSystem( gameInstance ).RequestRemovingStatPool( puppet.GetEntityID(), m_statPoolType );
			GameObject.RemoveStatusEffectTriggerListener( puppet, this );
		}
	}

}

class PhoneCallUploadDurationListener extends CustomValueStatPoolsListener
{
	var m_gameInstance : GameInstance;
	var m_requesterPuppet : weak< ScriptedPuppet >;
	var m_requesterID : EntityID;
	var m_duration : Float;
	var m_statPoolType : gamedataStatPoolType;
	default m_statPoolType = gamedataStatPoolType.PhoneCallDuration;

	protected event OnStatPoolAdded()
	{
		SendUploadStartedEvent();
		SetRegenBehavior();
	}

	protected virtual function SetRegenBehavior()
	{
		var activationTime : Float;
		var regenMod : StatPoolModifier;
		activationTime = m_duration;
		regenMod.enabled = true;
		regenMod.valuePerSec = 100.0 / activationTime;
		regenMod.rangeEnd = 100.0;
		GameInstance.GetStatPoolsSystem( m_gameInstance ).RequestSettingModifier( m_requesterID, m_statPoolType, gameStatPoolModificationTypes.Regeneration, regenMod );
	}

	protected event OnStatPoolRemoved()
	{
		SendUploadFinishedEvent();
		UnregisterListener();
	}

	protected event OnStatPoolMaxValueReached( value : Float )
	{
		if( m_statPoolType == gamedataStatPoolType.CallReinforcementProgress )
		{
			m_requesterPuppet.GetPuppetStateBlackboard().SetBool( GetAllBlackboardDefs().PuppetState.HasCalledReinforcements, true );
		}
		SendUploadFinishedEvent();
		UnregisterListener();
	}

	private function UnregisterListener()
	{
		GameInstance.GetStatPoolsSystem( m_gameInstance ).RequestUnregisteringListener( m_requesterID, m_statPoolType, this );
	}

	private function SendUploadStartedEvent()
	{
		var evt : UploadProgramProgressEvent;
		evt = new UploadProgramProgressEvent;
		evt.state = EUploadProgramState.STARTED;
		evt.duration = m_duration;
		evt.progressBarType = EProgressBarType.UPLOAD;
		evt.progressBarContext = EProgressBarContext.PhoneCall;
		evt.iconRecord = TweakDBInterface.GetChoiceCaptionIconPartRecord( T"ChoiceCaptionParts.PhoneCall" );
		evt.statPoolType = m_statPoolType;
		GameInstance.GetPersistencySystem( m_gameInstance ).QueueEntityEvent( m_requesterID, evt );
	}

	protected function SendUploadFinishedEvent()
	{
		var evt : UploadProgramProgressEvent;
		evt = new UploadProgramProgressEvent;
		evt.state = EUploadProgramState.COMPLETED;
		evt.progressBarContext = EProgressBarContext.PhoneCall;
		evt.statPoolType = m_statPoolType;
		GameInstance.GetPersistencySystem( m_gameInstance ).QueueEntityEvent( m_requesterID, evt );
	}

}

class ActionUploadListener extends CustomValueStatPoolsListener
{
	var m_action : ScriptableDeviceAction;
	var m_gameInstance : GameInstance;
}

class QuickHackDurationListener extends ActionUploadListener
{

	protected event OnStatPoolAdded()
	{
		SendUploadStartedEvent( m_action );
		SetRegenBehavior();
	}

	protected virtual function SetRegenBehavior()
	{
		var activationTime : Float;
		var regenMod : StatPoolModifier;
		activationTime = m_action.GetDurationValue();
		regenMod.enabled = true;
		regenMod.valuePerSec = 100.0 / activationTime;
		regenMod.rangeEnd = 100.0;
		GameInstance.GetStatPoolsSystem( m_gameInstance ).RequestSettingModifier( m_action.GetRequesterID(), gamedataStatPoolType.QuickHackDuration, gameStatPoolModificationTypes.Regeneration, regenMod );
	}

	protected event OnStatPoolMaxValueReached( value : Float )
	{
		m_action.CompleteAction( m_gameInstance );
		GameInstance.GetStatPoolsSystem( m_gameInstance ).RequestRemovingStatPool( m_action.GetRequesterID(), gamedataStatPoolType.QuickHackDuration );
		GameInstance.GetStatPoolsSystem( m_gameInstance ).RequestUnregisteringListener( m_action.GetRequesterID(), gamedataStatPoolType.QuickHackDuration, this );
		SendUploadFinishedEvent();
	}

	protected virtual function SendUploadStartedEvent( action : ScriptableDeviceAction )
	{
		var evt : UploadProgramProgressEvent;
		var uploadDuration : Float;
		evt = new UploadProgramProgressEvent;
		uploadDuration = m_action.GetDurationValue();
		evt.state = EUploadProgramState.STARTED;
		evt.duration = uploadDuration;
		evt.progressBarType = EProgressBarType.DURATION;
		evt.action = action;
		evt.iconRecord = action.GetInteractionIcon();
		evt.statPoolType = gamedataStatPoolType.QuickHackDuration;
		GameInstance.GetPersistencySystem( m_gameInstance ).QueueEntityEvent( m_action.GetRequesterID(), evt );
	}

	protected function SendUploadFinishedEvent()
	{
		var evt : UploadProgramProgressEvent;
		evt = new UploadProgramProgressEvent;
		evt.state = EUploadProgramState.COMPLETED;
		evt.statPoolType = gamedataStatPoolType.QuickHackDuration;
		GameInstance.GetPersistencySystem( m_gameInstance ).QueueEntityEvent( m_action.GetRequesterID(), evt );
	}

}

class QuickHackUploadListener extends ActionUploadListener
{

	protected event OnStatPoolAdded()
	{
		if( m_action.IsQuickHack() )
		{
			SendUploadStartedEvent( m_action );
			PlayQuickHackSound( 'ui_focus_mode_scanning_qh' );
		}
		SetRegenBehavior();
	}

	protected virtual function SetRegenBehavior()
	{
		var activationTime : Float;
		var regenMod : StatPoolModifier;
		activationTime = m_action.GetActivationTime();
		regenMod.enabled = true;
		regenMod.valuePerSec = 100.0 / activationTime;
		regenMod.rangeEnd = 100.0;
		GameInstance.GetStatPoolsSystem( m_gameInstance ).RequestSettingModifier( m_action.GetRequesterID(), gamedataStatPoolType.QuickHackUpload, gameStatPoolModificationTypes.Regeneration, regenMod );
	}

	protected event OnStatPoolMaxValueReached( value : Float )
	{
		m_action.CompleteAction( m_gameInstance );
		GameInstance.GetStatPoolsSystem( m_gameInstance ).RequestRemovingStatPool( m_action.GetRequesterID(), gamedataStatPoolType.QuickHackUpload );
		GameInstance.GetStatPoolsSystem( m_gameInstance ).RequestUnregisteringListener( m_action.GetRequesterID(), gamedataStatPoolType.QuickHackUpload, this );
		if( m_action.IsQuickHack() )
		{
			SendUploadFinishedEvent();
		}
	}

	protected virtual function SendUploadStartedEvent( action : ScriptableDeviceAction )
	{
		var evt : UploadProgramProgressEvent;
		var uploadDuration : Float;
		evt = new UploadProgramProgressEvent;
		uploadDuration = m_action.GetActivationTime();
		evt.state = EUploadProgramState.STARTED;
		evt.duration = uploadDuration;
		evt.progressBarType = EProgressBarType.UPLOAD;
		evt.action = action;
		evt.iconRecord = action.GetInteractionIcon();
		evt.statPoolType = gamedataStatPoolType.QuickHackUpload;
		GameInstance.GetPersistencySystem( m_gameInstance ).QueueEntityEvent( m_action.GetRequesterID(), evt );
		if( m_action.GetExecutor().IsPlayer() )
		{
			IncrementQuickHackBlackboard();
		}
		QuickhackModule.RequestRefreshQuickhackMenu( m_gameInstance, m_action.GetRequesterID() );
	}

	protected function SendUploadFinishedEvent()
	{
		var evt : UploadProgramProgressEvent;
		evt = new UploadProgramProgressEvent;
		evt.state = EUploadProgramState.COMPLETED;
		evt.statPoolType = gamedataStatPoolType.QuickHackUpload;
		GameInstance.GetPersistencySystem( m_gameInstance ).QueueEntityEvent( m_action.GetRequesterID(), evt );
		PlayQuickHackSound( 'ui_focus_mode_scanning_qh_done' );
		if( m_action.GetExecutor().IsPlayer() )
		{
			DecrementQuickHackBlackboard();
		}
	}

	protected function PlayQuickHackSound( eventName : CName )
	{
		var flag : audioAudioEventFlags;
		flag = audioAudioEventFlags.Unique;
		GameObject.PlaySoundEventWithParams( m_action.GetExecutor(), eventName, flag );
	}

	private function IncrementQuickHackBlackboard()
	{
		var playerPuppet : PlayerPuppet;
		var playerBlackboard : IBlackboard;
		var currValue : Int32;
		playerPuppet = ( ( PlayerPuppet )( GameInstance.GetPlayerSystem( m_gameInstance ).GetLocalPlayerControlledGameObject() ) );
		if( playerPuppet )
		{
			playerBlackboard = GameInstance.GetBlackboardSystem( m_gameInstance ).GetLocalInstanced( playerPuppet.GetEntityID(), GetAllBlackboardDefs().PlayerStateMachine );
			currValue = playerBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.IsUploadingQuickHack );
			playerBlackboard.SetInt( GetAllBlackboardDefs().PlayerStateMachine.IsUploadingQuickHack, currValue + 1 );
		}
	}

	private function DecrementQuickHackBlackboard()
	{
		var playerPuppet : PlayerPuppet;
		var playerBlackboard : IBlackboard;
		var currValue : Int32;
		playerPuppet = ( ( PlayerPuppet )( GameInstance.GetPlayerSystem( m_gameInstance ).GetLocalPlayerControlledGameObject() ) );
		if( playerPuppet )
		{
			playerBlackboard = GameInstance.GetBlackboardSystem( m_gameInstance ).GetLocalInstanced( playerPuppet.GetEntityID(), GetAllBlackboardDefs().PlayerStateMachine );
			currValue = playerBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.IsUploadingQuickHack );
			playerBlackboard.SetInt( GetAllBlackboardDefs().PlayerStateMachine.IsUploadingQuickHack, currValue - 1 );
		}
	}

	protected function RemoveLink( owner : weak< ScriptedPuppet > )
	{
		var evt : RemoveLinkEvent;
		if( !( owner ) )
		{
			return;
		}
		evt = new RemoveLinkEvent;
		owner.QueueEvent( evt );
	}

	protected function RemoveLinkedStatusEffects( owner : weak< ScriptedPuppet >, optional ssAction : Bool )
	{
		var evt : RemoveLinkedStatusEffectsEvent;
		if( !( owner ) )
		{
			return;
		}
		evt = new RemoveLinkedStatusEffectsEvent;
		evt.ssAction = ssAction;
		owner.QueueEvent( evt );
	}

}

class AccessBreachListener extends QuickHackUploadListener
{
}

class UploadFromNPCToNPCListener extends QuickHackUploadListener
{
	var m_npcPuppet : weak< ScriptedPuppet >;

	public override function OnStatPoolValueChanged( oldValue : Float, newValue : Float, percToPoints : Float )
	{
		var uploadEvent : UploadProgramProgressEvent;
		if( !( NPCPuppet.IsActive( m_npcPuppet ) ) )
		{
			RemoveLinkedStatusEffects( m_npcPuppet );
			GameInstance.GetStatPoolsSystem( m_gameInstance ).RequestRemovingStatPool( m_action.GetRequesterID(), gamedataStatPoolType.QuickHackUpload );
			GameInstance.GetStatPoolsSystem( m_gameInstance ).RequestUnregisteringListener( m_action.GetRequesterID(), gamedataStatPoolType.QuickHackUpload, this );
			uploadEvent = new UploadProgramProgressEvent;
			uploadEvent.state = EUploadProgramState.COMPLETED;
			GameInstance.GetPersistencySystem( m_gameInstance ).QueueEntityEvent( m_action.GetRequesterID(), uploadEvent );
		}
	}

}

class UploadFromNPCToPlayerListener extends QuickHackUploadListener
{
	var m_playerPuppet : weak< ScriptedPuppet >;
	var m_npcPuppet : weak< ScriptedPuppet >;
	var m_npcSquad : array< EntityID >;
	var m_variantHud : HUDProgressBarData;
	var m_hudBlackboard : weak< IBlackboard >;
	private var m_startUploadTimeStamp : Float;
	private var m_ssAction : Bool;

	protected event OnStatPoolAdded()
	{
		if( m_action.GetObjectActionID() == T"AIQuickHack.HackRevealPosition" )
		{
			m_ssAction = true;
			AISquadHelper.GetSquadmatesID( m_npcPuppet, m_npcSquad );
		}
		SendUploadStartedEvent( m_action );
	}

	protected override function SendUploadStartedEvent( action : ScriptableDeviceAction )
	{
		m_variantHud.active = true;
		m_variantHud.header = LocKeyToString( action.GetObjectActionRecord().ObjectActionUI().Caption() );
		m_startUploadTimeStamp = EngineTime.ToFloat( GameInstance.GetSimTime( m_npcPuppet.GetGame() ) );
		m_hudBlackboard = GameInstance.GetBlackboardSystem( m_gameInstance ).Get( GetAllBlackboardDefs().UI_HUDProgressBar );
		m_hudBlackboard.SetBool( GetAllBlackboardDefs().UI_HUDProgressBar.Active, m_variantHud.active );
		m_hudBlackboard.SetString( GetAllBlackboardDefs().UI_HUDProgressBar.Header, m_variantHud.header );
	}

	protected event OnStatPoolMaxValueReached( value : Float )
	{
		var actionEffects : array< weak< ObjectActionEffect_Record > >;
		var targetTracker : weak< TargetTrackingExtension >;
		super.OnStatPoolMaxValueReached( value );
		RemoveLink( m_npcPuppet );
		ScriptedPuppet.SendActionSignal( m_npcPuppet, 'HackingCompleted', 1.0 );
		m_variantHud.active = false;
		m_hudBlackboard.SetBool( GetAllBlackboardDefs().UI_HUDProgressBar.Active, m_variantHud.active );
		m_action.GetObjectActionRecord().CompletionEffects( actionEffects );
		m_npcPuppet.AddLinkedStatusEffect( m_npcPuppet.GetEntityID(), m_playerPuppet.GetEntityID(), actionEffects );
		m_playerPuppet.AddLinkedStatusEffect( m_npcPuppet.GetEntityID(), m_playerPuppet.GetEntityID(), actionEffects );
		if( m_ssAction )
		{
			m_playerPuppet.RemoveLinkedStatusEffects( true );
			if( !( TargetTrackingExtension.Get( ( ( ScriptedPuppet )( GameInstance.FindEntityByID( m_playerPuppet.GetGame(), m_npcSquad[ 0 ] ) ) ), targetTracker ) ) )
			{
				if( !( TargetTrackingExtension.Get( m_npcPuppet, targetTracker ) ) )
				{
					return false;
				}
			}
			if( AIActionHelper.TryChangingAttitudeToHostile( m_npcPuppet, m_playerPuppet ) )
			{
				targetTracker.AddThreat( m_playerPuppet, true, m_playerPuppet.GetWorldPosition(), 1.0, -1.0, false );
				m_npcPuppet.TriggerSecuritySystemNotification( m_playerPuppet.GetWorldPosition(), m_playerPuppet, ESecurityNotificationType.COMBAT );
			}
		}
	}

	public override function OnStatPoolValueChanged( oldValue : Float, newValue : Float, percToPoints : Float )
	{
		var evt : UploadProgramProgressEvent;
		var hitReactionComponent : HitReactionComponent;
		var statValue : Float;
		var immune : Bool;
		var stopHack : Bool;
		statValue = GameInstance.GetStatsSystem( m_playerPuppet.GetGame() ).GetStatValue( m_playerPuppet.GetEntityID(), gamedataStatType.QuickhackShield );
		m_variantHud.progress = newValue / 100.0;
		m_hudBlackboard.SetFloat( GetAllBlackboardDefs().UI_HUDProgressBar.Progress, m_variantHud.progress );
		if( ( ( newValue > 15.0 ) && ( statValue > 0.0 ) ) && !( StatusEffectSystem.ObjectHasStatusEffect( m_playerPuppet, T"BaseStatusEffect.AntiVirusCooldown" ) ) )
		{
			StatusEffectHelper.ApplyStatusEffect( ( ( GameObject )( m_playerPuppet ) ), T"BaseStatusEffect.AntiVirusCooldown" );
			immune = true;
		}
		if( m_ssAction )
		{
			hitReactionComponent = m_npcPuppet.GetHitReactionComponent();
			if( ( ( ( immune || !( ScriptedPuppet.IsActive( m_npcPuppet ) ) ) || !( ScriptedPuppet.IsActive( m_playerPuppet ) ) ) || NPCPuppet.IsInCombat( m_npcPuppet ) ) || ( ( ( hitReactionComponent.GetLastHitTimeStamp() - m_startUploadTimeStamp ) > 0.1 ) && ( 0.5 > ( EngineTime.ToFloat( GameInstance.GetSimTime( m_npcPuppet.GetGame() ) ) - hitReactionComponent.GetLastHitTimeStamp() ) ) ) )
			{
				stopHack = true;
			}
		}
		else if( ( ( ( ( ( immune || !( ScriptedPuppet.IsActive( m_npcPuppet ) ) ) || !( ScriptedPuppet.IsActive( m_playerPuppet ) ) ) || StatusEffectSystem.ObjectHasStatusEffect( m_npcPuppet, T"AIQuickHackStatusEffect.HackingInterrupted" ) ) || StatusEffectSystem.ObjectHasStatusEffect( m_npcPuppet, T"BaseStatusEffect.CyberwareMalfunction" ) ) || StatusEffectSystem.ObjectHasStatusEffect( m_npcPuppet, T"BaseStatusEffect.CyberwareMalfunctionLvl2" ) ) || StatusEffectSystem.ObjectHasStatusEffect( m_npcPuppet, T"BaseStatusEffect.CyberwareMalfunctionLvl3" ) )
		{
			stopHack = true;
		}
		if( stopHack )
		{
			immune = false;
			RemoveLinkedStatusEffects( m_npcPuppet, m_ssAction );
			m_variantHud.active = false;
			m_hudBlackboard.SetBool( GetAllBlackboardDefs().UI_HUDProgressBar.Active, m_variantHud.active );
			GameInstance.GetStatPoolsSystem( m_gameInstance ).RequestRemovingStatPool( m_action.GetRequesterID(), gamedataStatPoolType.QuickHackUpload );
			GameInstance.GetStatPoolsSystem( m_gameInstance ).RequestUnregisteringListener( m_action.GetRequesterID(), gamedataStatPoolType.QuickHackUpload, this );
			evt = new UploadProgramProgressEvent;
			evt.state = EUploadProgramState.COMPLETED;
			GameInstance.GetPersistencySystem( m_gameInstance ).QueueEntityEvent( m_action.GetRequesterID(), evt );
			StatusEffectHelper.RemoveStatusEffect( m_playerPuppet, T"AIQuickHackStatusEffect.BeingHacked" );
		}
	}

}

struct PlayerQuickhackData
{
	var actionRecord : weak< ObjectAction_Record >;
	var quality : Int32;
}

enum EPowerDifferential
{
	IMPOSSIBLE = -6,
	HARD = -3,
	NORMAL = 2,
	EASY = 4,
	TRASH = 5,
}

operator>( q1 : gamedataQuality, q2 : gamedataQuality ) : Bool
{
	var result : Bool;
	if( ( ( q1 == gamedataQuality.Invalid || q1 == gamedataQuality.Count ) || q2 == gamedataQuality.Invalid ) || q2 == gamedataQuality.Count )
	{
		return false;
	}
	switch( q1 )
	{
		case gamedataQuality.Common:
			return false;
		case gamedataQuality.Uncommon:
			result = ( ( q2 == gamedataQuality.Common ) ? ( true ) : ( false ) );
		break;
		case gamedataQuality.Rare:
			result = ( ( q2 == gamedataQuality.Common || q2 == gamedataQuality.Uncommon ) ? ( true ) : ( false ) );
		break;
		case gamedataQuality.Epic:
			result = ( ( ( q2 == gamedataQuality.Common || q2 == gamedataQuality.Uncommon ) || q2 == gamedataQuality.Rare ) ? ( true ) : ( false ) );
		break;
		case gamedataQuality.Legendary:
			result = ( ( ( ( q2 == gamedataQuality.Common || q2 == gamedataQuality.Uncommon ) || q2 == gamedataQuality.Rare ) || q2 == gamedataQuality.Epic ) ? ( true ) : ( false ) );
		break;
		default:
			return false;
	}
	return result;
}

operator>=( q1 : gamedataQuality, q2 : gamedataQuality ) : Bool
{
	var result : Bool;
	if( ( ( q1 == gamedataQuality.Invalid || q1 == gamedataQuality.Count ) || q2 == gamedataQuality.Invalid ) || q2 == gamedataQuality.Count )
	{
		return false;
	}
	switch( q1 )
	{
		case gamedataQuality.Common:
			result = ( ( q2 == gamedataQuality.Common ) ? ( true ) : ( false ) );
		break;
		case gamedataQuality.Uncommon:
			result = ( ( q2 == gamedataQuality.Common || q2 == gamedataQuality.Uncommon ) ? ( true ) : ( false ) );
		break;
		case gamedataQuality.Rare:
			result = ( ( ( q2 == gamedataQuality.Common || q2 == gamedataQuality.Uncommon ) || q2 == gamedataQuality.Rare ) ? ( true ) : ( false ) );
		break;
		case gamedataQuality.Epic:
			result = ( ( ( ( q2 == gamedataQuality.Common || q2 == gamedataQuality.Uncommon ) || q2 == gamedataQuality.Rare ) || q2 == gamedataQuality.Epic ) ? ( true ) : ( false ) );
		break;
		case gamedataQuality.Legendary:
			result = ( ( ( ( ( q2 == gamedataQuality.Common || q2 == gamedataQuality.Uncommon ) || q2 == gamedataQuality.Rare ) || q2 == gamedataQuality.Epic ) || q2 == gamedataQuality.Legendary ) ? ( true ) : ( false ) );
		break;
		default:
			return false;
	}
	return result;
}

operator<( q1 : gamedataQuality, q2 : gamedataQuality ) : Bool
{
	var result : Bool;
	if( ( ( q1 == gamedataQuality.Invalid || q1 == gamedataQuality.Count ) || q2 == gamedataQuality.Invalid ) || q2 == gamedataQuality.Count )
	{
		return false;
	}
	switch( q2 )
	{
		case gamedataQuality.Common:
			return false;
		case gamedataQuality.Uncommon:
			result = ( ( q1 == gamedataQuality.Common ) ? ( true ) : ( false ) );
		break;
		case gamedataQuality.Rare:
			result = ( ( q1 == gamedataQuality.Common || q1 == gamedataQuality.Uncommon ) ? ( true ) : ( false ) );
		break;
		case gamedataQuality.Epic:
			result = ( ( ( q1 == gamedataQuality.Common || q1 == gamedataQuality.Uncommon ) || q1 == gamedataQuality.Rare ) ? ( true ) : ( false ) );
		break;
		case gamedataQuality.Legendary:
			result = ( ( ( ( q1 == gamedataQuality.Common || q1 == gamedataQuality.Uncommon ) || q1 == gamedataQuality.Rare ) || q1 == gamedataQuality.Epic ) ? ( true ) : ( false ) );
		break;
		default:
			return false;
	}
	return result;
}

operator<=( q1 : gamedataQuality, q2 : gamedataQuality ) : Bool
{
	var result : Bool;
	if( ( ( q1 == gamedataQuality.Invalid || q1 == gamedataQuality.Count ) || q2 == gamedataQuality.Invalid ) || q2 == gamedataQuality.Count )
	{
		return false;
	}
	switch( q2 )
	{
		case gamedataQuality.Common:
			result = ( ( q1 == gamedataQuality.Common ) ? ( true ) : ( false ) );
		break;
		case gamedataQuality.Uncommon:
			result = ( ( q1 == gamedataQuality.Common || q1 == gamedataQuality.Uncommon ) ? ( true ) : ( false ) );
		break;
		case gamedataQuality.Rare:
			result = ( ( ( q1 == gamedataQuality.Common || q1 == gamedataQuality.Uncommon ) || q1 == gamedataQuality.Rare ) ? ( true ) : ( false ) );
		break;
		case gamedataQuality.Epic:
			result = ( ( ( ( q1 == gamedataQuality.Common || q1 == gamedataQuality.Uncommon ) || q1 == gamedataQuality.Rare ) || q1 == gamedataQuality.Epic ) ? ( true ) : ( false ) );
		break;
		case gamedataQuality.Legendary:
			result = ( ( ( ( ( q1 == gamedataQuality.Common || q1 == gamedataQuality.Uncommon ) || q1 == gamedataQuality.Rare ) || q1 == gamedataQuality.Epic ) || q1 == gamedataQuality.Legendary ) ? ( true ) : ( false ) );
		break;
		default:
			return false;
	}
	return result;
}

exec function ApplyGLP( gameInstance : GameInstance, value : String )
{
	var glpID : TweakDBID;
	var glpRecord : weak< GameplayLogicPackage_Record >;
	glpID = TDBID.Create( value );
	glpRecord = TweakDBInterface.GetGameplayLogicPackageRecord( glpID );
	if( glpRecord )
	{
		RPGManager.ApplyGLP( GameInstance.GetPlayerSystem( gameInstance ).GetLocalPlayerControlledGameObject(), glpRecord );
	}
}

