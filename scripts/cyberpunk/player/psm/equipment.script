struct InstanceDataMappedToReferenceName
{
	var itemHandlingFeatureName : CName;
	var attachmentSlot : String;
}

class ItemIdWrapper extends IScriptable
{
	var itemID : ItemID;
}

enum EEquipmentState
{
	Unequipped = 0,
	Equipped = 1,
	Equipping = 2,
	Unequipping = 3,
	FirstEquip = 4,
}

enum EEquipmentSide
{
	Left = 0,
	Right = 1,
}

abstract class EquipmentBaseTransition extends DefaultTransition
{

	protected const final function GetMappedInstanceData( referenceName : CName ) : InstanceDataMappedToReferenceName
	{
		var mappedInstanceData : InstanceDataMappedToReferenceName;
		if( referenceName == 'RightHand' )
		{
			mappedInstanceData.itemHandlingFeatureName = 'rightHandItemHandling';
			mappedInstanceData.attachmentSlot = "AttachmentSlots.WeaponRight";
		}
		if( referenceName == 'LeftHand' )
		{
			mappedInstanceData.itemHandlingFeatureName = 'leftHandItemHandling';
			mappedInstanceData.attachmentSlot = "AttachmentSlots.WeaponLeft";
		}
		return mappedInstanceData;
	}

	protected const function GetWeaponManipulationRequest( const stateContext : StateContext, stateMachineInitData : weak< EquipmentInitData > ) : EquipmentManipulationRequest
	{
		var request : EquipmentManipulationRequest;
		request = ( ( EquipmentManipulationRequest )( stateContext.GetPermanentScriptableParameter( stateMachineInitData.eqManipulationVarName ) ) );
		return request;
	}

	protected const function SaveProcessedEquipmentManipulationRequest( stateContext : StateContext, stateMachineInstanceData : StateMachineInstanceData, stateMachineInitData : weak< EquipmentInitData > )
	{
		stateContext.SetPermanentScriptableParameter( ReferenceNameToProcessRequestId( stateMachineInstanceData ), GetWeaponManipulationRequest( stateContext, stateMachineInitData ), true );
	}

	protected const function GetProcessedEquipmentManipulationRequest( stateMachineInstanceData : StateMachineInstanceData, const stateContext : StateContext ) : EquipmentManipulationRequest
	{
		var request : EquipmentManipulationRequest;
		request = ( ( EquipmentManipulationRequest )( stateContext.GetPermanentScriptableParameter( ReferenceNameToProcessRequestId( stateMachineInstanceData ) ) ) );
		return request;
	}

	protected const function ClearProcessedEquipmentManipulationRequest( stateMachineInstanceData : StateMachineInstanceData, stateContext : StateContext )
	{
		stateContext.RemovePermanentScriptableParameter( ReferenceNameToProcessRequestId( stateMachineInstanceData ) );
	}

	protected const function CheckSlotMatchAndCompareRequestType( const stateContext : StateContext, stateMachineInstanceData : StateMachineInstanceData, stateMachineInitData : weak< EquipmentInitData >, requestTypeCompare : EquipmentManipulationRequestType ) : Bool
	{
		var equipRequestMatch : Bool;
		var request : EquipmentManipulationRequest;
		var slotMatch : Bool;
		request = GetWeaponManipulationRequest( stateContext, stateMachineInitData );
		if( request == NULL )
		{
			return false;
		}
		equipRequestMatch = request.requestType == requestTypeCompare;
		slotMatch = request.requestSlot == EquipmentManipulationRequestSlot.Both || request.requestSlot == ReferenceNameToRequestSlot( stateMachineInstanceData );
		return equipRequestMatch && slotMatch;
	}

	protected const function CheckReplicatedEquipRequest( const scriptInterface : StateGameScriptInterface, const stateContext : StateContext, stateMachineInstanceData : StateMachineInstanceData ) : Bool
	{
		var multiplyerRequestData : parameterRequestItem;
		var isDifferentItem : Bool;
		var slotMatch : Bool;
		isDifferentItem = false;
		slotMatch = false;
		if( ReferenceNameToRequestSlot( stateMachineInstanceData ) == EquipmentManipulationRequestSlot.Right )
		{
			slotMatch = true;
		}
		multiplyerRequestData = ( ( parameterRequestItem )( stateContext.GetTemporaryScriptableParameter( 'cpo_replicatedEquipRequest' ) ) );
		if( multiplyerRequestData == NULL )
		{
			multiplyerRequestData = ( ( parameterRequestItem )( stateContext.GetConditionScriptableParameter( 'cpo_replicatedEquipRequest' ) ) );
		}
		if( multiplyerRequestData )
		{
			isDifferentItem = GetSlotAttachedItemID( scriptInterface, stateMachineInstanceData ) != multiplyerRequestData.requests[ 0 ].itemIDToEquip;
		}
		if( isDifferentItem && slotMatch )
		{
			stateContext.SetConditionScriptableParameter( 'cpo_replicatedEquipRequest', multiplyerRequestData, true );
			return true;
		}
		return false;
	}

	protected const function ReferenceNameToProcessRequestId( stateMachineInstanceData : StateMachineInstanceData ) : CName
	{
		if( stateMachineInstanceData.referenceName == 'RightHand' )
		{
			return 'ProcessedEqRequest_Right';
		}
		else if( stateMachineInstanceData.referenceName == 'LeftHand' )
		{
			return 'ProcessedEqRequest_Left';
		}
		else
		{
			return 'ProcessedEqRequest_Undefined';
		}
	}

	protected const function ReferenceNameToRequestSlot( stateMachineInstanceData : StateMachineInstanceData ) : EquipmentManipulationRequestSlot
	{
		if( stateMachineInstanceData.referenceName == 'RightHand' )
		{
			return EquipmentManipulationRequestSlot.Right;
		}
		else if( stateMachineInstanceData.referenceName == 'LeftHand' )
		{
			return EquipmentManipulationRequestSlot.Left;
		}
		else
		{
			return EquipmentManipulationRequestSlot.Undefined;
		}
	}

	protected const function GetItemCategoryFromItemID( item : ItemID ) : gamedataItemCategory
	{
		var record : Item_Record;
		record = TweakDBInterface.GetItemRecord( ItemID.GetTDBID( item ) );
		return record.ItemCategory().Type();
	}

	protected const function GetEquipAreaFromItemID( item : ItemID ) : gamedataEquipmentArea
	{
		var record : Item_Record;
		record = TweakDBInterface.GetItemRecord( ItemID.GetTDBID( item ) );
		return record.EquipArea().Type();
	}

	protected const function IsVisualItemInSlot( const scriptInterface : StateGameScriptInterface, stateMachineInstanceData : StateMachineInstanceData ) : Bool
	{
		var mappedInstanceData : InstanceDataMappedToReferenceName;
		var itemObject : weak< ItemObject >;
		mappedInstanceData = GetMappedInstanceData( stateMachineInstanceData.referenceName );
		itemObject = scriptInterface.GetTransactionSystem().GetItemInSlot( scriptInterface.executionOwner, TDBID.Create( mappedInstanceData.attachmentSlot ) );
		return ( itemObject != NULL ) && itemObject.IsVisualSpawnAttached();
	}

	protected const function IsUsingFluffConsumable( const scriptInterface : StateGameScriptInterface, stateMachineInstanceData : StateMachineInstanceData ) : Bool
	{
		var item : ItemID;
		item = GetSlotActiveItem( scriptInterface, stateMachineInstanceData );
		if( TweakDBInterface.GetItemRecord( ItemID.GetTDBID( item ) ).ItemType().Type() == gamedataItemType.Con_Edible )
		{
			return true;
		}
		return false;
	}

	protected const function GetIsPSMInValidState( const scriptInterface : StateGameScriptInterface, const stateContext : StateContext, stateMachineInstanceData : StateMachineInstanceData ) : Bool
	{
		var item : ItemObject;
		var weapon : WeaponObject;
		var weaponPSMState : gamePSMRangedWeaponStates;
		item = GetSlotAttachedItem( scriptInterface, stateMachineInstanceData );
		if( !( item ) || GetItemCategoryFromItemID( item.GetItemID() ) != gamedataItemCategory.Weapon )
		{
			return true;
		}
		weapon = ( ( WeaponObject )( item ) );
		if( !( weapon.IsRanged() ) )
		{
			return true;
		}
		weaponPSMState = ( ( gamePSMRangedWeaponStates )( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.Weapon ) ) );
		return ( ( weaponPSMState == gamePSMRangedWeaponStates.Default || weaponPSMState == gamePSMRangedWeaponStates.NoAmmo ) || weaponPSMState == gamePSMRangedWeaponStates.Ready ) || weaponPSMState == gamePSMRangedWeaponStates.Safe;
	}

	protected const function GetWeaponEquipDuration( const scriptInterface : StateGameScriptInterface, const stateContext : StateContext, stateMachineInstanceData : StateMachineInstanceData ) : Float
	{
		var weapon : weak< WeaponObject >;
		var statSystem : StatsSystem;
		statSystem = scriptInterface.GetStatsSystem();
		if( GetProcessedEquipmentManipulationRequest( stateMachineInstanceData, stateContext ).equipAnim == gameEquipAnimationType.HACK_ForceInstantEquip )
		{
			return 0.0;
		}
		weapon = ( ( WeaponObject )( GetSlotAttachedItemObject( scriptInterface, stateMachineInstanceData ) ) );
		return statSystem.GetStatValue( weapon.GetEntityID(), gamedataStatType.EquipDuration );
	}

	protected const function GetWeaponUnEquipDuration( const scriptInterface : StateGameScriptInterface, stateContext : StateContext, stateMachineInstanceData : StateMachineInstanceData ) : Float
	{
		var weapon : weak< WeaponObject >;
		var statSystem : StatsSystem;
		var duration : Float;
		var instantEquipRequested : Bool;
		statSystem = scriptInterface.GetStatsSystem();
		weapon = ( ( WeaponObject )( GetSlotAttachedItemObject( scriptInterface, stateMachineInstanceData ) ) );
		instantEquipRequested = GetProcessedEquipmentManipulationRequest( stateMachineInstanceData, stateContext ).equipAnim == gameEquipAnimationType.Instant;
		if( instantEquipRequested || HasThrowableCooldown( scriptInterface, weapon ) )
		{
			duration = 0.0;
		}
		else
		{
			duration = statSystem.GetStatValue( weapon.GetEntityID(), gamedataStatType.UnequipDuration );
		}
		stateContext.SetPermanentFloatParameter( 'rhUnequipDuration', duration, true );
		return duration;
	}

	protected const function GetConsumableUnEquipDuration( stateMachineInstanceData : StateMachineInstanceData, const stateContext : StateContext ) : Float
	{
		if( GetProcessedEquipmentManipulationRequest( stateMachineInstanceData, stateContext ).equipAnim == gameEquipAnimationType.Instant )
		{
			return 0.0;
		}
		else
		{
			return 0.2;
		}
	}

	protected const function HandleWeaponEquip( scriptInterface : StateGameScriptInterface, stateContext : StateContext, stateMachineInstanceData : StateMachineInstanceData, item : ItemID )
	{
		var animFeature : AnimFeature_EquipUnequipItem;
		var weaponEquipAnimFeature : AnimFeature_EquipType;
		var weaponEquipEvent : WeaponEquipEvent;
		var transactionSystem : TransactionSystem;
		var statSystem : StatsSystem;
		var mappedInstanceData : InstanceDataMappedToReferenceName;
		var itemObject : weak< WeaponObject >;
		var firstEqSystem : FirstEquipSystem;
		var isInCombat : Bool;
		var statsEvent : UpdateWeaponStatsEvent;
		var animFeatureMeleeData : AnimFeature_MeleeData;
		var preventFirstEquip : Bool;
		var autoRefillEvent : SetAmmoCountEvent;
		var autoRefillRatio : Float;
		var magazineCapacity : Uint32;
		var firstEquip : Bool;
		animFeature = new AnimFeature_EquipUnequipItem;
		weaponEquipAnimFeature = new AnimFeature_EquipType;
		transactionSystem = scriptInterface.GetTransactionSystem();
		statSystem = scriptInterface.GetStatsSystem();
		mappedInstanceData = GetMappedInstanceData( stateMachineInstanceData.referenceName );
		firstEqSystem = FirstEquipSystem.GetInstance( scriptInterface.owner );
		firstEquip = false;
		itemObject = ( ( WeaponObject )( transactionSystem.GetItemInSlot( scriptInterface.executionOwner, TDBID.Create( mappedInstanceData.attachmentSlot ) ) ) );
		isInCombat = scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.Combat ) == ( ( Int32 )( gamePSMCombat.InCombat ) );
		if( TDB.GetBool( T"player.weapon.enableWeaponBlur", false ) )
		{
			GetBlurParametersFromWeapon( scriptInterface );
		}
		preventFirstEquip = scriptInterface.localBlackboard.GetBool( GetAllBlackboardDefs().PlayerStateMachine.ScenePreventFirstEquip ) || scriptInterface.localBlackboard.GetBool( GetAllBlackboardDefs().PlayerStateMachine.MountedPreventFirstEquip );
		if( !( isInCombat ) && !( preventFirstEquip ) )
		{
			if( weaponEquipAnimFeature.firstEquip = ( GetProcessedEquipmentManipulationRequest( stateMachineInstanceData, stateContext ).equipAnim == gameEquipAnimationType.FirstEquip || GetStaticBoolParameterDefault( "forceFirstEquip", false ) ) || !( firstEqSystem.HasPlayedFirstEquip( ItemID.GetTDBID( itemObject.GetItemID() ) ) ) )
			{
				weaponEquipAnimFeature.firstEquip = true;
				stateContext.SetConditionBoolParameter( 'firstEquip', true, true );
				firstEquip = true;
			}
		}
		scriptInterface.localBlackboard.SetBool( GetAllBlackboardDefs().PlayerStateMachine.IsWeaponFirstEquip, firstEquip );
		animFeature.stateTransitionDuration = statSystem.GetStatValue( itemObject.GetEntityID(), gamedataStatType.EquipDuration );
		animFeature.itemState = 1;
		animFeature.itemType = ( ( Int32 )( TDB.GetItemRecord( ItemID.GetTDBID( item ) ).ItemType().AnimFeatureIndex() ) );
		BlockAimingForTime( stateContext, scriptInterface, animFeature.stateTransitionDuration + 0.1 );
		weaponEquipAnimFeature.equipDuration = GetEquipDuration( scriptInterface, stateContext, stateMachineInstanceData );
		weaponEquipAnimFeature.unequipDuration = GetUnequipDuration( scriptInterface, stateContext, stateMachineInstanceData );
		scriptInterface.SetAnimationParameterFeature( mappedInstanceData.itemHandlingFeatureName, animFeature, scriptInterface.executionOwner );
		scriptInterface.SetAnimationParameterFeature( 'equipUnequipItem', animFeature, itemObject );
		weaponEquipEvent = new WeaponEquipEvent;
		weaponEquipEvent.animFeature = weaponEquipAnimFeature;
		weaponEquipEvent.item = itemObject;
		scriptInterface.executionOwner.QueueEvent( weaponEquipEvent );
		if( itemObject.WeaponHasTag( 'Throwable' ) && !( scriptInterface.GetStatPoolsSystem().HasStatPoolValueReachedMax( itemObject.GetEntityID(), gamedataStatPoolType.ThrowRecovery ) ) )
		{
			animFeatureMeleeData = new AnimFeature_MeleeData;
			animFeatureMeleeData.isThrowReloading = true;
			scriptInterface.SetAnimationParameterFeature( 'MeleeData', animFeatureMeleeData );
		}
		scriptInterface.executionOwner.QueueEventForEntityID( ( ( WeaponObject )( itemObject ) ).GetEntityID(), new PlayerWeaponSetupEvent );
		statsEvent = new UpdateWeaponStatsEvent;
		scriptInterface.executionOwner.QueueEventForEntityID( itemObject.GetEntityID(), statsEvent );
		if( weaponEquipAnimFeature.firstEquip )
		{
			scriptInterface.SetAnimationParameterFloat( 'safe', 0.0 );
			stateContext.SetPermanentBoolParameter( 'WeaponInSafe', false, true );
			stateContext.SetPermanentFloatParameter( 'TurnOffPublicSafeTimeStamp', EngineTime.ToFloat( GameInstance.GetSimTime( scriptInterface.owner.GetGame() ) ), true );
		}
		else if( stateContext.GetBoolParameter( 'InPublicZone', true ) )
		{
		}
		else if( stateContext.GetBoolParameter( 'WeaponInSafe', true ) )
		{
			scriptInterface.SetAnimationParameterFloat( 'safe', 1.0 );
		}
		autoRefillRatio = statSystem.GetStatValue( itemObject.GetEntityID(), gamedataStatType.MagazineAutoRefill );
		if( autoRefillRatio > 0.0 )
		{
			magazineCapacity = WeaponObject.GetMagazineCapacity( itemObject );
			autoRefillEvent = new SetAmmoCountEvent;
			autoRefillEvent.ammoTypeID = WeaponObject.GetAmmoType( itemObject );
			autoRefillEvent.count = ( ( Uint32 )( ( ( Float )( magazineCapacity ) ) * autoRefillRatio ) );
			itemObject.QueueEvent( autoRefillEvent );
		}
	}

	protected const function HandleWeaponUnequip( scriptInterface : StateGameScriptInterface, stateContext : StateContext, stateMachineInstanceData : StateMachineInstanceData, item : ItemID )
	{
		var itemObject : weak< WeaponObject >;
		var mappedInstanceData : InstanceDataMappedToReferenceName;
		var unequipStartEvent : UnequipStart;
		var animFeature : AnimFeature_EquipUnequipItem;
		var transactionSystem : TransactionSystem;
		var placementSlot : TweakDBID;
		var gunzerkerLevel : Int32;
		var playerDevelopmentData : PlayerDevelopmentData;
		mappedInstanceData = GetMappedInstanceData( stateMachineInstanceData.referenceName );
		unequipStartEvent = new UnequipStart;
		animFeature = new AnimFeature_EquipUnequipItem;
		transactionSystem = scriptInterface.GetTransactionSystem();
		placementSlot = EquipmentSystem.GetPlacementSlot( item );
		playerDevelopmentData = PlayerDevelopmentSystem.GetData( scriptInterface.executionOwner );
		itemObject = ( ( WeaponObject )( transactionSystem.GetItemInSlot( scriptInterface.executionOwner, TDBID.Create( mappedInstanceData.attachmentSlot ) ) ) );
		animFeature.stateTransitionDuration = GetWeaponUnEquipDuration( scriptInterface, stateContext, stateMachineInstanceData );
		animFeature.itemState = 3;
		animFeature.itemType = ( ( Int32 )( TDB.GetItemRecord( ItemID.GetTDBID( item ) ).ItemType().AnimFeatureIndex() ) );
		BlockAimingForTime( stateContext, scriptInterface, animFeature.stateTransitionDuration + 0.1 );
		scriptInterface.SetAnimationParameterFeature( mappedInstanceData.itemHandlingFeatureName, animFeature, scriptInterface.executionOwner );
		scriptInterface.SetAnimationParameterFeature( 'equipUnequipItem', animFeature, itemObject );
		unequipStartEvent.SetSlotID( placementSlot );
		scriptInterface.executionOwner.QueueEvent( unequipStartEvent );
		gunzerkerLevel = playerDevelopmentData.IsNewPerkBought( gamedataNewPerkType.Reflexes_Master_Perk_2 );
		if( ( itemObject && ( gunzerkerLevel > 0 ) ) && WeaponObject.GetWeaponType( itemObject.GetItemID() ) == gamedataItemType.Wea_SubmachineGun )
		{
			itemObject.StartReload();
			itemObject.StopReload( gameweaponReloadStatus.Standard );
		}
	}

	protected function DropActiveWeapon( scriptInterface : StateGameScriptInterface, stateContext : StateContext, stateMachineInstanceData : StateMachineInstanceData )
	{
		var cameraWorldTransform : Transform;
		var transformVec : Vector4;
		var worldPosition : Vector4;
		var dropRotation : Quaternion;
		var weaponID : ItemID;
		cameraWorldTransform = scriptInterface.GetCameraWorldTransform();
		transformVec = Vector4( 0.40000001, -0.60000002, -0.5, 0.0 );
		worldPosition = Transform.TransformPoint( cameraWorldTransform, transformVec );
		dropRotation = GetActiveWeapon( scriptInterface ).GetWorldOrientation();
		Quaternion.SetZRot( dropRotation, RandRangeF( 0.0, 180.0 ) );
		weaponID = GetItemIDFromParam( stateMachineInstanceData, stateContext );
		GameInstance.GetLootManager( scriptInterface.owner.GetGame() ).SpawnItemDrop( scriptInterface.owner, weaponID, worldPosition, dropRotation );
	}

	protected function CreateAndSendFirstEquipEndRequest( scriptInterface : StateGameScriptInterface, weaponTweakID : TweakDBID )
	{
		var requestToSend : CompletionOfFirstEquipRequest;
		var firstEqSystem : FirstEquipSystem;
		firstEqSystem = FirstEquipSystem.GetInstance( scriptInterface.owner );
		requestToSend = new CompletionOfFirstEquipRequest;
		requestToSend.weaponID = weaponTweakID;
		firstEqSystem.QueueRequest( requestToSend );
	}

	protected const function HasThrowableCooldown( scriptInterface : StateGameScriptInterface, weapon : WeaponObject ) : Bool
	{
		if( !( weapon ) )
		{
			return false;
		}
		if( !( weapon.WeaponHasTag( 'Throwable' ) ) )
		{
			return false;
		}
		if( scriptInterface.GetStatPoolsSystem().HasStatPoolValueReachedMax( weapon.GetEntityID(), gamedataStatPoolType.ThrowRecovery ) )
		{
			return false;
		}
		return true;
	}

	protected const function GetSlotAttachedItem( const scriptInterface : StateGameScriptInterface, stateMachineInstanceData : StateMachineInstanceData ) : ItemObject
	{
		var mappedInstanceData : InstanceDataMappedToReferenceName;
		mappedInstanceData = GetMappedInstanceData( stateMachineInstanceData.referenceName );
		return scriptInterface.GetTransactionSystem().GetItemInSlot( scriptInterface.executionOwner, TDBID.Create( mappedInstanceData.attachmentSlot ) );
	}

	protected const function GetSlotAttachedItemID( const scriptInterface : StateGameScriptInterface, stateMachineInstanceData : StateMachineInstanceData ) : ItemID
	{
		var item : ItemObject;
		item = GetSlotAttachedItem( scriptInterface, stateMachineInstanceData );
		if( item )
		{
			return item.GetItemID();
		}
		return ItemID.None();
	}

	protected const function GetSlotAttachedItemObject( const scriptInterface : StateGameScriptInterface, stateMachineInstanceData : StateMachineInstanceData ) : ItemObject
	{
		var mappedInstanceData : InstanceDataMappedToReferenceName;
		mappedInstanceData = GetMappedInstanceData( stateMachineInstanceData.referenceName );
		return scriptInterface.GetTransactionSystem().GetItemInSlot( scriptInterface.executionOwner, TDBID.Create( mappedInstanceData.attachmentSlot ) );
	}

	protected const function IsProperItemEquipped( const scriptInterface : StateGameScriptInterface, const stateContext : StateContext, stateMachineInstanceData : StateMachineInstanceData ) : Bool
	{
		var item : ItemID;
		var slotActiveItem : ItemID;
		item = GetItemIDFromParam( stateMachineInstanceData, stateContext );
		slotActiveItem = GetSlotActiveItem( scriptInterface, stateMachineInstanceData );
		return item == slotActiveItem;
	}

	protected const function GetSlotActiveItem( const scriptInterface : StateGameScriptInterface, stateMachineInstanceData : StateMachineInstanceData ) : ItemID
	{
		return EquipmentSystem.GetSlotActiveItem( scriptInterface.executionOwner, ReferenceNameToRequestSlot( stateMachineInstanceData ) );
	}

	protected const function GetEquipDuration( const scriptInterface : StateGameScriptInterface, const stateContext : StateContext, stateMachineInstanceData : StateMachineInstanceData ) : Float
	{
		switch( GetItemCategoryFromItemID( GetSlotAttachedItemID( scriptInterface, stateMachineInstanceData ) ) )
		{
			case gamedataItemCategory.Weapon:
			{
				return GetWeaponEquipDuration( scriptInterface, stateContext, stateMachineInstanceData );
			}
			case gamedataItemCategory.Consumable:
			{
				return 0.0;
			}
			case gamedataItemCategory.Gadget:
			{
				return 0.0;
			}
			case gamedataItemCategory.Cyberware:
			{
				return GetWeaponEquipDuration( scriptInterface, stateContext, stateMachineInstanceData );
			}
		}
		return 1.0;
	}

	protected const function GetUnequipDuration( const scriptInterface : StateGameScriptInterface, stateContext : StateContext, stateMachineInstanceData : StateMachineInstanceData ) : Float
	{
		switch( GetItemCategoryFromItemID( GetSlotAttachedItemID( scriptInterface, stateMachineInstanceData ) ) )
		{
			case gamedataItemCategory.Weapon:
			{
				return GetWeaponUnEquipDuration( scriptInterface, stateContext, stateMachineInstanceData );
			}
			case gamedataItemCategory.Consumable:
			{
				return GetConsumableUnEquipDuration( stateMachineInstanceData, stateContext );
			}
			case gamedataItemCategory.Gadget:
			{
				return 0.0;
			}
			case gamedataItemCategory.Cyberware:
			{
				return 0.0;
			}
			default:
				return 0.5;
		}
	}

	protected const function IsLeftHandLogic( stateMachineInstanceData : StateMachineInstanceData ) : Bool
	{
		return stateMachineInstanceData.referenceName == 'LeftHand';
	}

	protected const function IsRightHandLogic( stateMachineInstanceData : StateMachineInstanceData ) : Bool
	{
		return stateMachineInstanceData.referenceName == 'RightHand';
	}

	protected const function AddConsumableStateMachine( const scriptInterface : StateGameScriptInterface )
	{
		var psmAdd : PSMAddOnDemandStateMachine;
		psmAdd = new PSMAddOnDemandStateMachine;
		psmAdd.stateMachineName = 'Consumable';
		scriptInterface.executionOwner.QueueEvent( psmAdd );
	}

	protected const function RemoveConsumableStateMachine( const scriptInterface : StateGameScriptInterface )
	{
		var psmRemove : PSMRemoveOnDemandStateMachine;
		var psmIdent : StateMachineIdentifier;
		psmRemove = new PSMRemoveOnDemandStateMachine;
		psmIdent.definitionName = 'Consumable';
		psmRemove.stateMachineIdentifier = psmIdent;
		scriptInterface.executionOwner.QueueEvent( psmRemove );
	}

	protected const function AddGrenadesStateMachine( const scriptInterface : StateGameScriptInterface )
	{
		var psmAdd : PSMAddOnDemandStateMachine;
		psmAdd = new PSMAddOnDemandStateMachine;
		psmAdd.stateMachineName = 'CombatGadget';
		scriptInterface.executionOwner.QueueEvent( psmAdd );
	}

	protected const function RemoveGrenadesStateMachine( const scriptInterface : StateGameScriptInterface )
	{
		var psmRemove : PSMRemoveOnDemandStateMachine;
		var psmIdent : StateMachineIdentifier;
		psmRemove = new PSMRemoveOnDemandStateMachine;
		psmIdent.definitionName = 'CombatGadget';
		psmRemove.stateMachineIdentifier = psmIdent;
		scriptInterface.executionOwner.QueueEvent( psmRemove );
	}

	protected const function AddCyberwareStateMachine( const scriptInterface : StateGameScriptInterface )
	{
		var psmAdd : PSMAddOnDemandStateMachine;
		psmAdd = new PSMAddOnDemandStateMachine;
		psmAdd.stateMachineName = 'LeftHandCyberware';
		scriptInterface.executionOwner.QueueEvent( psmAdd );
	}

	protected const function RemoveCyberwareStateMachine( const scriptInterface : StateGameScriptInterface )
	{
		var psmRemove : PSMRemoveOnDemandStateMachine;
		var psmIdent : StateMachineIdentifier;
		psmRemove = new PSMRemoveOnDemandStateMachine;
		psmIdent.definitionName = 'LeftHandCyberware';
		psmRemove.stateMachineIdentifier = psmIdent;
		scriptInterface.executionOwner.QueueEvent( psmRemove );
	}

	protected const function SetRightHandItemParam( stateContext : StateContext, item : ItemID )
	{
		var wrapper : ItemIdWrapper;
		wrapper = new ItemIdWrapper;
		wrapper.itemID = item;
		stateContext.SetPermanentScriptableParameter( 'rightHandItem', wrapper, true );
	}

	protected const function ClearRightHandItemParam( stateContext : StateContext )
	{
		stateContext.RemovePermanentScriptableParameter( 'rightHandItem' );
	}

	protected const function SetLeftHandItemParam( stateContext : StateContext, item : ItemID )
	{
		var wrapper : ItemIdWrapper;
		wrapper = new ItemIdWrapper;
		wrapper.itemID = item;
		stateContext.SetPermanentScriptableParameter( 'leftHandItem', wrapper, true );
	}

	protected const function ClearLeftHandItemParam( stateContext : StateContext )
	{
		stateContext.RemovePermanentScriptableParameter( 'leftHandItem' );
	}

	protected const function ClearHandItemParam( stateContext : StateContext, stateMachineInstanceData : StateMachineInstanceData )
	{
		if( IsRightHandLogic( stateMachineInstanceData ) )
		{
			ClearRightHandItemParam( stateContext );
		}
		else if( IsLeftHandLogic( stateMachineInstanceData ) )
		{
			ClearLeftHandItemParam( stateContext );
		}
	}

	protected const function GetItemIDFromParam( stateMachineInstanceData : StateMachineInstanceData, const stateContext : StateContext ) : ItemID
	{
		if( IsRightHandLogic( stateMachineInstanceData ) )
		{
			return GetRightHandItemFromParam( stateContext );
		}
		else if( IsLeftHandLogic( stateMachineInstanceData ) )
		{
			return GetLeftHandItemFromParam( stateContext );
		}
		else
		{
			return ItemID.None();
		}
	}

	protected const function GetBlurParametersFromWeapon( scriptInterface : StateGameScriptInterface )
	{
		var animFeature : AnimFeature_WeaponBlur;
		var weapon : WeaponObject;
		var weaponTDB : TweakDBID;
		animFeature = new AnimFeature_WeaponBlur;
		weapon = GetActiveWeapon( scriptInterface );
		weaponTDB = ItemID.GetTDBID( weapon.GetItemID() );
		animFeature.weaponNearPlane = TDB.GetFloat( weaponTDB + T".weaponNearPlane" );
		animFeature.weaponFarPlane = TDB.GetFloat( weaponTDB + T".weaponFarPlane" );
		animFeature.weaponEdgesSharpness = TDB.GetFloat( weaponTDB + T".weaponEdgesSharpness" );
		animFeature.weaponVignetteIntensity = TDB.GetFloat( weaponTDB + T".weaponVignetteIntensity" );
		animFeature.weaponVignetteRadius = TDB.GetFloat( weaponTDB + T".weaponVignetteRadius" );
		animFeature.weaponVignetteCircular = TDB.GetFloat( weaponTDB + T".weaponVignetteCircular" );
		animFeature.weaponBlurIntensity = TDB.GetFloat( weaponTDB + T".weaponBlurIntensity" );
		animFeature.weaponNearPlane_aim = TDB.GetFloat( weaponTDB + T".weaponNearPlane_aim" );
		animFeature.weaponFarPlane_aim = TDB.GetFloat( weaponTDB + T".weaponFarPlane_aim" );
		animFeature.weaponEdgesSharpness_aim = TDB.GetFloat( weaponTDB + T".weaponEdgesSharpness_aim" );
		animFeature.weaponVignetteIntensity_aim = TDB.GetFloat( weaponTDB + T".weaponVignetteIntensity_aim" );
		animFeature.weaponVignetteRadius_aim = TDB.GetFloat( weaponTDB + T".weaponVignetteRadius_aim" );
		animFeature.weaponVignetteCircular_aim = TDB.GetFloat( weaponTDB + T".weaponVignetteCircular_aim" );
		animFeature.weaponBlurIntensity_aim = TDB.GetFloat( weaponTDB + T".weaponBlurIntensity_aim" );
		scriptInterface.SetAnimationParameterFeature( 'WeaponBlurData', animFeature );
	}

	protected const function CanProcessEquip( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var upperBodyState : Int32;
		upperBodyState = scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.UpperBody );
		return ( ( !( IsPlayerInAnyMenu( scriptInterface ) ) && CheckGenericEquipItemConditions( stateContext, scriptInterface ) ) && ( upperBodyState != ( ( Int32 )( gamePSMUpperBodyStates.TemporaryUnequip ) ) ) ) && ( ( upperBodyState != ( ( Int32 )( gamePSMUpperBodyStates.ForceEmptyHands ) ) ) || HasActiveConsumable( scriptInterface ) );
	}

	protected const function CanProcessUnEquip( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return !( IsPlayerInAnyMenu( scriptInterface ) );
	}

}

abstract class EquipmentBaseDecisions extends EquipmentBaseTransition
{
}

abstract class EquipmentBaseEvents extends EquipmentBaseTransition
{
}

class UnequippedDecisions extends EquipmentBaseDecisions
{
	const var stateMachineInstanceData : StateMachineInstanceData;
	const var stateMachineInitData : weak< EquipmentInitData >;

	protected export const function ToUnequippedWaitingForExternalFactors( stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var equipRequestOccuredThisFrame : Bool;
		var hasEquipProcessedPrevFrame : Bool;
		var upperBodyState : Int32;
		equipRequestOccuredThisFrame = false;
		hasEquipProcessedPrevFrame = false;
		if( CheckSlotMatchAndCompareRequestType( stateContext, stateMachineInstanceData, stateMachineInitData, EquipmentManipulationRequestType.Equip ) )
		{
			SaveProcessedEquipmentManipulationRequest( stateContext, stateMachineInstanceData, stateMachineInitData );
			equipRequestOccuredThisFrame = true;
		}
		if( !( equipRequestOccuredThisFrame ) )
		{
			hasEquipProcessedPrevFrame = GetProcessedEquipmentManipulationRequest( stateMachineInstanceData, stateContext );
		}
		if( equipRequestOccuredThisFrame || hasEquipProcessedPrevFrame )
		{
			return true;
		}
		if( CheckReplicatedEquipRequest( scriptInterface, stateContext, stateMachineInstanceData ) )
		{
			return true;
		}
		upperBodyState = scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.UpperBody );
		if( ( ( ( !( IsProperItemEquipped( scriptInterface, stateContext, stateMachineInstanceData ) ) && IsRightHandLogic( stateMachineInstanceData ) ) && ( upperBodyState != ( ( Int32 )( gamePSMUpperBodyStates.TemporaryUnequip ) ) ) ) && ( upperBodyState != ( ( Int32 )( gamePSMUpperBodyStates.ForceEmptyHands ) ) ) ) && GetItemCategoryFromItemID( GetSlotAttachedItemID( scriptInterface, stateMachineInstanceData ) ) != gamedataItemCategory.Gadget )
		{
			return true;
		}
		return false;
	}

}

class DelayedAnimFeatureCall extends DelayCallback
{
	var featureName : CName;
	var animFeature : AnimFeature_EquipUnequipItem;
	var scriptInterface : StateGameScriptInterface;

	public override function Call()
	{
		if( scriptInterface )
		{
			scriptInterface.SetAnimationParameterFeature( featureName, animFeature );
		}
	}

}

class UnequippedEvents extends EquipmentBaseEvents
{
	const var stateMachineInstanceData : StateMachineInstanceData;
	const var stateMachineInitData : weak< EquipmentInitData >;

	protected export virtual function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var itemHandling : AnimFeature_EquipUnequipItem;
		var mappedInstanceData : InstanceDataMappedToReferenceName;
		var delayedAnimFeature : DelayedAnimFeatureCall;
		mappedInstanceData = GetMappedInstanceData( stateMachineInstanceData.referenceName );
		itemHandling = new AnimFeature_EquipUnequipItem;
		itemHandling.itemState = 0;
		if( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.Vehicle ) == ( ( Int32 )( gamePSMVehicle.DriverCombat ) ) )
		{
			delayedAnimFeature = new DelayedAnimFeatureCall;
			delayedAnimFeature.featureName = mappedInstanceData.itemHandlingFeatureName;
			delayedAnimFeature.animFeature = itemHandling;
			delayedAnimFeature.scriptInterface = scriptInterface;
			scriptInterface.GetDelaySystem().DelayCallbackNextFrame( delayedAnimFeature );
		}
		else
		{
			scriptInterface.SetAnimationParameterFeature( mappedInstanceData.itemHandlingFeatureName, itemHandling );
		}
		if( IsRightHandLogic( stateMachineInstanceData ) )
		{
			ClearRightHandItemParam( stateContext );
		}
		else if( IsLeftHandLogic( stateMachineInstanceData ) )
		{
			ClearLeftHandItemParam( stateContext );
		}
		ClearProcessedEquipmentManipulationRequest( stateMachineInstanceData, stateContext );
	}

	protected export function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		stateContext.RemovePermanentScriptableParameter( stateMachineInitData.eqManipulationVarName );
	}

}

class UnequippedWaitingForExternalFactorsDecisions extends EquipmentBaseDecisions
{
	const var stateMachineInstanceData : StateMachineInstanceData;
	const var stateMachineInitData : weak< EquipmentInitData >;

	protected export const function ExitCondition( stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsRightHandLogic( stateMachineInstanceData ) )
		{
			if( !( CanProcessEquip( stateContext, scriptInterface ) ) )
			{
				return false;
			}
		}
		else if( IsLeftHandLogic( stateMachineInstanceData ) )
		{
			if( !( CheckGenericEquipItemConditions( stateContext, scriptInterface ) ) || ( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.UpperBody ) == ( ( Int32 )( gamePSMUpperBodyStates.ForceEmptyHands ) ) ) )
			{
				return false;
			}
		}
		return true;
	}

}

class UnequippedWaitingForExternalFactorsEvents extends EquipmentBaseEvents
{
}

class SelfRemovalDecisions extends StateFunctor
{
}

class SelfRemovalEvents extends StateFunctor
{
	const var stateMachineInstanceData : StateMachineInstanceData;

	private export function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var psmRemove : PSMRemoveOnDemandStateMachine;
		var psmIdent : StateMachineIdentifier;
		psmRemove = new PSMRemoveOnDemandStateMachine;
		psmIdent.definitionName = 'Equipment';
		psmIdent.referenceName = stateMachineInstanceData.referenceName;
		psmRemove.stateMachineIdentifier = psmIdent;
		scriptInterface.executionOwner.QueueEvent( psmRemove );
	}

}

class EquippedDecisions extends EquipmentBaseDecisions
{
	const var stateMachineInstanceData : StateMachineInstanceData;
	const var stateMachineInitData : weak< EquipmentInitData >;

	protected export const function ToUnequipCycle( stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var equipRequestOccuredThisFrame : Bool;
		var hasEquipProcessedPrevFrame : Bool;
		var upperBodyState : Int32;
		equipRequestOccuredThisFrame = false;
		hasEquipProcessedPrevFrame = false;
		upperBodyState = 0;
		if( CheckSlotMatchAndCompareRequestType( stateContext, stateMachineInstanceData, stateMachineInitData, EquipmentManipulationRequestType.Unequip ) )
		{
			SaveProcessedEquipmentManipulationRequest( stateContext, stateMachineInstanceData, stateMachineInitData );
			equipRequestOccuredThisFrame = true;
		}
		if( CheckSlotMatchAndCompareRequestType( stateContext, stateMachineInstanceData, stateMachineInitData, EquipmentManipulationRequestType.Equip ) && !( IsProperItemEquipped( scriptInterface, stateContext, stateMachineInstanceData ) ) )
		{
			SaveProcessedEquipmentManipulationRequest( stateContext, stateMachineInstanceData, stateMachineInitData );
			equipRequestOccuredThisFrame = true;
		}
		if( !( equipRequestOccuredThisFrame ) )
		{
			hasEquipProcessedPrevFrame = GetProcessedEquipmentManipulationRequest( stateMachineInstanceData, stateContext );
		}
		if( IsRightHandLogic( stateMachineInstanceData ) )
		{
			if( !( CanProcessUnEquip( stateContext, scriptInterface ) ) )
			{
				return false;
			}
		}
		if( equipRequestOccuredThisFrame || hasEquipProcessedPrevFrame )
		{
			return true;
		}
		if( CheckReplicatedEquipRequest( scriptInterface, stateContext, stateMachineInstanceData ) )
		{
			return true;
		}
		upperBodyState = scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.UpperBody );
		if( ( ( upperBodyState == ( ( Int32 )( gamePSMUpperBodyStates.TemporaryUnequip ) ) ) && IsRightHandLogic( stateMachineInstanceData ) ) || ( upperBodyState == ( ( Int32 )( gamePSMUpperBodyStates.ForceEmptyHands ) ) ) )
		{
			return true;
		}
		if( !( IsServer() ) )
		{
			if( ( !( IsProperItemEquipped( scriptInterface, stateContext, stateMachineInstanceData ) ) && IsRightHandLogic( stateMachineInstanceData ) ) && GetItemCategoryFromItemID( GetSlotAttachedItemID( scriptInterface, stateMachineInstanceData ) ) != gamedataItemCategory.Gadget )
			{
				return true;
			}
		}
		return false;
	}

}

class EquippedEvents extends EquipmentBaseEvents
{
	const var stateMachineInstanceData : StateMachineInstanceData;
	const var stateMachineInitData : weak< EquipmentInitData >;

	protected export virtual function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var broadcaster : StimBroadcasterComponent;
		if( IsRightHandLogic( stateMachineInstanceData ) )
		{
			MeleeTransition.ClearInputBuffer( stateContext );
			broadcaster = scriptInterface.executionOwner.GetStimBroadcasterComponent();
			if( !( WeaponObject.IsFists( GameObject.GetActiveWeapon( scriptInterface.executionOwner ).GetItemID() ) ) && !( stateContext.GetBoolParameter( 'weaponDisplayedStimuli', true ) ) )
			{
				if( broadcaster )
				{
					broadcaster.TriggerSingleBroadcast( scriptInterface.executionOwner, gamedataStimType.WeaponDisplayed );
				}
			}
			else if( WeaponObject.IsFists( GameObject.GetActiveWeapon( scriptInterface.executionOwner ).GetItemID() ) )
			{
				if( broadcaster )
				{
					broadcaster.TriggerSingleBroadcast( scriptInterface.executionOwner, gamedataStimType.WeaponHolstered );
				}
			}
			stateContext.RemovePermanentBoolParameter( 'weaponDisplayedStimuli' );
		}
		ClearProcessedEquipmentManipulationRequest( stateMachineInstanceData, stateContext );
	}

	protected export function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		stateContext.RemovePermanentScriptableParameter( stateMachineInitData.eqManipulationVarName );
	}

}

class EquipCycleInitDecisions extends EquipmentBaseDecisions
{
	const var stateMachineInstanceData : StateMachineInstanceData;

	public constexpr const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var item : ItemID;
		var equipmentSystemPlayerData : EquipmentSystemPlayerData;
		var record : Item_Record;
		var vehicleState : CName;
		record = TweakDBInterface.GetItemRecord( ItemID.GetTDBID( item ) );
		item = GetSlotActiveItem( scriptInterface, stateMachineInstanceData );
		if( !( ItemID.IsValid( item ) ) )
		{
			return true;
		}
		record = TweakDBInterface.GetItemRecord( ItemID.GetTDBID( item ) );
		if( !( record ) || record.ItemCategory().Type() != gamedataItemCategory.Weapon )
		{
			return true;
		}
		equipmentSystemPlayerData = EquipmentSystem.GetData( scriptInterface.executionOwner );
		if( !( equipmentSystemPlayerData ) )
		{
			return true;
		}
		if( WeaponObject.IsCyberwareWeapon( item ) )
		{
			vehicleState = stateContext.GetStateMachineCurrentState( 'Vehicle' );
			if( ( vehicleState == 'exit' || vehicleState == 'coolExiting' ) || vehicleState == 'slideExiting' )
			{
				return true;
			}
		}
		if( equipmentSystemPlayerData.CheckWeaponAgainstGameplayRestrictions( item ) )
		{
			return true;
		}
		return false;
	}

	protected export const function ToEquipCycle( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return IsVisualItemInSlot( scriptInterface, stateMachineInstanceData ) || IsUsingFluffConsumable( scriptInterface, stateMachineInstanceData );
	}

	protected export const function ToUnequipped( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var threshold : Float;
		threshold = 1.0;
		if( GetInStateTime() >= threshold )
		{
			return true;
		}
		return false;
	}

}

class EquipCycleInitEvents extends EquipmentBaseEvents
{
	const var stateMachineInstanceData : StateMachineInstanceData;

	protected export virtual function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var equipStartEvent : EquipStart;
		var placementSlot : TweakDBID;
		var item : ItemID;
		var multiplayerRequestData : parameterRequestItem;
		var itemHandling : AnimFeature_EquipUnequipItem;
		var mappedInstanceData : InstanceDataMappedToReferenceName;
		equipStartEvent = new EquipStart;
		multiplayerRequestData = ( ( parameterRequestItem )( stateContext.GetTemporaryScriptableParameter( 'cpo_replicatedEquipRequest' ) ) );
		if( multiplayerRequestData == NULL )
		{
			multiplayerRequestData = ( ( parameterRequestItem )( stateContext.GetConditionScriptableParameter( 'cpo_replicatedEquipRequest' ) ) );
			if( multiplayerRequestData != NULL )
			{
				stateContext.RemoveConditionScriptableParameter( 'cpo_replicatedEquipRequest' );
			}
		}
		if( IsServer() && ( multiplayerRequestData != NULL ) )
		{
			item = multiplayerRequestData.requests[ 0 ].itemIDToEquip;
			placementSlot = multiplayerRequestData.requests[ 0 ].slotID;
		}
		else
		{
			item = GetSlotActiveItem( scriptInterface, stateMachineInstanceData );
			placementSlot = EquipmentSystem.GetPlacementSlot( item );
		}
		if( ItemID.IsValid( item ) )
		{
			if( !( WeaponObject.IsRanged( item ) ) && !( stateContext.IsStateMachineActive( 'Vehicle' ) ) )
			{
				mappedInstanceData = GetMappedInstanceData( stateMachineInstanceData.referenceName );
				itemHandling = new AnimFeature_EquipUnequipItem;
				itemHandling.itemState = 0;
				scriptInterface.SetAnimationParameterFeature( mappedInstanceData.itemHandlingFeatureName, itemHandling );
			}
			if( IsClient() && scriptInterface.owner.IsControlledByLocalPeer() )
			{
				scriptInterface.RequestWeaponEquipOnServer( placementSlot, item );
			}
			if( !( IsUsingFluffConsumable( scriptInterface, stateMachineInstanceData ) ) )
			{
				equipStartEvent.SetSlotID( placementSlot );
				equipStartEvent.SetItemID( item );
				equipStartEvent.SetHighPriority( WeaponObject.GetWeaponType( item ) != gamedataItemType.Invalid );
				if( !( stateContext.IsStateMachineActive( 'Vehicle' ) ) || GetMountedVehicle( scriptInterface.executionOwner ).GetCameraManager().GetActivePerspective() == vehicleCameraPerspective.FPP )
				{
					equipStartEvent.SetStartingRenderingPlane( ERenderingPlane.RPl_Weapon );
				}
				equipStartEvent.SetFirstEquip( false );
				scriptInterface.executionOwner.QueueEvent( equipStartEvent );
			}
			if( IsRightHandLogic( stateMachineInstanceData ) )
			{
				SetRightHandItemParam( stateContext, item );
			}
			else if( IsLeftHandLogic( stateMachineInstanceData ) )
			{
				SetLeftHandItemParam( stateContext, item );
			}
		}
	}

	protected export virtual function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var mappedInstanceData : InstanceDataMappedToReferenceName;
		var item : ItemID;
		mappedInstanceData = GetMappedInstanceData( stateMachineInstanceData.referenceName );
		item = scriptInterface.GetTransactionSystem().GetItemInSlot( scriptInterface.executionOwner, TDBID.Create( mappedInstanceData.attachmentSlot ) ).GetItemID();
		if( IsMultiplayer() )
		{
			scriptInterface.GetTransactionSystem().SetActiveItemInSlot( scriptInterface.executionOwner, TDBID.Create( mappedInstanceData.attachmentSlot ), item );
		}
	}

}

class EquipCycleDecisions extends EquipmentBaseDecisions
{
	const var stateMachineInstanceData : StateMachineInstanceData;

	protected export const function ToEquipped( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var threshold : Float;
		var validPSMState : Bool;
		threshold = GetEquipDuration( scriptInterface, stateContext, stateMachineInstanceData );
		validPSMState = GetIsPSMInValidState( scriptInterface, stateContext, stateMachineInstanceData );
		return !( validPSMState ) || ( GetInStateTime() >= threshold );
	}

	protected constexpr export const function ToUnequipCycle( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return false;
	}

	protected export const function ToFirstEquip( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var firstEquipResult : StateResultBool;
		var preventFirstEquip : Bool;
		var firstEqSystem : FirstEquipSystem;
		var itemId : ItemID;
		firstEqSystem = FirstEquipSystem.GetInstance( scriptInterface.owner );
		firstEquipResult = stateContext.GetConditionBoolParameter( 'firstEquip' );
		preventFirstEquip = scriptInterface.localBlackboard.GetBool( GetAllBlackboardDefs().PlayerStateMachine.ScenePreventFirstEquip ) || scriptInterface.localBlackboard.GetBool( GetAllBlackboardDefs().PlayerStateMachine.MountedPreventFirstEquip );
		itemId = GetSlotActiveItem( scriptInterface, stateMachineInstanceData );
		return ( ( firstEquipResult.value && !( preventFirstEquip ) ) && ToEquipped( stateContext, scriptInterface ) ) && !( firstEqSystem.HasPlayedFirstEquip( ItemID.GetTDBID( itemId ) ) );
	}

}

class EquipCycleEvents extends EquipmentBaseEvents
{
	const var stateMachineInstanceData : StateMachineInstanceData;

	protected export virtual function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var item : ItemID;
		item = GetItemIDFromParam( stateMachineInstanceData, stateContext );
		if( !( ItemID.IsValid( item ) ) )
		{
			return;
		}
		if( IsRightHandLogic( stateMachineInstanceData ) )
		{
			if( GetItemCategoryFromItemID( item ) == gamedataItemCategory.Weapon )
			{
				HandleWeaponEquip( scriptInterface, stateContext, stateMachineInstanceData, item );
				return;
			}
		}
		if( IsLeftHandLogic( stateMachineInstanceData ) )
		{
			if( GetItemCategoryFromItemID( item ) == gamedataItemCategory.Consumable )
			{
				AddConsumableStateMachine( scriptInterface );
				return;
			}
			if( GetItemCategoryFromItemID( item ) == gamedataItemCategory.Gadget )
			{
				AddGrenadesStateMachine( scriptInterface );
				return;
			}
			if( GetItemCategoryFromItemID( item ) == gamedataItemCategory.Cyberware )
			{
				AddCyberwareStateMachine( scriptInterface );
				return;
			}
		}
	}

	protected export virtual function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var item : ItemID;
		var itemObject : weak< WeaponObject >;
		var mappedInstanceData : InstanceDataMappedToReferenceName;
		var animFeature : AnimFeature_EquipUnequipItem;
		var statSystem : StatsSystem;
		item = GetItemIDFromParam( stateMachineInstanceData, stateContext );
		mappedInstanceData = GetMappedInstanceData( stateMachineInstanceData.referenceName );
		animFeature = new AnimFeature_EquipUnequipItem;
		statSystem = scriptInterface.GetStatsSystem();
		if( !( ItemID.IsValid( item ) ) )
		{
			return;
		}
		if( IsRightHandLogic( stateMachineInstanceData ) )
		{
			if( GetItemCategoryFromItemID( item ) == gamedataItemCategory.Weapon )
			{
				itemObject = ( ( WeaponObject )( scriptInterface.GetTransactionSystem().GetItemInSlot( scriptInterface.executionOwner, TDBID.Create( mappedInstanceData.attachmentSlot ) ) ) );
				animFeature.stateTransitionDuration = statSystem.GetStatValue( itemObject.GetEntityID(), gamedataStatType.UnequipDuration );
				animFeature.itemState = 2;
				animFeature.itemType = ( ( Int32 )( TDB.GetItemRecord( ItemID.GetTDBID( item ) ).ItemType().AnimFeatureIndex() ) );
				scriptInterface.SetAnimationParameterFeature( mappedInstanceData.itemHandlingFeatureName, animFeature, scriptInterface.executionOwner );
				scriptInterface.SetAnimationParameterFeature( 'equipUnequipItem', animFeature, itemObject );
			}
		}
	}

}

class FirstEquipDecisions extends EquipmentBaseDecisions
{
	const var stateMachineInstanceData : StateMachineInstanceData;
	const var stateMachineInitData : weak< EquipmentInitData >;

	protected export const function ToEquipped( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var threshold : Float;
		var weapon : weak< WeaponObject >;
		var statSystem : StatsSystem;
		var validPSMState : Bool;
		var isAiming : Bool;
		var leftHandCyberState : gamePSMLeftHandCyberware;
		var upperBodyState : Int32;
		var locomotionDetailedState : Int32;
		statSystem = scriptInterface.GetStatsSystem();
		validPSMState = GetIsPSMInValidState( scriptInterface, stateContext, stateMachineInstanceData );
		isAiming = scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.UpperBody ) == ( ( Int32 )( gamePSMUpperBodyStates.Aim ) );
		if( isAiming )
		{
			return true;
		}
		upperBodyState = scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.UpperBody );
		locomotionDetailedState = scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.LocomotionDetailed );
		if( ( ( ( ( ( ( ( ( ( ( ( ( ( stateContext.IsStateMachineActive( 'CombatGadget' ) || stateContext.IsStateMachineActive( 'LocomotionSwimming' ) ) || stateContext.IsStateMachineActive( 'Vehicle' ) ) || stateContext.IsStateMachineActive( 'CarriedObject' ) ) || stateContext.IsStateMachineActive( 'Consumable' ) ) || stateContext.IsStateMachineActive( 'LocomotionTakedown' ) ) || ( upperBodyState == ( ( Int32 )( gamePSMUpperBodyStates.TemporaryUnequip ) ) ) ) || ( locomotionDetailedState == ( ( Int32 )( gamePSMDetailedLocomotionStates.Climb ) ) ) ) || ( locomotionDetailedState == ( ( Int32 )( gamePSMDetailedLocomotionStates.Ladder ) ) ) ) || ( locomotionDetailedState == ( ( Int32 )( gamePSMDetailedLocomotionStates.LadderSprint ) ) ) ) || ( locomotionDetailedState == ( ( Int32 )( gamePSMDetailedLocomotionStates.LadderSlide ) ) ) ) || ( locomotionDetailedState == ( ( Int32 )( gamePSMDetailedLocomotionStates.Vault ) ) ) ) || ( locomotionDetailedState == ( ( Int32 )( gamePSMDetailedLocomotionStates.SuperheroFall ) ) ) ) || ( locomotionDetailedState == ( ( Int32 )( gamePSMDetailedLocomotionStates.Slide ) ) ) ) || ( locomotionDetailedState == ( ( Int32 )( gamePSMDetailedLocomotionStates.SlideFall ) ) ) )
		{
			return true;
		}
		leftHandCyberState = ( ( gamePSMLeftHandCyberware )( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.LeftHandCyberware ) ) );
		if( ( leftHandCyberState != gamePSMLeftHandCyberware.Safe && leftHandCyberState != gamePSMLeftHandCyberware.Default ) && leftHandCyberState != gamePSMLeftHandCyberware.Idle )
		{
			return true;
		}
		if( !( validPSMState ) )
		{
			return true;
		}
		weapon = ( ( WeaponObject )( GetSlotAttachedItemObject( scriptInterface, stateMachineInstanceData ) ) );
		threshold = statSystem.GetStatValue( weapon.GetEntityID(), gamedataStatType.EquipDuration_First ) - statSystem.GetStatValue( weapon.GetEntityID(), gamedataStatType.EquipDuration );
		if( GetInStateTime() >= threshold )
		{
			return true;
		}
		if( CheckSlotMatchAndCompareRequestType( stateContext, stateMachineInstanceData, stateMachineInitData, EquipmentManipulationRequestType.Unequip ) )
		{
			return true;
		}
		if( CheckSlotMatchAndCompareRequestType( stateContext, stateMachineInstanceData, stateMachineInitData, EquipmentManipulationRequestType.Equip ) && !( IsProperItemEquipped( scriptInterface, stateContext, stateMachineInstanceData ) ) )
		{
			return true;
		}
		return false;
	}

}

class FirstEquipEvents extends EquipmentBaseEvents
{
	const var stateMachineInstanceData : StateMachineInstanceData;
	const var stateMachineInitData : weak< EquipmentInitData >;

	protected export virtual function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var broadcaster : StimBroadcasterComponent;
		if( IsRightHandLogic( stateMachineInstanceData ) )
		{
			if( !( WeaponObject.IsFists( GameObject.GetActiveWeapon( scriptInterface.executionOwner ).GetItemID() ) ) )
			{
				broadcaster = scriptInterface.executionOwner.GetStimBroadcasterComponent();
				if( broadcaster )
				{
					broadcaster.TriggerSingleBroadcast( scriptInterface.executionOwner, gamedataStimType.WeaponDisplayed );
				}
				stateContext.SetPermanentBoolParameter( 'weaponDisplayedStimuli', true, true );
			}
		}
	}

	protected export virtual function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var itemObject : weak< WeaponObject >;
		var mappedInstanceData : InstanceDataMappedToReferenceName;
		mappedInstanceData = GetMappedInstanceData( stateMachineInstanceData.referenceName );
		itemObject = ( ( WeaponObject )( scriptInterface.GetTransactionSystem().GetItemInSlot( scriptInterface.executionOwner, TDBID.Create( mappedInstanceData.attachmentSlot ) ) ) );
		CreateAndSendFirstEquipEndRequest( scriptInterface, ItemID.GetTDBID( itemObject.GetItemID() ) );
		scriptInterface.PushAnimationEvent( 'FirstEquipEnd' );
		stateContext.SetConditionBoolParameter( 'firstEquip', false, true );
	}

}

class UnequipCycleDecisions extends EquipmentBaseDecisions
{
	const var stateMachineInstanceData : StateMachineInstanceData;

	protected export const function ToEquipCycleInit( stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var threshold : Float;
		var itemId : ItemID;
		var smConditions : Bool;
		var upperBodyState : Int32;
		threshold = GetUnequipDuration( scriptInterface, stateContext, stateMachineInstanceData );
		itemId = GetSlotActiveItem( scriptInterface, stateMachineInstanceData );
		upperBodyState = scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.UpperBody );
		smConditions = ( ( ( upperBodyState == ( ( Int32 )( gamePSMUpperBodyStates.TemporaryUnequip ) ) ) || ( upperBodyState == ( ( Int32 )( gamePSMUpperBodyStates.ForceEmptyHands ) ) ) ) || stateContext.GetStateMachineCurrentState( 'Vehicle' ) == 'entering' ) || stateContext.GetStateMachineCurrentState( 'Vehicle' ) == 'switchSeats';
		return ( ( GetInStateTime() >= threshold ) && ( itemId != ItemID.None() ) ) && !( smConditions );
	}

	protected export const function ToUnequipped( stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var threshold : Float;
		var upperBodyState : Int32;
		threshold = GetUnequipDuration( scriptInterface, stateContext, stateMachineInstanceData );
		upperBodyState = scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.UpperBody );
		if( ( GetInStateTime() >= threshold ) && ( GetSlotActiveItem( scriptInterface, stateMachineInstanceData ) == ItemID.None() ) )
		{
			if( IsLeftHandLogic( stateMachineInstanceData ) )
			{
				return !( stateContext.IsStateMachineActive( 'Consumable' ) ) && !( stateContext.IsStateMachineActive( 'CombatGadget' ) );
			}
			else if( IsRightHandLogic( stateMachineInstanceData ) )
			{
				return true;
			}
		}
		else if( ( ( ( ( upperBodyState == ( ( Int32 )( gamePSMUpperBodyStates.TemporaryUnequip ) ) ) || ( upperBodyState == ( ( Int32 )( gamePSMUpperBodyStates.ForceEmptyHands ) ) ) ) || stateContext.GetStateMachineCurrentState( 'Vehicle' ) == 'entering' ) || stateContext.GetStateMachineCurrentState( 'Vehicle' ) == 'switchSeats' ) && IsRightHandLogic( stateMachineInstanceData ) )
		{
			return true;
		}
		return false;
	}

}

class UnequipCycleEvents extends EquipmentBaseEvents
{
	const var stateMachineInstanceData : StateMachineInstanceData;

	protected export virtual function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var item : ItemID;
		item = GetItemIDFromParam( stateMachineInstanceData, stateContext );
		if( !( ItemID.IsValid( item ) ) )
		{
			return;
		}
		if( IsRightHandLogic( stateMachineInstanceData ) )
		{
			if( GetItemCategoryFromItemID( item ) == gamedataItemCategory.Weapon )
			{
				HandleWeaponUnequip( scriptInterface, stateContext, stateMachineInstanceData, item );
			}
		}
		if( IsLeftHandLogic( stateMachineInstanceData ) )
		{
			if( GetItemCategoryFromItemID( item ) == gamedataItemCategory.Consumable )
			{
				return;
			}
			if( GetItemCategoryFromItemID( item ) == gamedataItemCategory.Gadget )
			{
				return;
			}
			if( GetItemCategoryFromItemID( item ) == gamedataItemCategory.Cyberware )
			{
				RemoveCyberwareStateMachine( scriptInterface );
				return;
			}
		}
	}

	protected export virtual function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var item : ItemID;
		var itemObject : weak< GameObject >;
		var mappedInstanceData : InstanceDataMappedToReferenceName;
		var unequipEndEvent : UnequipEnd;
		var animFeature : AnimFeature_EquipUnequipItem;
		var statSystem : StatsSystem;
		var placementSlot : TweakDBID;
		var itemId : ItemID;
		var upperBodyState : Int32;
		item = GetItemIDFromParam( stateMachineInstanceData, stateContext );
		mappedInstanceData = GetMappedInstanceData( stateMachineInstanceData.referenceName );
		unequipEndEvent = new UnequipEnd;
		animFeature = new AnimFeature_EquipUnequipItem;
		statSystem = scriptInterface.GetStatsSystem();
		placementSlot = EquipmentSystem.GetPlacementSlot( item );
		itemId = GetSlotActiveItem( scriptInterface, stateMachineInstanceData );
		upperBodyState = 0;
		if( !( ItemID.IsValid( item ) ) )
		{
			return;
		}
		unequipEndEvent.SetSlotID( placementSlot );
		scriptInterface.executionOwner.QueueEvent( unequipEndEvent );
		if( IsRightHandLogic( stateMachineInstanceData ) )
		{
			if( GetItemCategoryFromItemID( item ) == gamedataItemCategory.Weapon )
			{
				animFeature.stateTransitionDuration = statSystem.GetStatValue( scriptInterface.executionOwnerEntityID, gamedataStatType.UnequipDuration );
				animFeature.itemState = 4;
				animFeature.itemType = ( ( Int32 )( TDB.GetItemRecord( ItemID.GetTDBID( item ) ).ItemType().AnimFeatureIndex() ) );
				if( itemId != ItemID.None() )
				{
					animFeature.swappingWeapons = true;
				}
				scriptInterface.SetAnimationParameterFeature( mappedInstanceData.itemHandlingFeatureName, animFeature, scriptInterface.executionOwner );
				itemObject = scriptInterface.GetTransactionSystem().GetItemInSlot( scriptInterface.executionOwner, TDBID.Create( mappedInstanceData.attachmentSlot ) );
				scriptInterface.SetAnimationParameterFeature( 'equipUnequipItem', animFeature, itemObject );
				upperBodyState = scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.UpperBody );
				if( ( GetEquipAreaFromItemID( item ) == gamedataEquipmentArea.WeaponHeavy || ( ( ItemObject )( itemObject ) ).GetItemData().HasTag( 'DiscardOnEmpty' ) ) && ( upperBodyState != ( ( Int32 )( gamePSMUpperBodyStates.ForceEmptyHands ) ) ) )
				{
					DropActiveWeapon( scriptInterface, stateContext, stateMachineInstanceData );
				}
			}
		}
	}

}

