abstract class MeleeTransition extends DefaultTransition
{
	var m_stateNameString : String;

	protected export function OnAttach( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface )
	{
		m_stateNameString = NameToString( GetStateName() );
		UppercaseFirstChar( m_stateNameString );
	}

	public constexpr static function GetMeleeAttackCooldownName() : CName
	{
		return 'MeleeAttackCooldown';
	}

	public static function GetHoldEnterDuration( const scriptInterface : StateGameScriptInterface ) : Float
	{
		return scriptInterface.GetStatsSystem().GetStatValue( ( ( EntityID )( scriptInterface.ownerEntityID ) ), gamedataStatType.HoldEnterDuration );
	}

	protected const function IsBlockPressed( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return scriptInterface.IsActionJustPressed( 'MeleeBlock' );
	}

	protected const function IsBlockHeld( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return scriptInterface.GetActionValue( 'MeleeBlock' ) > 0.5;
	}

	public static function LightMeleeAttackPressed( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return scriptInterface.IsActionJustPressed( 'MeleeLightAttack' );
	}

	protected const function LightMeleeAttackReleased( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return scriptInterface.IsActionJustReleased( 'MeleeLightAttack' );
	}

	public static function MeleeAttackPressed( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return scriptInterface.IsActionJustPressed( 'MeleeAttack' );
	}

	public static function MeleeAttackReleased( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return scriptInterface.IsActionJustReleased( 'MeleeAttack' );
	}

	protected const function QuickMeleePressed( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return scriptInterface.IsActionJustPressed( 'QuickMelee' );
	}

	protected const function QuickMeleeHeld( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return scriptInterface.IsActionJustHeld( 'QuickMelee' );
	}

	protected const function QuickMeleeReleased( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return scriptInterface.IsActionJustReleased( 'QuickMelee' );
	}

	public static function StrongMeleeAttackPressed( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return scriptInterface.IsActionJustPressed( 'MeleeStrongAttack' );
	}

	public static function StrongMeleeAttackReleased( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return scriptInterface.IsActionJustReleased( 'MeleeStrongAttack' );
	}

	public static function AnyMeleeAttack( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( scriptInterface.GetActionValue( 'MeleeAttack' ) > 0.0 )
		{
			return true;
		}
		if( scriptInterface.GetActionValue( 'MeleeLightAttack' ) > 0.0 )
		{
			return true;
		}
		if( scriptInterface.GetActionValue( 'MeleeHeavyAttack' ) > 0.0 )
		{
			return true;
		}
		if( scriptInterface.GetActionValue( 'QuickMelee' ) > 0.0 )
		{
			return true;
		}
		return false;
	}

	public static function GetAimAssistMeleeRecord( const scriptInterface : StateGameScriptInterface ) : AimAssistMelee_Record
	{
		var aimAsisstRecordId : TweakDBID;
		var aimAssistRecord : AimAssistConfigPreset_Record;
		var record : AimAssistMelee_Record;
		aimAssistRecord = NULL;
		record = NULL;
		aimAsisstRecordId = scriptInterface.GetTargetingSystem().GetAimAssistConfig( scriptInterface.executionOwner );
		aimAssistRecord = TweakDBInterface.GetAimAssistConfigPresetRecord( aimAsisstRecordId );
		if( aimAssistRecord )
		{
			record = aimAssistRecord.MeleeParams();
		}
		return record;
	}

	public static function AnyMeleeAttackPressed( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return ( MeleeAttackPressed( scriptInterface ) || LightMeleeAttackPressed( scriptInterface ) ) || StrongMeleeAttackPressed( scriptInterface );
	}

	public static function NoMeleeAttack( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( scriptInterface.GetActionValue( 'MeleeAttack' ) > 0.0 )
		{
			return false;
		}
		if( scriptInterface.GetActionValue( 'MeleeLightAttack' ) > 0.0 )
		{
			return false;
		}
		if( scriptInterface.GetActionValue( 'MeleeStrongAttack' ) > 0.0 )
		{
			return false;
		}
		return true;
	}

	protected const function NoStrongAttackPressed( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( scriptInterface.GetActionValue( 'MeleeAttack' ) > 0.0 )
		{
			return false;
		}
		if( scriptInterface.GetActionValue( 'MeleeStrongAttack' ) > 0.0 )
		{
			return false;
		}
		return true;
	}

	protected const function ShouldHold( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface, optional skipDurationCheck : Bool, optional skipPressCount : Bool ) : Bool
	{
		if( stateContext.GetConditionBool( 'StrongMeleeAttackPressed' ) )
		{
			return true;
		}
		if( skipPressCount || CheckMeleeAttackPressCount( stateContext, scriptInterface ) )
		{
			if( scriptInterface.GetActionValue( 'MeleeStrongAttack' ) > 0.0 )
			{
				return true;
			}
			if( ( scriptInterface.GetActionValue( 'MeleeAttack' ) > 0.5 ) && ( skipDurationCheck || ( scriptInterface.GetActionStateTime( 'MeleeAttack' ) >= GetHoldEnterDuration( scriptInterface ) ) ) )
			{
				return true;
			}
		}
		return false;
	}

	public static function CheckMeleeAttackPressCount( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var actionPressCount : Uint32;
		var lastChargePressCount : StateResultInt;
		actionPressCount = scriptInterface.GetActionPressCount( 'MeleeAttack' );
		actionPressCount += scriptInterface.GetActionPressCount( 'MeleeLightAttack' );
		actionPressCount += scriptInterface.GetActionPressCount( 'MeleeStrongAttack' );
		lastChargePressCount = stateContext.GetPermanentIntParameter( 'LastMeleePressCount' );
		if( lastChargePressCount.valid && ( lastChargePressCount.value == ( ( Int32 )( actionPressCount ) ) ) )
		{
			return false;
		}
		return true;
	}

	protected function SetMeleeAttackPressCount( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var actionPressCount : Uint32;
		actionPressCount = scriptInterface.GetActionPressCount( 'MeleeAttack' );
		actionPressCount += scriptInterface.GetActionPressCount( 'MeleeLightAttack' );
		actionPressCount += scriptInterface.GetActionPressCount( 'MeleeStrongAttack' );
		stateContext.SetPermanentIntParameter( 'LastMeleePressCount', ( ( Int32 )( actionPressCount ) ), true );
	}

	protected function ClearMeleePressCount( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		stateContext.SetPermanentIntParameter( 'LastMeleePressCount', 0, true );
	}

	public static function WantsToStrongAttack( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsPlayingSyncedAnimation( scriptInterface ) )
		{
			return false;
		}
		if( stateContext.GetConditionBool( 'StrongMeleeAttackPressed' ) )
		{
			return true;
		}
		if( CheckMeleeAttackPressCount( stateContext, scriptInterface ) )
		{
			if( StrongMeleeAttackReleased( scriptInterface ) )
			{
				return true;
			}
			if( MeleeAttackReleased( scriptInterface ) && ( scriptInterface.GetActionPrevStateTime( 'MeleeAttack' ) > GetHoldEnterDuration( scriptInterface ) ) )
			{
				return true;
			}
		}
		return false;
	}

	public static function WantsToLightAttack( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsPlayingSyncedAnimation( scriptInterface ) )
		{
			return false;
		}
		if( stateContext.GetConditionBool( 'LightMeleeAttackPressed' ) )
		{
			return true;
		}
		if( CheckMeleeAttackPressCount( stateContext, scriptInterface ) )
		{
			if( MeleeAttackReleased( scriptInterface ) )
			{
				return true;
			}
			if( LightMeleeAttackPressed( scriptInterface ) )
			{
				return true;
			}
		}
		return false;
	}

	public static function IsThrownWeaponReloading( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( scriptInterface.GetStatPoolsSystem().HasStatPoolValueReachedMax( GetWeaponObject( scriptInterface ).GetEntityID(), gamedataStatPoolType.ThrowRecovery ) )
		{
			return false;
		}
		else
		{
			return true;
		}
	}

	protected const function ShouldInterruptHoldStates( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var interruptEvent : StateResultBool;
		if( !( IsWeaponReady( stateContext, scriptInterface ) ) )
		{
			return true;
		}
		if( IsAttackParried( stateContext, scriptInterface ) )
		{
			return true;
		}
		if( IsSafeStateForced( stateContext, scriptInterface ) )
		{
			return true;
		}
		if( ( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.Vision ) == ( ( Int32 )( gamePSMVision.Focus ) ) ) && !( IsInRpgContext( scriptInterface ) ) )
		{
			return true;
		}
		interruptEvent = stateContext.GetPermanentBoolParameter( 'InterruptMelee' );
		if( interruptEvent.value )
		{
			return true;
		}
		return false;
	}

	public static function UpdateMeleeInputBuffer( stateContext : StateContext, scriptInterface : StateGameScriptInterface, optional onlyLightMeleeAttack : Bool )
	{
		if( IsPlayingSyncedAnimation( scriptInterface ) )
		{
			ClearInputBuffer( stateContext );
			return;
		}
		if( onlyLightMeleeAttack )
		{
			if( WantsToLightAttack( stateContext, scriptInterface ) || WantsToStrongAttack( stateContext, scriptInterface ) )
			{
				stateContext.SetConditionBoolParameter( 'StrongMeleeAttackPressed', false, true );
				stateContext.SetConditionBoolParameter( 'LightMeleeAttackPressed', true, true );
			}
			return;
		}
		if( WantsToStrongAttack( stateContext, scriptInterface ) )
		{
			stateContext.SetConditionBoolParameter( 'StrongMeleeAttackPressed', true, true );
			stateContext.SetConditionBoolParameter( 'LightMeleeAttackPressed', false, true );
		}
		else if( WantsToLightAttack( stateContext, scriptInterface ) )
		{
			stateContext.SetConditionBoolParameter( 'StrongMeleeAttackPressed', false, true );
			stateContext.SetConditionBoolParameter( 'LightMeleeAttackPressed', true, true );
		}
	}

	public static function ClearInputBuffer( stateContext : StateContext )
	{
		stateContext.SetConditionBoolParameter( 'LightMeleeAttackPressed', false, true );
		stateContext.SetConditionBoolParameter( 'StrongMeleeAttackPressed', false, true );
	}

	protected const function EquipAttackCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsRightHandInUnequippingState( stateContext ) )
		{
			return false;
		}
		if( !( CheckItemType( scriptInterface, gamedataItemType.Wea_Katana ) ) )
		{
			return false;
		}
		if( scriptInterface.IsActionJustHeld( 'MeleeAttack' ) )
		{
			return true;
		}
		return false;
	}

	protected const function CheckItemType( const scriptInterface : StateGameScriptInterface, const itemType : gamedataItemType ) : Bool
	{
		var currentItemType : gamedataItemType;
		if( !( GetWeaponItemType( scriptInterface, GetWeaponObject( scriptInterface ), currentItemType ) ) || currentItemType != itemType )
		{
			return false;
		}
		return true;
	}

	public static function MeleeSprintStateCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.Melee ) == ( ( Int32 )( gamePSMMelee.Block ) ) )
		{
			return false;
		}
		if( !( stateContext.GetBoolParameter( 'canSprintWhileCharging', true ) ) && stateContext.GetStateMachineCurrentState( 'Melee' ) == 'meleeChargedHold' )
		{
			return false;
		}
		if( stateContext.GetBoolParameter( 'isAttacking', true ) )
		{
			return false;
		}
		if( !( HasMeleeWeaponEquipped( scriptInterface ) ) )
		{
			return true;
		}
		return true;
	}

	public static function MeleeUseExplorationCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.Melee ) == ( ( Int32 )( gamePSMMelee.Block ) ) )
		{
			return false;
		}
		if( stateContext.GetStateMachineCurrentState( 'Melee' ) == 'meleeChargedHold' )
		{
			return false;
		}
		if( stateContext.GetBoolParameter( 'isAttacking', true ) )
		{
			return false;
		}
		if( !( HasMeleeWeaponEquipped( scriptInterface ) ) )
		{
			return true;
		}
		return true;
	}

	protected function IncrementAttackNumber( scriptInterface : StateGameScriptInterface, stateContext : StateContext )
	{
		var currentValue : StateResultInt;
		var value : Int32;
		var attacksNumber : Int32;
		currentValue = stateContext.GetPermanentIntParameter( 'meleeAttackNumber' );
		value = currentValue.value;
		value += 1;
		attacksNumber = ( ( Int32 )( scriptInterface.GetStatsSystem().GetStatValue( ( ( EntityID )( scriptInterface.ownerEntityID ) ), gamedataStatType.AttacksNumber ) ) );
		if( value >= attacksNumber )
		{
			if( CheckIfInfiniteCombo( stateContext, scriptInterface ) )
			{
				value = 1;
			}
			else
			{
				value = 0;
			}
		}
		SetAttackNumber( stateContext, value );
	}

	protected function IncrementTotalComboAttackNumber( scriptInterface : StateGameScriptInterface, stateContext : StateContext )
	{
		var currentValue : StateResultInt;
		var value : Int32;
		currentValue = stateContext.GetPermanentIntParameter( 'totalMeleeAttacksInCombo' );
		value = currentValue.value;
		value += 1;
		stateContext.SetPermanentIntParameter( 'totalMeleeAttacksInCombo', value, true );
	}

	protected const function CheckIfFinalAttack( const scriptInterface : StateGameScriptInterface, const stateContext : StateContext ) : Bool
	{
		var currentValue : StateResultInt;
		var value : Int32;
		var attacksNumber : Int32;
		if( CheckIfInfiniteCombo( stateContext, scriptInterface ) )
		{
			return false;
		}
		currentValue = stateContext.GetPermanentIntParameter( 'meleeAttackNumber' );
		value = currentValue.value + 1;
		attacksNumber = ( ( Int32 )( scriptInterface.GetStatsSystem().GetStatValue( ( ( EntityID )( scriptInterface.ownerEntityID ) ), gamedataStatType.AttacksNumber ) ) );
		return value >= attacksNumber;
	}

	protected const function CheckIfInfiniteCombo( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( HasWeaponStatFlag( scriptInterface, gamedataStatType.CanWeaponInfinitlyCombo ) ) )
		{
			return false;
		}
		if( !( scriptInterface.HasStatFlag( gamedataStatType.CanMeleeInfinitelyCombo ) ) )
		{
			return false;
		}
		return true;
	}

	protected function ResetAttackNumber( stateContext : StateContext )
	{
		stateContext.SetPermanentIntParameter( 'meleeAttackNumber', 0, true );
		stateContext.SetPermanentIntParameter( 'totalMeleeAttacksInCombo', 0, true );
	}

	protected function SetAttackNumber( stateContext : StateContext, value : Int32 )
	{
		stateContext.SetPermanentIntParameter( 'meleeAttackNumber', value, true );
	}

	protected function SetCanSprintWhileCharging( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'canSprintWhileCharging', value, true );
	}

	protected function SetIsAttacking( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'isAttacking', value, true );
	}

	protected function SetIsBlocking( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'isBlocking', value, true );
	}

	protected function SetIsParried( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'isParried', value, true );
	}

	protected function SetIsThrowReloading( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'isThrowReloading', value, true );
	}

	protected function SetThrowReloadTime( stateContext : StateContext, value : Float )
	{
		stateContext.SetPermanentFloatParameter( 'throwReloadTime', value, true );
	}

	protected function SetIsTargeting( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'isTargeting', value, true );
	}

	protected function SetIsHolding( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'isHolding', value, true );
	}

	protected function SetIsSafe( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'isSafe', value, true );
	}

	protected const function ApplyThrowAttackGameplayRestrictions( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface )
	{
		StatusEffectHelper.ApplyStatusEffect( scriptInterface.executionOwner, T"GameplayRestriction.NoRadialMenus" );
		StatusEffectHelper.ApplyStatusEffect( scriptInterface.executionOwner, T"GameplayRestriction.FirearmsNoUnequipNoSwitch" );
	}

	protected const function RemoveAllMeleeGameplayRestrictions( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface )
	{
		RemoveThrowAttackGameplayRestrictions( stateContext, scriptInterface );
	}

	protected const function RemoveThrowAttackGameplayRestrictions( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface )
	{
		StatusEffectHelper.RemoveStatusEffect( scriptInterface.executionOwner, T"GameplayRestriction.NoRadialMenus" );
		StatusEffectHelper.RemoveStatusEffect( scriptInterface.executionOwner, T"GameplayRestriction.FirearmsNoUnequipNoSwitch" );
	}

	protected const function IsWeaponReady( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var isTakedown : Bool;
		var isInFocusMode : Bool;
		var isUsingCombatGadget : Bool;
		isTakedown = ( ( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.Takedown ) == ( ( Int32 )( gamePSMTakedown.Grapple ) ) ) || ( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.Takedown ) == ( ( Int32 )( gamePSMTakedown.Leap ) ) ) ) || ( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.Takedown ) == ( ( Int32 )( gamePSMTakedown.Takedown ) ) );
		isInFocusMode = scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.Vision ) == ( ( Int32 )( gamePSMVision.Focus ) );
		isUsingCombatGadget = stateContext.IsStateMachineActive( 'CombatGadget' );
		if( IsNoCombatActionsForced( scriptInterface ) )
		{
			return false;
		}
		if( stateContext.IsStateMachineActive( 'Consumable' ) || stateContext.IsStateMachineActive( 'CombatGadget' ) )
		{
			return false;
		}
		if( StatusEffectSystem.ObjectHasStatusEffectOfType( scriptInterface.executionOwner, gamedataStatusEffectType.Stunned ) )
		{
			return false;
		}
		if( !( IsRightHandInEquippedState( stateContext ) ) )
		{
			return false;
		}
		if( IsPlayingSyncedAnimation( scriptInterface ) )
		{
			return false;
		}
		if( isInFocusMode && !( IsInRpgContext( scriptInterface ) ) )
		{
			return false;
		}
		if( isUsingCombatGadget )
		{
			return false;
		}
		if( isTakedown )
		{
			return false;
		}
		return true;
	}

	protected const function HasWeaponStatFlag( const scriptInterface : StateGameScriptInterface, flag : gamedataStatType ) : Bool
	{
		var flagOn : Bool;
		flagOn = scriptInterface.GetStatsSystem().GetStatBoolValue( scriptInterface.ownerEntityID, flag );
		return flagOn;
	}

	protected function DrawDebugText( scriptInterface : StateGameScriptInterface, out textLayerId : Uint32, text : String )
	{
		textLayerId = GameInstance.GetDebugVisualizerSystem( scriptInterface.GetGame() ).DrawText( Vector4( 500.0, 550.0, 0.0, 0.0 ), text, gameDebugViewETextAlignment.Left, Color( 255, 255, 0, 255 ) );
		GameInstance.GetDebugVisualizerSystem( scriptInterface.GetGame() ).SetScale( textLayerId, Vector4( 1.0, 1.0, 0.0, 0.0 ) );
	}

	protected function ClearDebugText( scriptInterface : StateGameScriptInterface, textLayerId : Uint32 )
	{
		GameInstance.GetDebugVisualizerSystem( scriptInterface.GetGame() ).ClearLayer( textLayerId );
	}

	protected function GetPerfectAimSnapParams() : AimRequest
	{
		var aimSnapParams : AimRequest;
		aimSnapParams.duration = 0.33000001;
		aimSnapParams.adjustPitch = true;
		aimSnapParams.adjustYaw = true;
		aimSnapParams.endOnAimingStopped = true;
		aimSnapParams.precision = 0.1;
		aimSnapParams.easeIn = true;
		aimSnapParams.easeOut = true;
		aimSnapParams.checkRange = true;
		aimSnapParams.processAsInput = true;
		aimSnapParams.bodyPartsTracking = true;
		aimSnapParams.bptMaxDot = 0.5;
		aimSnapParams.bptMaxSwitches = -1.0;
		aimSnapParams.bptMinInputMag = 0.5;
		aimSnapParams.bptMinResetInputMag = 0.1;
		return aimSnapParams;
	}

	protected function GetBlockLookAtParams() : AimRequest
	{
		var aimSnapParams : AimRequest;
		aimSnapParams.duration = 30.0;
		aimSnapParams.adjustPitch = true;
		aimSnapParams.adjustYaw = true;
		aimSnapParams.endOnAimingStopped = false;
		aimSnapParams.precision = 0.1;
		aimSnapParams.easeIn = true;
		aimSnapParams.easeOut = true;
		aimSnapParams.checkRange = true;
		aimSnapParams.processAsInput = true;
		aimSnapParams.bodyPartsTracking = false;
		aimSnapParams.bptMaxDot = 0.5;
		aimSnapParams.bptMaxSwitches = -1.0;
		aimSnapParams.bptMinInputMag = 0.5;
		aimSnapParams.bptMinResetInputMag = 0.1;
		return aimSnapParams;
	}

	protected function SendAnimFeatureData( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var animFeature : AnimFeature_MeleeData;
		var weaponObject : WeaponObject;
		animFeature = new AnimFeature_MeleeData;
		animFeature.attackType = stateContext.GetIntParameter( 'attackType', true );
		animFeature.attackNumber = stateContext.GetIntParameter( 'meleeAttackNumber', true );
		animFeature.attackSpeed = stateContext.GetFloatParameter( 'attackSpeed', true );
		animFeature.hasDeflectAnim = stateContext.GetBoolParameter( 'hasDeflectAnim', true );
		animFeature.hasHitAnim = stateContext.GetBoolParameter( 'hasHitAnim', true );
		weaponObject = GetWeaponObject( scriptInterface );
		animFeature.isAttacking = stateContext.GetBoolParameter( 'isAttacking', true );
		animFeature.isTargeting = stateContext.GetBoolParameter( 'isTargeting', true );
		animFeature.isBlocking = stateContext.GetBoolParameter( 'isBlocking', true );
		animFeature.isParried = stateContext.GetBoolParameter( 'isParried', true );
		animFeature.isHolding = stateContext.GetBoolParameter( 'isHolding', true );
		animFeature.shouldHandsDisappear = weaponObject.HasTag( 'Cyberware' );
		animFeature.keepRenderPlane = weaponObject.HasTag( 'KeepRenderPlane' );
		animFeature.isSafe = stateContext.GetBoolParameter( 'isSafe', true );
		animFeature.isThrowReloading = stateContext.GetBoolParameter( 'isThrowReloading', true );
		animFeature.throwReloadTime = stateContext.GetFloatParameter( 'throwReloadTime', true );
		animFeature.isMeleeWeaponEquipped = true;
		scriptInterface.SetAnimationParameterFeature( 'MeleeData', animFeature );
	}

	protected function DisableNanoWireIK( scriptInterface : StateGameScriptInterface )
	{
		UpdateNanoWireEndPositionAnimFeature( scriptInterface, 'ikRightNanoWire', false );
		UpdateNanoWireEndPositionAnimFeature( scriptInterface, 'ikLeftNanoWire', false );
	}

	protected function UpdateNanoWireEndPositionAnimFeature( scriptInterface : StateGameScriptInterface, animFeatureName : CName, enable : Bool, optional setPosition : Bool, optional slotPosition : Vector4 )
	{
		var animFeature : AnimFeature_SimpleIkSystem;
		animFeature = new AnimFeature_SimpleIkSystem;
		animFeature.isEnable = enable;
		animFeature.setPosition = setPosition;
		animFeature.position = slotPosition;
		scriptInterface.SetAnimationParameterFeature( animFeatureName, animFeature );
	}

	protected function GetMeleeMovementDirection( stateContext : StateContext, scriptInterface : StateGameScriptInterface ) : meleeMoveDirection
	{
		var direction : meleeMoveDirection;
		var currentYaw : Float;
		currentYaw = GetYawMovementDirection( stateContext, scriptInterface );
		if( ( currentYaw >= -45.0 ) && ( currentYaw <= 45.0 ) )
		{
			direction = meleeMoveDirection.Forward;
		}
		else if( ( currentYaw > 45.0 ) && ( currentYaw < 135.0 ) )
		{
			direction = meleeMoveDirection.Right;
		}
		else if( ( ( currentYaw >= 135.0 ) && ( currentYaw <= 180.0 ) ) || ( ( currentYaw <= -135.0 ) && ( currentYaw >= -180.0 ) ) )
		{
			direction = meleeMoveDirection.Back;
		}
		else if( ( currentYaw > -135.0 ) && ( currentYaw < -45.0 ) )
		{
			direction = meleeMoveDirection.Left;
		}
		return direction;
	}

	public static function GetWeaponObject( const scriptInterface : StateGameScriptInterface ) : WeaponObject
	{
		var owner : GameObject;
		var weapon : WeaponObject;
		owner = scriptInterface.owner;
		weapon = ( ( WeaponObject )( owner ) );
		return weapon;
	}

	public static function CanThrowWeaponObject( const owner : GameObject, const weapon : WeaponObject ) : Bool
	{
		if( !( RPGManager.HasStatFlag( weapon, gamedataStatType.HasMeleeTargeting ) ) )
		{
			return false;
		}
		if( weapon.WeaponHasTag( 'Throwable' ) && !( RPGManager.HasStatFlag( owner, gamedataStatType.CanThrowWeapon ) ) )
		{
			return false;
		}
		return true;
	}

	protected const function GetAttackDataFromCurrentState( stateContext : StateContext, scriptInterface : StateGameScriptInterface, attackNumber : Int32, out outgoingStruct : MeleeAttackData ) : Bool
	{
		var recordID : TweakDBID;
		var ownerID : EntityID;
		var statsSystem : StatsSystem;
		var attackSpeed : Float;
		var attackSpeedMult : Float;
		var staminaCostMods : array< weak< StatModifier_Record > >;
		var effectToPlay : CName;
		var attackRecord : weak< Attack_Melee_Record >;
		if( !( GetAttackRecord( scriptInterface, attackNumber, attackRecord ) ) )
		{
			return false;
		}
		recordID = attackRecord.GetID();
		if( !( TDBID.IsValid( recordID ) ) )
		{
			return false;
		}
		attackSpeedMult = 1.0;
		ownerID = scriptInterface.ownerEntityID;
		statsSystem = scriptInterface.GetStatsSystem();
		if( attackRecord.DontScaleWithAttackSpeed() )
		{
			attackSpeed = 1.0;
		}
		else
		{
			attackSpeed = statsSystem.GetStatValue( scriptInterface.ownerEntityID, gamedataStatType.AttackSpeed );
			if( scriptInterface.HasStatFlag( gamedataStatType.CanMeleeBerserk ) )
			{
				attackSpeedMult *= LerpF( ( ( Float )( stateContext.GetIntParameter( 'totalMeleeAttacksInCombo', true ) ) ) / ( ( Float )( GetStaticIntParameterDefault( "maxBerserkASAttack", 1 ) ) ), 1.0, GetStaticFloatParameterDefault( "maxBerserkAS", 1.0 ), true );
			}
			if( IsPlayerExhausted( scriptInterface ) )
			{
				attackSpeedMult *= GetStaticFloatParameterDefault( "lowStaminaAttackSpeedMult", 0.60000002 );
			}
			attackSpeed *= attackSpeedMult;
		}
		attackRecord.StaminaCost( staminaCostMods );
		outgoingStruct = scriptInterface.GetMeleeAttackData( attackRecord, RPGManager.CalculateStatModifiers( staminaCostMods, scriptInterface.GetGame(), scriptInterface.owner, ownerID ), attackSpeed );
		GetWeaponObject( scriptInterface ).SetAttack( recordID );
		stateContext.SetPermanentFloatParameter( 'idleTransitionTime', outgoingStruct.idleTransitionTime, true );
		stateContext.SetPermanentFloatParameter( 'attackSpeed', attackSpeed, true );
		effectToPlay = attackRecord.VfxName();
		GameObjectEffectHelper.StartEffectEvent( scriptInterface.owner, effectToPlay, false );
		return true;
	}

	protected const function HasAttackRecord( const scriptInterface : StateGameScriptInterface, optional const attackNumber : Int32 ) : Bool
	{
		var attackRecord : weak< Attack_Melee_Record >;
		if( GetAttackRecord( scriptInterface, attackNumber, attackRecord ) )
		{
			return true;
		}
		return false;
	}

	protected const function GetAttackRecord( const scriptInterface : StateGameScriptInterface, const attackNumber : Int32, out attackRecord : weak< Attack_Melee_Record > ) : Bool
	{
		attackRecord = ( ( Attack_Melee_Record )( GetWeaponObject( scriptInterface ).GetAttack( StringToName( m_stateNameString + IntToString( attackNumber ) ) ).GetRecord() ) );
		return attackRecord != NULL;
	}

	public function SpawnMeleeWeaponProjectile( scriptInterface : StateGameScriptInterface )
	{
		var transactionSystem : TransactionSystem;
		var itemObj : ItemObject;
		var projectileTemplateName : CName;
		var appearanceName : CName;
		var isItemKnife : Bool;
		var useAppearance : Bool;
		var weaponObj : WeaponObject;
		transactionSystem = scriptInterface.GetTransactionSystem();
		itemObj = transactionSystem.GetItemInSlot( scriptInterface.executionOwner, T"AttachmentSlots.WeaponRight" );
		weaponObj = GetWeaponObject( scriptInterface );
		isItemKnife = CheckItemType( scriptInterface, gamedataItemType.Wea_Knife );
		if( isItemKnife )
		{
			useAppearance = weaponObj.GetBoolPropertyFromWeaponDefinition( T".useProjectileAppearance" );
			if( useAppearance )
			{
				appearanceName = weaponObj.GetAppearanceNameFromComponent( 'Grip' );
			}
		}
		projectileTemplateName = weaponObj.GetNamePropertyFromWeaponDefinition( T".projectileTemplateName" );
		if( itemObj && IsNameValid( projectileTemplateName ) )
		{
			ProjectileLaunchHelper.SpawnProjectileFromScreenCenter( scriptInterface.executionOwner, projectileTemplateName, appearanceName, itemObj );
		}
	}

	protected const function GetMeleeWeaponFriendlyName( scriptInterface : StateGameScriptInterface ) : CName
	{
		return StringToName( TweakDBInterface.GetItemRecord( ItemID.GetTDBID( GetWeaponObject( scriptInterface ).GetItemID() ) ).FriendlyName() );
	}

	public static function IsPlayingSyncedAnimation( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( scriptInterface.GetWorkspotSystem().IsActorInWorkspot( scriptInterface.executionOwner ) && !( scriptInterface.localBlackboard.GetBool( GetAllBlackboardDefs().PlayerStateMachine.MountedToVehicle ) ) )
		{
			return true;
		}
		return false;
	}

	protected function AdjustAttackPosition( scriptInterface : StateGameScriptInterface, stateContext : StateContext, attackData : MeleeAttackData ) : Bool
	{
		var impulseVector : Vector4;
		var adjustPosition : Vector4;
		if( !( attackData.useAdjustmentInsteadOfImpulse ) )
		{
			return false;
		}
		impulseVector = AddCameraSpaceImpulse( scriptInterface, stateContext, attackData );
		impulseVector += AddForwardImpulse( scriptInterface, stateContext, attackData );
		impulseVector += AddUpImpulse( scriptInterface, stateContext, attackData );
		adjustPosition = scriptInterface.executionOwner.GetWorldPosition() + impulseVector;
		RequestPlayerPositionAdjustment( stateContext, scriptInterface, NULL, attackData.attackEffectDelay, 0.89999998, -1.0, adjustPosition, false );
		return true;
	}

	protected function AddAttackImpulse( scriptInterface : StateGameScriptInterface, stateContext : StateContext, attackData : MeleeAttackData )
	{
		var impulseEvent : PSMImpulse;
		var impulseVector : Vector4;
		var targetTooCloseRange : Float;
		targetTooCloseRange = 5.0;
		if( ( attackData.forwardImpulse > 0.0 ) || ( attackData.cameraSpaceImpulse > 0.0 ) )
		{
			if( GetTargetObject( scriptInterface, targetTooCloseRange ) )
			{
				return;
			}
		}
		impulseVector = AddCameraSpaceImpulse( scriptInterface, stateContext, attackData );
		impulseVector += AddForwardImpulse( scriptInterface, stateContext, attackData );
		impulseVector += AddUpImpulse( scriptInterface, stateContext, attackData );
		impulseEvent = new PSMImpulse;
		impulseEvent.id = 'impulse';
		impulseEvent.impulse = impulseVector;
		scriptInterface.executionOwner.QueueEvent( impulseEvent );
	}

	protected function AddCameraSpaceImpulse( scriptInterface : StateGameScriptInterface, stateContext : StateContext, attackData : MeleeAttackData ) : Vector4
	{
		var impulseVector : Vector4;
		var impulseValue : Float;
		var cameraWorldTransform : Transform;
		if( attackData.cameraSpaceImpulse == 0.0 )
		{
			return Vector4.EmptyVector();
		}
		impulseValue = attackData.cameraSpaceImpulse;
		if( !( scriptInterface.IsOnGround() ) )
		{
			impulseValue *= GetStaticFloatParameterDefault( "inAirImpulseMultiplier", 1.0 );
		}
		cameraWorldTransform = scriptInterface.GetCameraWorldTransform();
		impulseVector = Transform.GetForward( cameraWorldTransform );
		impulseVector = impulseVector * impulseValue;
		return impulseVector;
	}

	protected function AddForwardImpulse( scriptInterface : StateGameScriptInterface, stateContext : StateContext, attackData : MeleeAttackData ) : Vector4
	{
		var impulseVector : Vector4;
		var impulseValue : Float;
		if( attackData.forwardImpulse == 0.0 )
		{
			return Vector4.EmptyVector();
		}
		impulseValue = attackData.forwardImpulse;
		if( !( scriptInterface.IsOnGround() ) )
		{
			impulseValue *= GetStaticFloatParameterDefault( "inAirImpulseMultiplier", 1.0 );
		}
		impulseVector = scriptInterface.executionOwner.GetWorldForward();
		impulseVector = impulseVector * impulseValue;
		return impulseVector;
	}

	protected function AddUpImpulse( scriptInterface : StateGameScriptInterface, stateContext : StateContext, attackData : MeleeAttackData ) : Vector4
	{
		var impulseVector : Vector4;
		var impulseValue : Float;
		if( attackData.upImpulse == 0.0 )
		{
			return Vector4.EmptyVector();
		}
		impulseValue = attackData.upImpulse;
		if( !( scriptInterface.IsOnGround() ) )
		{
			impulseValue *= GetStaticFloatParameterDefault( "inAirImpulseMultiplier", 1.0 );
		}
		impulseVector = scriptInterface.executionOwner.GetWorldUp();
		impulseVector = impulseVector * impulseValue;
		return impulseVector;
	}

	protected function GetMovementInput( scriptInterface : StateGameScriptInterface ) : Float
	{
		var x : Float;
		var y : Float;
		var res : Float;
		x = scriptInterface.GetActionValue( 'MoveX' );
		y = scriptInterface.GetActionValue( 'MoveY' );
		res = SqrtF( SqrF( x ) + SqrF( y ) );
		return res;
	}

	protected function IsPlayerInputDirectedForward( scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( AbsF( scriptInterface.GetInputHeading() ) < 45.0 )
		{
			return true;
		}
		return false;
	}

	protected const function GetNanoWireTargetObject( const scriptInterface : StateGameScriptInterface ) : GameObject
	{
		var targetingSystem : TargetingSystem;
		var targetObject : GameObject;
		var angleOut : EulerAngles;
		var wireAttackRange : Float;
		targetingSystem = scriptInterface.GetTargetingSystem();
		targetObject = targetingSystem.GetObjectClosestToCrosshair( scriptInterface.executionOwner, angleOut, TSQ_NPC() );
		wireAttackRange = scriptInterface.GetStatsSystem().GetStatValue( ( ( EntityID )( scriptInterface.ownerEntityID ) ), gamedataStatType.Range );
		wireAttackRange *= 2.0;
		if( ( targetObject.IsPuppet() && ScriptedPuppet.IsActive( targetObject ) ) && ( GameObject.GetAttitudeTowards( targetObject, scriptInterface.executionOwner ) == EAIAttitude.AIA_Neutral || GameObject.GetAttitudeTowards( targetObject, scriptInterface.executionOwner ) == EAIAttitude.AIA_Hostile ) )
		{
			if( ( wireAttackRange <= 0.0 ) || ( Vector4.Distance( scriptInterface.executionOwner.GetWorldPosition(), targetObject.GetWorldPosition() ) <= wireAttackRange ) )
			{
				return targetObject;
			}
		}
		return NULL;
	}

	protected function IsTargetAPuppet( scriptInterface : StateGameScriptInterface ) : Bool
	{
		return GetTargetObject( scriptInterface ).IsPuppet();
	}

	protected function IsTargetOfficer( scriptInterface : StateGameScriptInterface, object : weak< GameObject > ) : Bool
	{
		var isOfficer : Bool;
		var puppet : NPCPuppet;
		puppet = ( ( NPCPuppet )( object ) );
		isOfficer = TweakDBInterface.GetCharacterRecord( puppet.GetRecordID() ).Rarity().Type() == gamedataNPCRarity.Officer;
		return isOfficer;
	}

	protected const function IsAttackParried( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return scriptInterface.GetStatusEffectSystem().HasStatusEffect( scriptInterface.executionOwnerEntityID, T"BaseStatusEffect.Parry" );
	}

	protected const function HasMeleeTargeting( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return HasWeaponStatFlag( scriptInterface, gamedataStatType.HasMeleeTargeting );
	}

	protected const function CanWeaponBlock( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return HasWeaponStatFlag( scriptInterface, gamedataStatType.CanWeaponBlock );
	}

	protected const function CanWeaponDeflect( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return HasWeaponStatFlag( scriptInterface, gamedataStatType.CanWeaponDeflect );
	}

	protected const function CanThrowWeapon( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return scriptInterface.HasStatFlag( gamedataStatType.CanThrowWeapon );
	}

	protected function ResetFlags( stateContext : StateContext )
	{
		SetIsBlocking( stateContext, false );
		SetIsTargeting( stateContext, false );
		SetIsAttacking( stateContext, false );
		SetIsHolding( stateContext, false );
		SetIsParried( stateContext, false );
		SetIsSafe( stateContext, false );
		SetIsThrowReloading( stateContext, false );
	}

}

abstract class MeleeEventsTransition extends MeleeTransition
{

	public virtual function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		SendAnimFeatureData( stateContext, scriptInterface );
	}

	public export virtual function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		SendAnimFeatureData( stateContext, scriptInterface );
		ToggleWireVisualEffect( stateContext, scriptInterface, 'monowire_idle', false );
	}

	public export virtual function OnUpdate( timeDelta : Float, stateContext : StateContext, scriptInterface : StateGameScriptInterface ) {}

	public export virtual function OnForcedExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var animFeature : AnimFeature_MeleeData;
		animFeature = new AnimFeature_MeleeData;
		scriptInterface.SetAnimationParameterFeature( 'MeleeData', animFeature );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Melee, ( ( Int32 )( gamePSMMelee.Default ) ) );
		ResetFlags( stateContext );
		ToggleWireVisualEffect( stateContext, scriptInterface, 'monowire_idle', false );
		RemoveAllMeleeGameplayRestrictions( stateContext, scriptInterface );
		MeleeTransitionRemoveTriggerEffects( GameInstance.GetAudioSystem( scriptInterface.owner.GetGame() ) );
	}

	protected function ToggleWireVisualEffect( stateContext : StateContext, scriptInterface : StateGameScriptInterface, effectName : CName, b : Bool )
	{
		if( GetMeleeWeaponFriendlyName( scriptInterface ) == 'mono_wires' )
		{
			if( b == true )
			{
				GameObjectEffectHelper.StartEffectEvent( scriptInterface.owner, effectName );
			}
			else
			{
				GameObjectEffectHelper.StopEffectEvent( scriptInterface.owner, effectName );
			}
		}
	}

	protected function MeleeTransitionRemoveTriggerEffects( audioSystem : AudioSystem )
	{
		audioSystem.RemoveTriggerEffect( 'PSM_MeleeTargetingOnEnter_trigger' );
		audioSystem.RemoveTriggerEffect( 'PSM_MeleeReloadOnEnter_feedback' );
		audioSystem.RemoveTriggerEffect( 'PSM_MeleeAttackGeneric' );
	}

}

import class MeleeAttackData extends IScriptable
{
	import var attackName : CName;
	import var attackSpeed : Float;
	import var attackWindowOpen : Float;
	import var attackWindowClosed : Float;
	import var idleTransitionTime : Float;
	import var holdTransitionTime : Float;
	import var blockTransitionTime : Float;
	import var attackEffectDirection : CName;
	import var attackEffectDuration : Float;
	import var attackEffectDelay : Float;
	import var impactFxSlot : CName;
	import var impulseDelay : Float;
	import var cameraSpaceImpulse : Float;
	import var forwardImpulse : Float;
	import var upImpulse : Float;
	import var useAdjustmentInsteadOfImpulse : Bool;
	import var enableAdjustingPlayerPositionToTarget : Bool;
	import var startPosition : Vector4;
	import var endPosition : Vector4;
	import var staminaCost : Float;
	import var weaponChargeCost : Float;
	import var hasDeflectAnim : Bool;
	import var hasHitAnim : Bool;
	import var trailStartDelay : Float;
	import var trailStopDelay : Float;
	import var trailAttackSide : String;
	import var incrementsCombo : Bool;
	import var startupDuration : Float;
	import var activeDuration : Float;
	import var recoverDuration : Float;
	import var activeHitDuration : Float;
	import var recoverHitDuration : Float;
	import var standUpDelay : Float;
	import var ikOffset : Vector3;
}

class MeleeNotReadyDecisions extends MeleeTransition
{

	protected export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return !( IsWeaponReady( stateContext, scriptInterface ) );
	}

	protected export const function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( EquipAttackCondition( stateContext, scriptInterface ) )
		{
			return true;
		}
		return IsWeaponReady( stateContext, scriptInterface );
	}

}

class MeleeNotReadyEvents extends MeleeEventsTransition
{

	public export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var weapon : weak< WeaponObject >;
		weapon = ( ( WeaponObject )( scriptInterface.owner ) );
		ResetFlags( stateContext );
		ResetAttackNumber( stateContext );
		scriptInterface.PushAnimationEvent( 'MeleeNotReady' );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.NotReady ) ) );
		stateContext.RemovePermanentFloatParameter( 'meleeRecoveryDuration' );
		TutorialSetFact( scriptInterface, 'melee_combat_tutorial' );
		CheckThrowingKnifeCooldown( stateContext, scriptInterface );
		GameInstance.GetAudioSystem( scriptInterface.owner.GetGame() ).AddTriggerEffect( weapon.GetTriggerEffectName(), 'PSM_MeleeAttackGeneric' );
		if( StatusEffectSystem.ObjectHasStatusEffect( scriptInterface.executionOwner, PlayerStaminaHelpers.GetExhaustedStatusEffectID() ) )
		{
			GameInstance.GetAudioSystem( scriptInterface.owner.GetGame() ).ReplaceTriggerEffect( 'te_wea_melee_swing_exhausted', 'PSM_MeleeAttackGeneric', false );
		}
		super.OnEnter( stateContext, scriptInterface );
	}

	public export override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		super.OnExit( stateContext, scriptInterface );
	}

	protected function CheckThrowingKnifeCooldown( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		if( !( GetWeaponObject( scriptInterface ).WeaponHasTag( 'Throwable' ) ) )
		{
			return;
		}
		if( IsThrownWeaponReloading( stateContext, scriptInterface ) )
		{
			SetIsThrowReloading( stateContext, true );
		}
	}

}

class MeleeParriedDecisions extends MeleeTransition
{

	protected export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return IsAttackParried( stateContext, scriptInterface );
	}

	protected const function ToMeleeIdle( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return !( IsAttackParried( stateContext, scriptInterface ) );
	}

	protected const function ToMeleeDeflect( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return IsBlockPressed( stateContext, scriptInterface );
	}

}

class MeleeParriedEvents extends MeleeEventsTransition
{

	public override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		ClearInputBuffer( stateContext );
		ResetFlags( stateContext );
		ResetAttackNumber( stateContext );
		scriptInterface.PushAnimationEvent( 'MeleeParried' );
		SetIsParried( stateContext, true );
		PlayRumble( scriptInterface, "heavy_fast" );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.Parried ) ) );
		stateContext.RemovePermanentFloatParameter( 'meleeRecoveryDuration' );
		super.OnEnter( stateContext, scriptInterface );
	}

	public override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		SetIsParried( stateContext, false );
		super.OnExit( stateContext, scriptInterface );
	}

}

class MeleeRecoveryDecisions extends MeleeTransition
{

	protected export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var paramResult : StateResultFloat;
		paramResult = stateContext.GetPermanentFloatParameter( 'meleeRecoveryDuration' );
		if( paramResult.valid )
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	protected const function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var paramResult : StateResultFloat;
		paramResult = stateContext.GetPermanentFloatParameter( 'meleeRecoveryDuration' );
		return GetInStateTime() >= paramResult.value;
	}

}

class MeleeRecoveryEvents extends MeleeNotReadyEvents
{

	public override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		stateContext.RemovePermanentFloatParameter( 'meleeRecoveryDuration' );
	}

	public override function OnForcedExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		stateContext.RemovePermanentFloatParameter( 'meleeRecoveryDuration' );
	}

}

class MeleeIdleDecisions extends MeleeTransition
{

	protected export const function ToMeleePublicSafe( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.Combat ) == ( ( Int32 )( gamePSMCombat.InCombat ) ) )
		{
			return false;
		}
		if( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.Zones ) == ( ( Int32 )( gamePSMZones.Dangerous ) ) )
		{
			return false;
		}
		if( StatusEffectSystem.ObjectHasStatusEffectWithTag( scriptInterface.executionOwner, 'Fists' ) )
		{
			return false;
		}
		if( stateContext.GetBoolParameter( 'InPublicZone', true ) )
		{
			if( GetInStateTime() > GetStaticFloatParameterDefault( "safeTransition", 1.0 ) )
			{
				return true;
			}
			return false;
		}
		return false;
	}

	protected export const function ToMeleeHold( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( ShouldHold( stateContext, scriptInterface, true ) )
		{
			return true;
		}
		return false;
	}

}

abstract class MeleeRumblingEvents extends MeleeEventsTransition
{

	public virtual function GetIntensity() : String
	{
		return "light";
	}

	public export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var itemTags : array< CName >;
		var itemRecord : weak< Item_Record >;
		var weaponItem : ItemID;
		var hasRumblingWeaponTag : Bool;
		weaponItem = EquipmentSystem.GetData( GameInstance.GetPlayerSystem( scriptInterface.owner.GetGame() ).GetLocalPlayerMainGameObject() ).GetActiveItem( gamedataEquipmentArea.Weapon );
		itemRecord = RPGManager.GetItemRecord( weaponItem );
		itemTags = itemRecord.Tags();
		hasRumblingWeaponTag = itemTags.Contains( 'MeleeRumblingWeapon' );
		if( hasRumblingWeaponTag )
		{
			PlayRumbleLoop( scriptInterface, GetIntensity() );
		}
		super.OnEnter( stateContext, scriptInterface );
	}

	public export override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		StopRumbleLoop( scriptInterface, GetIntensity() );
		super.OnExit( stateContext, scriptInterface );
	}

	public export override function OnForcedExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		StopRumbleLoop( scriptInterface, GetIntensity() );
		super.OnExit( stateContext, scriptInterface );
	}

}

class MeleeIdleEvents extends MeleeRumblingEvents
{

	public export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		ResetFlags( stateContext );
		ResetAttackNumber( stateContext );
		ClearMeleePressCount( stateContext, scriptInterface );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Melee, ( ( Int32 )( gamePSMMelee.Default ) ) );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.Idle ) ) );
		stateContext.SetPermanentBoolParameter( 'isSafe', false, true );
		SetFlags( stateContext );
		ToggleWireVisualEffect( stateContext, scriptInterface, 'monowire_idle', true );
		GameInstance.GetAudioSystem( scriptInterface.owner.GetGame() ).RemoveTriggerEffect( 'PSM_MeleeTargetingOnEnter_trigger' );
		super.OnEnter( stateContext, scriptInterface );
	}

	protected virtual function SetFlags( stateContext : StateContext ) {}
}

class MeleePublicSafeDecisions extends MeleeTransition
{

	protected const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.Combat ) == ( ( Int32 )( gamePSMCombat.InCombat ) ) )
		{
			return false;
		}
		if( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.Zones ) == ( ( Int32 )( gamePSMZones.Dangerous ) ) )
		{
			return false;
		}
		if( stateContext.IsStateActive( 'Locomotion', 'sprint' ) )
		{
			return false;
		}
		if( StatusEffectSystem.ObjectHasStatusEffectWithTag( scriptInterface.executionOwner, 'Fists' ) )
		{
			return false;
		}
		return false;
	}

	protected export const function ToMeleeIdle( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( stateContext.IsStateActive( 'Locomotion', 'sprint' ) )
		{
			return true;
		}
		if( scriptInterface.IsActionJustPressed( 'Reload' ) )
		{
			return true;
		}
		if( StatusEffectSystem.ObjectHasStatusEffectWithTag( scriptInterface.executionOwner, 'Fists' ) )
		{
			return true;
		}
		return false;
	}

}

class MeleePublicSafeEvents extends MeleeRumblingEvents
{
	var m_unequipTime : Float;

	public export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		ResetFlags( stateContext );
		ResetAttackNumber( stateContext );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Melee, ( ( Int32 )( gamePSMMelee.Default ) ) );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.PublicSafe ) ) );
		SetIsSafe( stateContext, true );
		if( GetWeaponItemTag( stateContext, scriptInterface, 'Meleeware' ) )
		{
			m_unequipTime = GetStaticFloatParameterDefault( "timeToUnequipMeleeware", 15.0 );
		}
		else if( stateContext.GetBoolParameter( 'InPublicZone', true ) )
		{
			m_unequipTime = GetStaticFloatParameterDefault( "timeToAutoUnequipWeapon", 15.0 );
		}
		else
		{
			m_unequipTime = -1.0;
		}
		super.OnEnter( stateContext, scriptInterface );
	}

	protected function OnTick( timeDelta : Float, stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		if( ( m_unequipTime > 0.0 ) && ( GetInStateTime() >= m_unequipTime ) )
		{
			SendEquipmentSystemWeaponManipulationRequest( scriptInterface, EquipmentManipulationAction.UnequipWeapon );
		}
	}

}

class MeleeSafeDecisions extends MeleeTransition
{

	protected export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( ( ( PlayerPuppet )( scriptInterface.executionOwner ) ).IsAimingAtFriendly() || ShouldEnterSafe( stateContext, scriptInterface ) )
		{
			return true;
		}
		return false;
	}

	protected export const function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( EnterCondition( stateContext, scriptInterface ) ) )
		{
			return true;
		}
		return false;
	}

}

class MeleeSafeEvents extends MeleePublicSafeEvents
{

	public export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.Safe ) ) );
	}

}

class MeleeHoldDecisions extends MeleeTransition
{

	protected export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( ShouldHold( stateContext, scriptInterface ) && !( IsPlayingSyncedAnimation( scriptInterface ) ) )
		{
			return true;
		}
		return false;
	}

	protected export const function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var isThrowableWeapon : Bool;
		if( ShouldInterruptHoldStates( stateContext, scriptInterface ) )
		{
			return true;
		}
		if( ToMeleeChargedHold( stateContext, scriptInterface ) && !( IsPlayingSyncedAnimation( scriptInterface ) ) )
		{
			return true;
		}
		if( ( scriptInterface.GetActionValue( 'MeleeStrongAttack' ) <= 0.0 ) && ( scriptInterface.GetActionValue( 'MeleeAttack' ) <= 0.0 ) )
		{
			return true;
		}
		if( IsBlockHeld( stateContext, scriptInterface ) )
		{
			isThrowableWeapon = GetWeaponObject( scriptInterface ).WeaponHasTag( 'Throwable' );
			if( !( isThrowableWeapon ) || CanThrowWeapon( stateContext, scriptInterface ) )
			{
				return true;
			}
		}
		return false;
	}

	protected export const function ToMeleeChargedHold( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( WantsToStrongAttack( stateContext, scriptInterface ) )
		{
			return true;
		}
		if( scriptInterface.GetActionValue( 'MeleeStrongAttack' ) > 0.0 )
		{
			return true;
		}
		if( GetInStateTime() > GetHoldEnterDuration( scriptInterface ) )
		{
			return true;
		}
		return false;
	}

	protected export const function ToMeleeFinalAttack( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return CheckIfFinalAttack( scriptInterface, stateContext ) && WantsToLightAttack( stateContext, scriptInterface );
	}

}

class MeleeHoldEvents extends MeleeEventsTransition
{

	public export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		SetIsHolding( stateContext, true );
		SetIsBlocking( stateContext, false );
		SetIsAttacking( stateContext, false );
		SetIsTargeting( stateContext, false );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.Hold ) ) );
		super.OnEnter( stateContext, scriptInterface );
	}

	public export override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		SetIsHolding( stateContext, false );
		super.OnExit( stateContext, scriptInterface );
	}

}

class MeleeChargedHoldDecisions extends MeleeTransition
{

	protected export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( ShouldHold( stateContext, scriptInterface ) )
		{
			return true;
		}
		return false;
	}

	protected const function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( ShouldInterruptHoldStates( stateContext, scriptInterface ) )
		{
			return true;
		}
		if( !( ShouldHold( stateContext, scriptInterface ) ) )
		{
			return true;
		}
		if( ToMeleeStrongAttack( stateContext, scriptInterface ) && !( IsPlayingSyncedAnimation( scriptInterface ) ) )
		{
			return true;
		}
		if( IsBlockHeld( stateContext, scriptInterface ) )
		{
			return true;
		}
		return false;
	}

	protected const function ToMeleeStrongAttack( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var timeoutDuration : Float;
		if( NoStrongAttackPressed( scriptInterface ) )
		{
			return true;
		}
		timeoutDuration = scriptInterface.GetStatsSystem().GetStatValue( ( ( EntityID )( scriptInterface.ownerEntityID ) ), gamedataStatType.HoldTimeoutDuration );
		if( ( timeoutDuration > 0.0 ) && ( GetInStateTime() >= timeoutDuration ) )
		{
			return true;
		}
		return false;
	}

	protected constexpr const function ToMeleeFinalAttack( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return false;
	}

}

class MeleeChargedHoldEvents extends MeleeRumblingEvents
{
	var m_clearWeaponCharge : Bool;

	public override function GetIntensity() : String
	{
		return "heavy";
	}

	public override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var chargeValuePerSec : Float;
		m_clearWeaponCharge = true;
		PlayRumble( scriptInterface, "light_fast" );
		SetIsHolding( stateContext, true );
		SetIsBlocking( stateContext, false );
		SetIsAttacking( stateContext, false );
		SetIsTargeting( stateContext, false );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.ChargedHold ) ) );
		stateContext.SetPermanentBoolParameter( 'VisionToggled', false, true );
		ForceDisableVisionMode( stateContext );
		if( !( CheckItemType( scriptInterface, gamedataItemType.Cyb_MantisBlades ) ) )
		{
			stateContext.SetTemporaryBoolParameter( 'InterruptSprint', true, true );
			SetCanSprintWhileCharging( stateContext, false );
		}
		else
		{
			SetCanSprintWhileCharging( stateContext, true );
		}
		chargeValuePerSec = GetChargeValuePerSec( scriptInterface );
		if( chargeValuePerSec > 0.0 )
		{
			StartPool( scriptInterface.GetStatPoolsSystem(), GetWeaponObject( scriptInterface ).GetEntityID(), gamedataStatPoolType.WeaponCharge, 100.0, chargeValuePerSec );
		}
		GameInstance.GetAudioSystem( scriptInterface.owner.GetGame() ).AddTriggerEffect( 'te_wea_melee_charge', 'PSM_MeleeChargeOnEnter_charge' );
		super.OnEnter( stateContext, scriptInterface );
	}

	public override function OnForcedExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		OnExitCommon( stateContext, scriptInterface );
		super.OnForcedExit( stateContext, scriptInterface );
	}

	public override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		OnExitCommon( stateContext, scriptInterface );
		super.OnExit( stateContext, scriptInterface );
	}

	protected function OnExitToMeleeStrongAttack( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		m_clearWeaponCharge = false;
		OnExit( stateContext, scriptInterface );
	}

	private function OnExitCommon( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		SetIsHolding( stateContext, false );
		if( CheckItemType( scriptInterface, gamedataItemType.Cyb_NanoWires ) )
		{
			m_clearWeaponCharge = false;
		}
		StopPool( scriptInterface.GetStatPoolsSystem(), GetWeaponObject( scriptInterface ).GetEntityID(), gamedataStatPoolType.WeaponCharge, false );
		if( m_clearWeaponCharge )
		{
			ChangeStatPoolValue( scriptInterface, scriptInterface.ownerEntityID, gamedataStatPoolType.WeaponCharge, -100.0, true );
		}
		GameInstance.GetAudioSystem( scriptInterface.owner.GetGame() ).RemoveTriggerEffect( 'PSM_MeleeChargeOnEnter_charge' );
	}

	private function GetChargeValuePerSec( scriptInterface : StateGameScriptInterface ) : Float
	{
		var weapon : WeaponObject;
		var chargeDuration : Float;
		var statsSystem : StatsSystem;
		statsSystem = scriptInterface.GetStatsSystem();
		if( !( statsSystem ) )
		{
			return -1.0;
		}
		weapon = GetWeaponObject( scriptInterface );
		if( !( weapon ) )
		{
			return -1.0;
		}
		chargeDuration = statsSystem.GetStatValue( weapon.GetEntityID(), gamedataStatType.ChargeTime );
		if( chargeDuration <= 0.0 )
		{
			return -1.0;
		}
		return 100.0 / chargeDuration;
	}

}

abstract class MeleeAttackGenericDecisions extends MeleeTransition
{

	protected const virtual function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( HasAttackRecord( scriptInterface, stateContext.GetIntParameter( 'meleeAttackNumber', true ) ) ) )
		{
			return false;
		}
		if( GameObject.IsCooldownActive( scriptInterface.owner, GetMeleeAttackCooldownName() ) )
		{
			return false;
		}
		return true;
	}

	protected export const virtual function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var interruptEvent : StateResultBool;
		var attackData : MeleeAttackData;
		var inStateTime : Float;
		interruptEvent = stateContext.GetPermanentBoolParameter( 'InterruptMelee' );
		attackData = GetAttackData( stateContext );
		inStateTime = GetInStateTime();
		if( interruptEvent.value )
		{
			if( inStateTime >= attackData.attackWindowClosed )
			{
				return true;
			}
			return false;
		}
		if( IsBlockHeld( stateContext, scriptInterface ) )
		{
			if( ( attackData.blockTransitionTime > 0.0 ) && ( inStateTime >= attackData.blockTransitionTime ) )
			{
				return true;
			}
			if( inStateTime >= attackData.attackWindowClosed )
			{
				if( !( HasMeleeTargeting( stateContext, scriptInterface ) ) && IsBlockPressed( stateContext, scriptInterface ) )
				{
					return true;
				}
			}
		}
		if( ( inStateTime >= attackData.attackWindowClosed ) && !( IsPlayingSyncedAnimation( scriptInterface ) ) )
		{
			if( stateContext.GetConditionBool( 'LightMeleeAttackPressed' ) )
			{
				return true;
			}
			else if( stateContext.GetConditionBool( 'StrongMeleeAttackPressed' ) )
			{
				return true;
			}
			else if( ShouldHold( stateContext, scriptInterface, false, true ) )
			{
				return true;
			}
		}
		if( inStateTime >= attackData.idleTransitionTime )
		{
			return true;
		}
		if( IsAttackParried( stateContext, scriptInterface ) )
		{
			return true;
		}
		return false;
	}

	protected const function GetAttackData( const stateContext : StateContext ) : MeleeAttackData
	{
		return ( ( MeleeAttackData )( stateContext.GetConditionScriptableParameter( 'MeleeAttackData' ) ) );
	}

}

abstract class MeleeAttackGenericEvents extends MeleeEventsTransition
{
	var m_effect : EffectInstance;
	var m_attackCreated : Bool;
	var m_blockImpulseCreation : Bool;
	var m_standUpSend : Bool;
	var m_trailCreated : Bool;
	var m_textLayer : Uint32;
	var m_rumblePlayed : Bool;
	var m_shouldBlockImpulseUpdate : Bool;

	protected virtual function GetAttackType() : EMeleeAttackType
	{
		return EMeleeAttackType.Combo;
	}

	protected virtual function IsMoveToTargetEnabled( attackData : MeleeAttackData, assistRecord : AimAssistMelee_Record ) : Bool
	{
		var assistLevel : EMoveAssistLevel;
		var attackType : EMeleeAttackType;
		if( !( attackData.enableAdjustingPlayerPositionToTarget ) )
		{
			return false;
		}
		if( assistRecord )
		{
			assistLevel = ( ( EMoveAssistLevel )( assistRecord.MoveToTargetEnabledAttacks() ) );
			if( assistLevel == EMoveAssistLevel.AllAttacks )
			{
				return true;
			}
			else if( assistLevel == EMoveAssistLevel.Off )
			{
				return false;
			}
			else if( assistLevel == EMoveAssistLevel.SpecialAttacks )
			{
				attackType = GetAttackType();
				return attackType == EMeleeAttackType.Strong;
			}
		}
		return false;
	}

	public override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var attackData : MeleeAttackData;
		var attackRange : Float;
		var adjustmentDistParam : Float;
		var adjustmentTargetRadius : Float;
		var adjustRadius : Float;
		var adjustRadiusParam : Float;
		var broadcaster : StimBroadcasterComponent;
		var aimAssistRecord : AimAssistMelee_Record;
		aimAssistRecord = GetAimAssistMeleeRecord( scriptInterface );
		m_attackCreated = false;
		m_blockImpulseCreation = false;
		m_standUpSend = false;
		m_effect = NULL;
		m_trailCreated = false;
		m_rumblePlayed = false;
		m_shouldBlockImpulseUpdate = false;
		if( broadcaster = scriptInterface.executionOwner.GetStimBroadcasterComponent() )
		{
			broadcaster.TriggerSingleBroadcast( scriptInterface.executionOwner, gamedataStimType.MeleeAttack );
		}
		SetMeleeAttackPressCount( stateContext, scriptInterface );
		ClearInputBuffer( stateContext );
		stateContext.SetPermanentBoolParameter( 'InterruptMelee', false, true );
		SetIsAttacking( stateContext, true );
		SetIsBlocking( stateContext, false );
		if( ( GetAttackType() != EMeleeAttackType.Throw && aimAssistRecord ) && aimAssistRecord.AimSnapOnAttack() )
		{
			scriptInterface.GetTargetingSystem().AimSnap( scriptInterface.executionOwner );
		}
		GameObject.PlayVoiceOver( scriptInterface.executionOwner, 'meleeAttack', 'Scripts:MeleeAttackGenericEvents' );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Melee, ( ( Int32 )( gamePSMMelee.Attack ) ) );
		GetAttackDataFromCurrentState( stateContext, scriptInterface, stateContext.GetIntParameter( 'meleeAttackNumber', true ), attackData );
		stateContext.SetPermanentBoolParameter( 'hasDeflectAnim', attackData.hasDeflectAnim, true );
		stateContext.SetPermanentBoolParameter( 'hasHitAnim', attackData.hasHitAnim, true );
		stateContext.SetConditionScriptableParameter( 'MeleeAttackData', attackData, true );
		stateContext.SetPermanentBoolParameter( 'VisionToggled', false, true );
		ForceDisableVisionMode( stateContext );
		stateContext.SetTemporaryBoolParameter( 'InterruptSprint', true, true );
		stateContext.SetConditionBoolParameter( 'SprintToggled', false, true );
		ClearDebugText( scriptInterface, m_textLayer );
		if( IsMoveToTargetEnabled( attackData, aimAssistRecord ) )
		{
			if( !( IsPlayerExhausted( scriptInterface ) ) )
			{
				attackRange = scriptInterface.GetStatsSystem().GetStatValue( ( ( EntityID )( scriptInterface.ownerEntityID ) ), gamedataStatType.Range );
				adjustmentDistParam = aimAssistRecord.MoveToTargetSearchDistance();
				adjustmentTargetRadius = attackRange + adjustmentDistParam;
				adjustRadiusParam = aimAssistRecord.MoveToTargetDistanceIntoAttackRange();
				adjustRadius = MaxF( attackRange - adjustRadiusParam, 1.5 );
				if( AdjustPlayerPosition( stateContext, scriptInterface, GetTargetObject( scriptInterface, adjustmentTargetRadius ), attackData.attackEffectDelay, adjustRadius, '' ) )
				{
					m_blockImpulseCreation = true;
				}
			}
		}
		SendAnimationSlotData( stateContext, scriptInterface, attackData );
		scriptInterface.PushAnimationEvent( 'Attack' );
		stateContext.SetPermanentIntParameter( 'attackType', ( ( Int32 )( GetAttackType() ) ), true );
		super.OnEnter( stateContext, scriptInterface );
		if( attackData.standUpDelay == 0.0 )
		{
			stateContext.SetConditionBoolParameter( 'CrouchToggled', false, true );
			m_standUpSend = true;
		}
		if( attackData.incrementsCombo )
		{
			IncrementAttackNumber( scriptInterface, stateContext );
		}
		SetIsSafe( stateContext, false );
		SendDataTrackingRequest( scriptInterface, ETelemetryData.MeleeAttacksMade, 1 );
		GameInstance.GetTelemetrySystem( scriptInterface.owner.GetGame() ).LogWeaponAttackPerformed( GetWeaponObject( scriptInterface ) );
	}

	protected function SendAnimationSlotData( stateContext : StateContext, scriptInterface : StateGameScriptInterface, const attackData : MeleeAttackData ) : Bool
	{
		var slotData : AnimFeature_MeleeSlotData;
		slotData = new AnimFeature_MeleeSlotData;
		slotData.attackType = ( ( Int32 )( GetAttackType() ) );
		slotData.comboNumber = stateContext.GetIntParameter( 'meleeAttackNumber', true );
		slotData.startupDuration = attackData.startupDuration;
		slotData.activeDuration = attackData.activeDuration;
		slotData.recoverDuration = attackData.recoverDuration;
		slotData.activeHitDuration = attackData.activeHitDuration;
		slotData.recoverHitDuration = attackData.recoverHitDuration;
		scriptInterface.SetAnimationParameterFeature( 'MeleeSlotData', slotData );
		return true;
	}

	protected function ConsumeStamina( scriptInterface : StateGameScriptInterface, attackData : MeleeAttackData )
	{
		if( attackData.staminaCost > 0.0 )
		{
			PlayerStaminaHelpers.ModifyStamina( ( ( PlayerPuppet )( scriptInterface.executionOwner ) ), -( attackData.staminaCost ) );
		}
	}

	protected function ConsumeWeaponCharge( scriptInterface : StateGameScriptInterface, attackData : MeleeAttackData )
	{
		if( !( scriptInterface.GetStatPoolsSystem().IsStatPoolAdded( scriptInterface.ownerEntityID, gamedataStatPoolType.WeaponCharge ) ) )
		{
			return;
		}
		if( attackData.weaponChargeCost > 0.0 )
		{
			ChangeStatPoolValue( scriptInterface, scriptInterface.ownerEntityID, gamedataStatPoolType.WeaponCharge, -( attackData.weaponChargeCost ), true );
		}
	}

	public export override function OnUpdate( timeDelta : Float, stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var attackData : MeleeAttackData;
		var duration : Float;
		super.OnUpdate( timeDelta, stateContext, scriptInterface );
		attackData = GetAttackData( stateContext );
		duration = GetInStateTime();
		if( ( !( m_standUpSend ) && ( attackData.standUpDelay > 0.0 ) ) && ( duration > attackData.standUpDelay ) )
		{
			stateContext.SetConditionBoolParameter( 'CrouchToggled', false, true );
			m_standUpSend = true;
		}
		UpdateIKData( scriptInterface, attackData );
		if( ( ( duration >= attackData.attackEffectDelay ) && !( m_attackCreated ) ) && ( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon ) != ( ( Int32 )( gamePSMMeleeWeapon.ThrowAttack ) ) ) )
		{
			CreateMeleeAttack( stateContext, scriptInterface, attackData );
			m_attackCreated = true;
			ConsumeStamina( scriptInterface, attackData );
		}
		if( m_effect )
		{
			UpdateEffectPosition( stateContext, scriptInterface, attackData );
			if( duration >= ( ( attackData.attackEffectDelay + attackData.attackEffectDuration ) + 0.1 ) )
			{
				m_effect = NULL;
				ConsumeWeaponCharge( scriptInterface, attackData );
			}
		}
		if( m_trailCreated && ( duration >= attackData.trailStopDelay ) )
		{
			GetWeaponObject( scriptInterface ).StopCurrentMeleeTrailEffect( attackData.trailAttackSide );
		}
		else if( ( duration >= attackData.trailStartDelay ) && !( m_trailCreated ) )
		{
			GetWeaponObject( scriptInterface ).StartCurrentMeleeTrailEffect( attackData.trailAttackSide );
			m_trailCreated = true;
		}
		if( ShouldBlockMovementImpulseUpdate( timeDelta, attackData, stateContext, scriptInterface ) )
		{
			m_shouldBlockImpulseUpdate = true;
		}
		if( UpdateMovementImpulse( timeDelta, attackData, stateContext, scriptInterface ) )
		{
			m_blockImpulseCreation = true;
		}
		if( duration >= attackData.attackEffectDelay )
		{
			if( !( m_rumblePlayed ) )
			{
				PlayRumble( scriptInterface, GetStaticStringParameterDefault( "rumbleStrength", "light_fast" ) );
				m_rumblePlayed = true;
			}
		}
		if( GetAttackType() == EMeleeAttackType.Final )
		{
			ClearInputBuffer( stateContext );
		}
		else if( IsAttackWindowOpen( stateContext, scriptInterface ) )
		{
			UpdateMeleeInputBuffer( stateContext, scriptInterface );
		}
		if( duration >= attackData.attackWindowClosed )
		{
			SetIsAttacking( stateContext, false );
		}
	}

	protected function UpdateIKData( scriptInterface : StateGameScriptInterface, const attackData : MeleeAttackData )
	{
		var animFeature : AnimFeature_MeleeIKData;
		var target : GameObject;
		var slotPosition : Vector4;
		animFeature = new AnimFeature_MeleeIKData;
		target = GetTargetObject( scriptInterface );
		if( target )
		{
			if( AIActionHelper.GetTargetSlotPosition( target, 'Head', slotPosition ) )
			{
				animFeature.headPosition = slotPosition;
				animFeature.isValid = true;
			}
			if( AIActionHelper.GetTargetSlotPosition( target, 'Chest', slotPosition ) )
			{
				animFeature.chestPosition = slotPosition;
				animFeature.isValid = true;
			}
			animFeature.ikOffset.X = attackData.ikOffset.X;
			animFeature.ikOffset.Y = attackData.ikOffset.Y;
			animFeature.ikOffset.Z = attackData.ikOffset.Z;
		}
		scriptInterface.SetAnimationParameterFeature( 'MeleeIKData', animFeature );
	}

	protected function ShouldBlockMovementImpulseUpdate( timeDelta : Float, attackData : MeleeAttackData, stateContext : StateContext, scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( scriptInterface.IsOnGround() ) && ( ( attackData.forwardImpulse < 0.0 ) || ( attackData.forwardImpulse > 0.0 ) ) )
		{
			return true;
		}
		if( scriptInterface.GetOwnerStateVectorParameterFloat( physicsStateValue.LinearSpeed ) >= 10.0 )
		{
			return true;
		}
		return false;
	}

	protected function UpdateMovementImpulse( timeDelta : Float, attackData : MeleeAttackData, stateContext : StateContext, scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( m_blockImpulseCreation )
		{
			return true;
		}
		if( IsPlayerExhausted( scriptInterface ) )
		{
			return true;
		}
		if( m_shouldBlockImpulseUpdate )
		{
			return false;
		}
		if( ( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.LocomotionDetailed ) == ( ( Int32 )( gamePSMDetailedLocomotionStates.Slide ) ) ) || ( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.LocomotionDetailed ) == ( ( Int32 )( gamePSMDetailedLocomotionStates.SlideFall ) ) ) )
		{
			return false;
		}
		if( GetInStateTime() < attackData.impulseDelay )
		{
			return false;
		}
		if( !( CheckItemType( scriptInterface, gamedataItemType.Cyb_MantisBlades ) ) )
		{
			if( ( ( attackData.cameraSpaceImpulse > 0.0 ) || ( attackData.forwardImpulse > 0.0 ) ) && !( IsPlayerInputDirectedForward( scriptInterface ) ) )
			{
				return true;
			}
			if( IsCameraPitchAcceptable( stateContext, scriptInterface, GetStaticFloatParameterDefault( "cameraPitchThreshold", -30.0 ) ) )
			{
				return true;
			}
		}
		if( !( AdjustAttackPosition( scriptInterface, stateContext, attackData ) ) )
		{
			AddAttackImpulse( scriptInterface, stateContext, attackData );
		}
		return true;
	}

	protected function UpdateEffectPosition( stateContext : StateContext, scriptInterface : StateGameScriptInterface, attackData : MeleeAttackData )
	{
		var startPosition : Vector4;
		var endPosition : Vector4;
		var dir : Vector4;
		var cameraWorldTransform : Transform;
		var attackRange : Float;
		cameraWorldTransform = scriptInterface.GetCameraWorldTransform();
		startPosition = attackData.startPosition;
		endPosition = attackData.endPosition;
		dir = startPosition - endPosition;
		attackRange = scriptInterface.GetStatsSystem().GetStatValue( ( ( EntityID )( scriptInterface.ownerEntityID ) ), gamedataStatType.Range );
		startPosition = attackData.startPosition;
		if( dir.Y == 0.0 )
		{
			startPosition.Y += ( attackRange * 0.5 );
		}
		EffectData.SetVector( m_effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.position, Transform.TransformPoint( cameraWorldTransform, startPosition ) );
	}

	public export override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var interruptEvent : StateResultBool;
		var attackData : MeleeAttackData;
		attackData = GetAttackData( stateContext );
		interruptEvent = stateContext.GetPermanentBoolParameter( 'InterruptMelee' );
		scriptInterface.SetAnimationParameterFloat( 'safe', 0.0 );
		stateContext.SetPermanentBoolParameter( 'safe', false, true );
		if( interruptEvent.value )
		{
			GetAttackDataFromCurrentState( stateContext, scriptInterface, stateContext.GetIntParameter( 'meleeAttackNumber', true ), attackData );
			stateContext.SetPermanentFloatParameter( 'meleeRecoveryDuration', attackData.idleTransitionTime - GetInStateTime(), true );
		}
		stateContext.SetPermanentBoolParameter( 'InterruptMelee', false, true );
		super.OnExit( stateContext, scriptInterface );
		ClearDebugText( scriptInterface, m_textLayer );
	}

	public override function OnForcedExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		ClearDebugText( scriptInterface, m_textLayer );
		super.OnForcedExit( stateContext, scriptInterface );
	}

	protected function CreateMeleeAttack( stateContext : StateContext, scriptInterface : StateGameScriptInterface, attackData : MeleeAttackData )
	{
		var sweepBoxColliderSize : Float;
		var startPosition : Vector4;
		var endPosition : Vector4;
		var time : Float;
		var colliderBox : Vector4;
		var attackRange : Float;
		var dir : Vector4;
		sweepBoxColliderSize = 0.25;
		startPosition = attackData.startPosition;
		endPosition = attackData.endPosition;
		attackRange = scriptInterface.GetStatsSystem().GetStatValue( ( ( EntityID )( scriptInterface.ownerEntityID ) ), gamedataStatType.Range );
		dir = endPosition - startPosition;
		colliderBox.X = sweepBoxColliderSize;
		colliderBox.Y = sweepBoxColliderSize;
		colliderBox.Z = sweepBoxColliderSize;
		if( dir.Y != 0.0 )
		{
			endPosition.Y = attackRange;
		}
		else
		{
			startPosition.Y += ( attackRange * 0.5 );
			endPosition.Y += ( attackRange * 0.5 );
			colliderBox.Y = attackRange;
		}
		time = attackData.attackEffectDuration;
		SpawnAttackGameEffect( stateContext, scriptInterface, startPosition, endPosition, time, colliderBox, attackData );
		GameObject.StartCooldown( scriptInterface.owner, GetMeleeAttackCooldownName(), attackData.attackWindowClosed - attackData.attackEffectDelay, true );
	}

	protected function SpawnAttackGameEffect( stateContext : StateContext, scriptInterface : StateGameScriptInterface, startPosition : Vector4, endPosition : Vector4, time : Float, colliderBox : Vector4, attackData : MeleeAttackData ) : Bool
	{
		var effect : EffectInstance;
		var attackStartPositionWorld : Vector4;
		var attackDirectionWorld : Vector4;
		var cameraWorldTransform : Transform;
		var weapon : WeaponObject;
		var meleeAttack : Attack_GameEffect;
		var success : Bool;
		var weaponCharge : Float;
		success = false;
		cameraWorldTransform = scriptInterface.GetCameraWorldTransform();
		attackStartPositionWorld = Transform.TransformPoint( cameraWorldTransform, startPosition );
		attackStartPositionWorld.W = 0.0;
		attackDirectionWorld = Transform.TransformPoint( cameraWorldTransform, endPosition ) - attackStartPositionWorld;
		attackDirectionWorld.W = 0.0;
		weapon = ( ( WeaponObject )( scriptInterface.owner ) );
		if( weapon )
		{
			meleeAttack = ( ( Attack_GameEffect )( weapon.GetCurrentAttack() ) );
			if( meleeAttack )
			{
				effect = meleeAttack.PrepareAttack( scriptInterface.executionOwner );
				EffectData.SetVector( effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.box, colliderBox );
				EffectData.SetFloat( effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.duration, time );
				EffectData.SetVector( effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.position, attackStartPositionWorld );
				EffectData.SetQuat( effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.rotation, Transform.GetOrientation( cameraWorldTransform ) );
				EffectData.SetVector( effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.forward, Vector4.Normalize( attackDirectionWorld ) );
				EffectData.SetFloat( effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.range, Vector4.Length( attackDirectionWorld ) );
				EffectData.SetInt( effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.attackNumber, stateContext.GetIntParameter( 'meleeAttackNumber', true ) );
				EffectData.SetName( effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.impactOrientationSlot, attackData.impactFxSlot );
				weaponCharge = MinF( attackData.weaponChargeCost / 100.0, WeaponObject.GetWeaponChargeNormalized( weapon ) );
				EffectData.SetFloat( effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.charge, weaponCharge );
				if( GetAttackType() == EMeleeAttackType.Strong )
				{
					EffectData.SetBool( effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.meleeCleave, true );
				}
				EffectData.SetVariant( effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.fxPackage, ( ( WeaponObject )( scriptInterface.owner ) ).GetFxPackage() );
				EffectData.SetBool( effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.playerOwnedWeapon, true );
				m_effect = effect;
				success = meleeAttack.StartAttack();
			}
		}
		return success;
	}

	protected function BroadcastStimuli( scriptInterface : StateGameScriptInterface, radius : Float )
	{
		var effect : EffectInstance;
		var position : Vector4;
		var stimuliEvent : StimuliEvent;
		position = scriptInterface.executionOwner.GetWorldPosition();
		stimuliEvent = new StimuliEvent;
		stimuliEvent.sourcePosition = position;
		stimuliEvent.name = 'run';
		effect = GameInstance.GetGameEffectSystem( scriptInterface.GetGame() ).CreateEffectStatic( 'stimuli', 'stimuli_range', scriptInterface.executionOwner, scriptInterface.owner );
		EffectData.SetVariant( effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.stimuliEvent, stimuliEvent );
		EffectData.SetVector( effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.position, position );
		EffectData.SetFloat( effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.radius, radius );
		EffectData.SetBool( effect.GetSharedData(), GetAllBlackboardDefs().EffectSharedData.stimuliRaycastTest, true );
		GameInstance.GetStimuliSystem( scriptInterface.owner.GetGame() ).BroadcastStimuli( effect );
	}

	protected const function GetAttackData( const stateContext : StateContext ) : MeleeAttackData
	{
		return ( ( MeleeAttackData )( stateContext.GetConditionScriptableParameter( 'MeleeAttackData' ) ) );
	}

	protected const function IsAttackWindowOpen( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var attackData : MeleeAttackData;
		var inStateTime : Float;
		attackData = GetAttackData( stateContext );
		inStateTime = GetInStateTime();
		if( inStateTime >= attackData.attackWindowOpen )
		{
			return true;
		}
		return false;
	}

}

class MeleeComboAttackDecisions extends MeleeAttackGenericDecisions
{

	protected export const override function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( WantsToLightAttack( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		if( !( super.EnterCondition( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		return true;
	}

}

class MeleeComboAttackEvents extends MeleeAttackGenericEvents
{

	protected override final function GetAttackType() : EMeleeAttackType
	{
		return EMeleeAttackType.Combo;
	}

	public export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.ComboAttack ) ) );
		super.OnEnter( stateContext, scriptInterface );
		IncrementTotalComboAttackNumber( scriptInterface, stateContext );
	}

}

class MeleeFinalAttackDecisions extends MeleeAttackGenericDecisions
{

	protected export const override function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( CheckIfFinalAttack( scriptInterface, stateContext ) ) )
		{
			return false;
		}
		if( WantsToStrongAttack( stateContext, scriptInterface ) )
		{
			return false;
		}
		if( !( WantsToLightAttack( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		if( !( super.EnterCondition( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		return true;
	}

}

class MeleeFinalAttackEvents extends MeleeAttackGenericEvents
{

	protected override final function GetAttackType() : EMeleeAttackType
	{
		return EMeleeAttackType.Final;
	}

	public export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		stateContext.SetPermanentBoolParameter( 'finalAttack', true, true );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.FinalAttack ) ) );
		super.OnEnter( stateContext, scriptInterface );
	}

	public export override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		stateContext.SetPermanentBoolParameter( 'finalAttack', false, true );
		super.OnExit( stateContext, scriptInterface );
	}

}

class MeleeSafeAttackDecisions extends MeleeAttackGenericDecisions
{

	protected export const override function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( WantsToLightAttack( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		if( !( HasAttackRecord( scriptInterface ) ) )
		{
			return false;
		}
		return true;
	}

}

class MeleeSafeAttackEvents extends MeleeAttackGenericEvents
{

	protected override final function GetAttackType() : EMeleeAttackType
	{
		return EMeleeAttackType.Safe;
	}

	public export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		ResetAttackNumber( stateContext );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.SafeAttack ) ) );
		super.OnEnter( stateContext, scriptInterface );
	}

	public export override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		super.OnExit( stateContext, scriptInterface );
	}

}

class MeleeStrongAttackDecisions extends MeleeAttackGenericDecisions
{

	protected const override function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( stateContext.GetConditionBool( 'StrongMeleeAttackPressed' ) ) )
		{
			return false;
		}
		return true;
	}

}

class MeleeStrongAttackEvents extends MeleeAttackGenericEvents
{

	protected override final function GetAttackType() : EMeleeAttackType
	{
		return EMeleeAttackType.Strong;
	}

	public function OnEnterFromMeleeLeap( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		OnEnter( stateContext, scriptInterface );
		m_blockImpulseCreation = true;
		SetBlackboardBoolVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeLeap, true );
	}

	public override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		stateContext.SetPermanentBoolParameter( 'strongAttack', true, true );
		SetAttackNumber( stateContext, stateContext.GetIntParameter( 'meleeAttackNumber', true ) % ( ( Int32 )( 2 ) ) );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.StrongAttack ) ) );
		super.OnEnter( stateContext, scriptInterface );
	}

	public override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		stateContext.SetPermanentBoolParameter( 'strongAttack', false, true );
		SetBlackboardBoolVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeLeap, false );
		super.OnExit( stateContext, scriptInterface );
	}

	protected function OnExitToMeleeComboAttack( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		OnExit( stateContext, scriptInterface );
	}

}

class MeleeDeflectDecisions extends MeleeTransition
{

	protected export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsBlockPressed( stateContext, scriptInterface ) )
		{
			if( !( CanWeaponDeflect( stateContext, scriptInterface ) ) )
			{
				return false;
			}
			if( HasMeleeTargeting( stateContext, scriptInterface ) )
			{
				return false;
			}
			if( GetStaticBoolParameterDefault( "disabled", false ) )
			{
				return false;
			}
			if( GameObject.IsCooldownActive( scriptInterface.owner, 'Deflect' ) )
			{
				return false;
			}
			return true;
		}
		return false;
	}

	protected export const function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsDeflectSuccessful( stateContext, scriptInterface ) )
		{
			return true;
		}
		if( ShouldInterruptHoldStates( stateContext, scriptInterface ) )
		{
			return true;
		}
		if( GetInStateTime() >= GetStaticFloatParameterDefault( "duration", 0.40000001 ) )
		{
			return true;
		}
		if( IsBlockHeld( stateContext, scriptInterface ) )
		{
			return AnyMeleeAttackPressed( scriptInterface ) || stateContext.GetConditionBool( 'LightMeleeAttackPressed' );
		}
		return false;
	}

	public function ToMeleeHold( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( ( ShouldHold( stateContext, scriptInterface ) && ToMeleeComboAttack( stateContext, scriptInterface ) ) && !( IsPlayingSyncedAnimation( scriptInterface ) ) )
		{
			return true;
		}
		return false;
	}

	protected const function ToMeleeComboAttack( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( IsBlockHeld( stateContext, scriptInterface ) ) )
		{
			if( stateContext.GetConditionBool( 'LightMeleeAttackPressed' ) && !( IsPlayingSyncedAnimation( scriptInterface ) ) )
			{
				return true;
			}
		}
		return false;
	}

	public constexpr export function ToMeleeBlock( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return true;
	}

	protected export function ToMeleeDeflectAttack( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return IsDeflectSuccessful( stateContext, scriptInterface );
	}

	protected const function IsDeflectSuccessful( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var deflectEvent : StateResultBool;
		deflectEvent = stateContext.GetTemporaryBoolParameter( 'successfulDeflect' );
		return deflectEvent.valid;
	}

}

class MeleeDeflectEvents extends MeleeEventsTransition
{
	var deflectStatFlag : gameStatModifierData;

	public export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var ownerID : StatsObjectID;
		ownerID = scriptInterface.executionOwnerEntityID;
		SetIsBlocking( stateContext, true );
		scriptInterface.PushAnimationEvent( 'Deflect' );
		scriptInterface.GetTargetingSystem().AimSnap( scriptInterface.executionOwner );
		deflectStatFlag = RPGManager.CreateStatModifier( gamedataStatType.IsDeflecting, gameStatModifierType.Additive, 1.0 );
		scriptInterface.GetStatsSystem().AddModifier( ownerID, deflectStatFlag );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Melee, ( ( Int32 )( gamePSMMelee.Block ) ) );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.Deflect ) ) );
		stateContext.SetTemporaryBoolParameter( 'InterruptSprint', true, true );
		ClearInputBuffer( stateContext );
		super.OnEnter( stateContext, scriptInterface );
	}

	public export override function OnUpdate( timeDelta : Float, stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		super.OnUpdate( timeDelta, stateContext, scriptInterface );
	}

	public export override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var ownerID : StatsObjectID;
		ownerID = scriptInterface.executionOwnerEntityID;
		scriptInterface.GetStatsSystem().RemoveModifier( ownerID, deflectStatFlag );
		GameObject.StartCooldown( scriptInterface.owner, 'Deflect', GetStaticFloatParameterDefault( "cooldown", -1.0 ), true );
		super.OnExit( stateContext, scriptInterface );
	}

}

class MeleeDeflectAttackDecisions extends MeleeAttackGenericDecisions
{

	protected const override function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( HasAttackRecord( scriptInterface ) ) )
		{
			return false;
		}
		return true;
	}

}

class MeleeDeflectAttackEvents extends MeleeAttackGenericEvents
{
	var m_slowMoSet : Bool;

	public override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		ResetAttackNumber( stateContext );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.DeflectAttack ) ) );
		TutorialAddFact( scriptInterface, 'melee_deflect_tutorial', 1 );
		PlayRumble( scriptInterface, GetStaticStringParameterDefault( "rumbleOnStartStrength", "light_fast" ) );
		GameObject.PlaySound( scriptInterface.executionOwner, GetStaticCNameParameterDefault( "slowMoStartSound", '' ) );
		m_slowMoSet = false;
		super.OnEnter( stateContext, scriptInterface );
	}

	public override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		super.OnExit( stateContext, scriptInterface );
	}

	public override function OnUpdate( timeDelta : Float, stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var slowMoStart : Float;
		slowMoStart = GetStaticFloatParameterDefault( "slowMoStart", 0.1 );
		if( ( !( m_slowMoSet ) && ( GetInStateTime() > slowMoStart ) ) && !( IsTimeDilationActive( stateContext, scriptInterface, '' ) ) )
		{
			scriptInterface.GetTimeSystem().SetTimeDilation( 'deflect', GetStaticFloatParameterDefault( "slowMoAmount", 0.1 ), GetStaticFloatParameterDefault( "slowDuration", 0.1 ), GetStaticCNameParameterDefault( "slowMoEaseIn", 'Linear' ), GetStaticCNameParameterDefault( "slowMoEaseOut", 'Linear' ) );
			m_slowMoSet = true;
		}
		super.OnUpdate( timeDelta, stateContext, scriptInterface );
	}

}

class MeleeBlockDecisions extends MeleeTransition
{

	protected export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsBlockHeld( stateContext, scriptInterface ) )
		{
			if( IsAttackParried( stateContext, scriptInterface ) )
			{
				return false;
			}
			if( !( CanWeaponBlock( stateContext, scriptInterface ) ) )
			{
				return false;
			}
			if( HasMeleeTargeting( stateContext, scriptInterface ) && CanThrowWeapon( stateContext, scriptInterface ) )
			{
				return false;
			}
			if( GameObject.IsCooldownActive( scriptInterface.owner, 'Block' ) )
			{
				return false;
			}
			if( GameObject.IsCooldownActive( scriptInterface.owner, 'Deflect' ) )
			{
				return false;
			}
			if( !( IsBlockHeld( stateContext, scriptInterface ) ) )
			{
				return false;
			}
			return true;
		}
		return false;
	}

	protected export const function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( ShouldEnterSafe( stateContext, scriptInterface ) )
		{
			return true;
		}
		if( ShouldInterruptHoldStates( stateContext, scriptInterface ) )
		{
			return true;
		}
		if( AnyMeleeAttackPressed( scriptInterface ) )
		{
			return true;
		}
		if( IsBlockHeld( stateContext, scriptInterface ) )
		{
			return false;
		}
		if( GetInStateTime() >= GetStaticFloatParameterDefault( "minDuration", -1.0 ) )
		{
			return true;
		}
		return false;
	}

}

class MeleeBlockEvents extends MeleeRumblingEvents
{
	var blockStatFlag : gameStatModifierData;

	public override function GetIntensity() : String
	{
		return "medium";
	}

	public export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var ownerID : StatsObjectID;
		ownerID = scriptInterface.executionOwnerEntityID;
		ClearInputBuffer( stateContext );
		SetMeleeAttackPressCount( stateContext, scriptInterface );
		SetIsBlocking( stateContext, true );
		scriptInterface.PushAnimationEvent( 'Block' );
		stateContext.SetTemporaryBoolParameter( 'InterruptSprint', true, true );
		blockStatFlag = RPGManager.CreateStatModifier( gamedataStatType.IsBlocking, gameStatModifierType.Additive, 1.0 );
		scriptInterface.GetStatsSystem().AddModifier( ownerID, blockStatFlag );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Melee, ( ( Int32 )( gamePSMMelee.Block ) ) );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.Block ) ) );
		super.OnEnter( stateContext, scriptInterface );
	}

	public export override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var ownerID : StatsObjectID;
		ownerID = scriptInterface.executionOwnerEntityID;
		scriptInterface.GetStatsSystem().RemoveModifier( ownerID, blockStatFlag );
		GameObject.StartCooldown( scriptInterface.owner, 'Block', GetStaticFloatParameterDefault( "cooldown", -1.0 ), true );
		super.OnExit( stateContext, scriptInterface );
	}

}

class MeleeTargetingDecisions extends MeleeTransition
{

	protected export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( CanThrowWeaponObject( scriptInterface.executionOwner, GetWeaponObject( scriptInterface ) ) ) )
		{
			return false;
		}
		if( !( IsBlockHeld( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		return true;
	}

	protected const function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( ShouldInterruptHoldStates( stateContext, scriptInterface ) )
		{
			return true;
		}
		if( !( EnterCondition( stateContext, scriptInterface ) ) )
		{
			return true;
		}
		if( MeleeAttackPressed( scriptInterface ) )
		{
			return true;
		}
		return false;
	}

}

class MeleeTargetingEvents extends MeleeEventsTransition
{

	public override function OnUpdate( timeDelta : Float, stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		super.OnUpdate( timeDelta, stateContext, scriptInterface );
	}

	public override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var aimAssistRecord : AimAssistMelee_Record;
		aimAssistRecord = GetAimAssistMeleeRecord( scriptInterface );
		SetIsTargeting( stateContext, true );
		scriptInterface.PushAnimationEvent( 'Targeting' );
		ResetAttackNumber( stateContext );
		stateContext.SetTemporaryBoolParameter( 'InterruptSprint', true, true );
		if( aimAssistRecord && aimAssistRecord.AimSnapOnAim() )
		{
			scriptInterface.GetTargetingSystem().AimSnap( scriptInterface.executionOwner );
		}
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Melee, ( ( Int32 )( gamePSMMelee.Block ) ) );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.Targeting ) ) );
		super.OnEnter( stateContext, scriptInterface );
		GameInstance.GetAudioSystem( scriptInterface.owner.GetGame() ).AddTriggerEffect( 'te_wea_melee_throw', 'PSM_MeleeTargetingOnEnter_trigger' );
	}

}

class MeleeThrowAttackDecisions extends MeleeAttackGenericDecisions
{

	protected const override function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( HasAttackRecord( scriptInterface ) ) )
		{
			return false;
		}
		if( !( IsBlockHeld( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		if( !( MeleeAttackPressed( scriptInterface ) ) )
		{
			return false;
		}
		if( GetWeaponObject( scriptInterface ).WeaponHasTag( 'Throwable' ) && !( CanThrowWeapon( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		return true;
	}

}

class MeleeThrowAttackEvents extends MeleeAttackGenericEvents
{
	var m_projectileThrown : Bool;
	default m_projectileThrown = false;
	var m_targetObject : weak< GameObject >;

	protected override final function GetAttackType() : EMeleeAttackType
	{
		return EMeleeAttackType.Throw;
	}

	protected function EnableLockOnTarget( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var aimRequestData : AimRequest;
		aimRequestData = GetBlockLookAtParams();
		scriptInterface.GetTargetingSystem().LookAt( scriptInterface.executionOwner, aimRequestData );
	}

	public override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var aimAssistRecord : AimAssistMelee_Record;
		aimAssistRecord = GetAimAssistMeleeRecord( scriptInterface );
		m_projectileThrown = false;
		if( CheckItemType( scriptInterface, gamedataItemType.Cyb_NanoWires ) )
		{
			m_targetObject = GetNanoWireTargetObject( scriptInterface );
		}
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.ThrowAttack ) ) );
		EnableLockOnTarget( stateContext, scriptInterface );
		if( aimAssistRecord && aimAssistRecord.AimSnapOnThrow() )
		{
			scriptInterface.GetTargetingSystem().AimSnap( scriptInterface.executionOwner );
		}
		super.OnEnter( stateContext, scriptInterface );
	}

	public override function OnUpdate( timeDelta : Float, stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var attackData : MeleeAttackData;
		var isItemKnife : Bool;
		var isItemNanowire : Bool;
		var isValidNanowireAttack : Bool;
		super.OnUpdate( timeDelta, stateContext, scriptInterface );
		attackData = GetAttackData( stateContext );
		isItemKnife = CheckItemType( scriptInterface, gamedataItemType.Wea_Knife );
		isItemNanowire = CheckItemType( scriptInterface, gamedataItemType.Cyb_NanoWires );
		isValidNanowireAttack = isItemNanowire && m_targetObject;
		if( ( ( GetInStateTime() > attackData.attackEffectDelay ) && !( m_projectileThrown ) ) && ( isValidNanowireAttack || isItemKnife ) )
		{
			m_projectileThrown = true;
			if( isItemKnife )
			{
				SetIsThrowReloading( stateContext, true );
				SendAnimFeatureData( stateContext, scriptInterface );
				SpawnMeleeWeaponProjectile( scriptInterface );
				if( CheckItemType( scriptInterface, gamedataItemType.Wea_Knife ) )
				{
					ApplyKnifeThrowCooldown( stateContext, scriptInterface );
				}
			}
		}
	}

	protected function UpdateNanoWireIKState( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		if( GetInStateTime() >= GetStaticFloatParameterDefault( "timeToEnableWireIK", 0.54000002 ) )
		{
			EnableNanoWireIK( scriptInterface, true );
		}
		if( GetInStateTime() >= GetStaticFloatParameterDefault( "timeToDisableWireIK", 1.20000005 ) )
		{
			DisableNanoWireIK( scriptInterface );
		}
	}

	protected function EnableNanoWireIK( scriptInterface : StateGameScriptInterface, enable : Bool, optional setPosition : Bool )
	{
		var slotPosition : Vector4;
		var targetPosition : Vector4;
		var wireTargetSlot : CName;
		if( m_targetObject )
		{
			wireTargetSlot = GetStaticCNameParameterDefault( "wireTargetSlot", 'wireTargetSlot' );
			AIActionHelper.GetTargetSlotPosition( m_targetObject, wireTargetSlot, slotPosition );
			targetPosition = slotPosition;
		}
		else
		{
			targetPosition = Vector4( 0.0, 0.0, 0.0, 1.0 );
		}
		UpdateNanoWireEndPositionAnimFeature( scriptInterface, GetStaticCNameParameterDefault( "ikAnimFeatureName", 'ikLeftNanoWire' ), enable, setPosition, targetPosition );
	}

	public override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		DisableNanoWireIK( scriptInterface );
		super.OnExit( stateContext, scriptInterface );
	}

	protected function ApplyKnifeThrowCooldown( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var reloadTime : Float;
		reloadTime = GameInstance.GetStatsSystem( scriptInterface.GetGame() ).GetStatValue( scriptInterface.owner.GetEntityID(), gamedataStatType.ThrowRecovery );
		SetThrowReloadTime( stateContext, reloadTime );
	}

}

class MeleeThrowReloadDecisions extends MeleeTransition
{

	protected export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var throwReloading : StateResultBool;
		throwReloading = stateContext.GetPermanentBoolParameter( 'isThrowReloading' );
		if( GetWeaponObject( scriptInterface ).WeaponHasTag( 'Throwable' ) && throwReloading.value )
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	protected export const function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsThrownWeaponReloading( stateContext, scriptInterface ) || ( GetInStateTime() <= TDB.GetFloat( T"Items.Base_Knife.minimumReloadTime", 2.0 ) ) )
		{
			return false;
		}
		return true;
	}

}

class MeleeThrowReloadEvents extends MeleeEventsTransition
{
	var m_isSwitchingWeapon : Bool;

	public override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		SetIsThrowReloading( stateContext, true );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Melee, ( ( Int32 )( gamePSMMelee.Default ) ) );
		super.OnEnter( stateContext, scriptInterface );
		GameInstance.GetAudioSystem( scriptInterface.owner.GetGame() ).AddTriggerEffect( 'te_wea_melee_reload', 'PSM_MeleeReloadOnEnter_feedback' );
	}

	public override function OnUpdate( timeDelta : Float, stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		if( ( stateContext.IsStateActive( 'UpperBody', 'aimingState' ) || IsBlockHeld( stateContext, scriptInterface ) ) || MeleeAttackPressed( scriptInterface ) )
		{
			if( !( m_isSwitchingWeapon ) && ( GetInStateTime() > TDB.GetFloat( T"Items.Base_Knife.knifeWeaponSwapOnAttackDelay", 0.40000001 ) ) )
			{
				m_isSwitchingWeapon = true;
				EquipNextWeapon( scriptInterface.executionOwner );
			}
		}
	}

	public override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var weaponEquipAnimFeature : AnimFeature_EquipType;
		weaponEquipAnimFeature = new AnimFeature_EquipType;
		SetIsThrowReloading( stateContext, false );
		weaponEquipAnimFeature.firstEquip = false;
		scriptInterface.SetAnimationParameterFeature( 'WeaponEquipType', weaponEquipAnimFeature );
		super.OnExit( stateContext, scriptInterface );
		GameInstance.GetAudioSystem( scriptInterface.owner.GetGame() ).RemoveTriggerEffect( 'PSM_MeleeTargetingOnEnter_trigger' );
		GameInstance.GetAudioSystem( scriptInterface.owner.GetGame() ).RemoveTriggerEffect( 'PSM_MeleeReloadOnEnter_feedback' );
	}

	private function EquipNextWeapon( owner : GameObject )
	{
		var equipmentManipulationRequest : EquipmentSystemWeaponManipulationRequest;
		var eqSystem : weak< EquipmentSystem >;
		equipmentManipulationRequest = new EquipmentSystemWeaponManipulationRequest;
		eqSystem = ( ( EquipmentSystem )( GameInstance.GetScriptableSystemsContainer( owner.GetGame() ).Get( 'EquipmentSystem' ) ) );
		equipmentManipulationRequest.requestType = EquipmentManipulationAction.CycleNextWeaponWheelItem;
		equipmentManipulationRequest.owner = owner;
		eqSystem.QueueRequest( equipmentManipulationRequest );
	}

}

class MeleeLeapDecisions extends MeleeTransition
{

	protected export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var performCheck : Bool;
		if( !( scriptInterface.IsOnGround() ) )
		{
			return false;
		}
		if( !( scriptInterface.HasStatFlag( gamedataStatType.CanMeleeLeap ) ) )
		{
			return false;
		}
		if( !( GetStaticBoolParameterDefault( "canLeapWithoutTarget", false ) ) && !( GetTargetObject( scriptInterface, GetStaticFloatParameterDefault( "maxDistToTarget", 5.0 ) ) ) )
		{
			return false;
		}
		if( GetTargetObject( scriptInterface, GetStaticFloatParameterDefault( "minDistToTarget", 2.0 ) ) )
		{
			return false;
		}
		if( !( CheckLeapCollision( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		if( IsInMeleeState( stateContext, 'meleeChargedHold' ) && MeleeAttackReleased( scriptInterface ) )
		{
			performCheck = true;
		}
		if( stateContext.IsStateActive( 'Locomotion', 'sprint' ) || ( scriptInterface.GetOwnerStateVectorParameterFloat( physicsStateValue.LinearSpeed ) > 5.0 ) )
		{
			if( AnyMeleeAttackPressed( scriptInterface ) )
			{
				performCheck = true;
			}
		}
		if( !( performCheck ) )
		{
			return false;
		}
		return true;
	}

	protected const function CheckLeapCollision( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var geometryDescription : GeometryDescriptionQuery;
		var queryFilter : QueryFilter;
		var geometryDescriptionResult : GeometryDescriptionResult;
		var cameraWorldTransform : Transform;
		cameraWorldTransform = scriptInterface.GetCameraWorldTransform();
		QueryFilter.AddGroup( queryFilter, 'Static' );
		QueryFilter.AddGroup( queryFilter, 'PlayerBlocker' );
		geometryDescription = new GeometryDescriptionQuery;
		geometryDescription.refPosition = Transform.GetPosition( cameraWorldTransform );
		geometryDescription.refDirection = Transform.GetForward( cameraWorldTransform );
		geometryDescription.filter = queryFilter;
		geometryDescription.primitiveDimension = Vector4( 0.1, 0.1, 0.1, 0.0 );
		geometryDescription.maxDistance = 5.0;
		geometryDescription.maxExtent = 5.0;
		geometryDescription.probingPrecision = 0.05;
		geometryDescription.probingMaxDistanceDiff = 5.0;
		geometryDescription.AddFlag( worldgeometryDescriptionQueryFlags.DistanceVector );
		geometryDescriptionResult = scriptInterface.GetSpatialQueriesSystem().GetGeometryDescriptionSystem().QueryExtents( geometryDescription );
		if( geometryDescriptionResult.queryStatus == worldgeometryDescriptionQueryStatus.NoGeometry )
		{
			return true;
		}
		return false;
	}

	protected const function ToMeleeStrongAttack( stateContext : StateContext, scriptInterface : StateGameScriptInterface ) : Bool
	{
		var result : StateResultFloat;
		result = stateContext.GetConditionFloatParameter( 'LeapExitTime' );
		if( result.valid )
		{
			return GetInStateTime() >= result.value;
		}
		else
		{
			return false;
		}
	}

	protected const function ToMeleeIdle( stateContext : StateContext, scriptInterface : StateGameScriptInterface ) : Bool
	{
		var result : StateResultFloat;
		result = stateContext.GetConditionFloatParameter( 'LeapExitTime' );
		if( result.valid )
		{
			return GetInStateTime() >= result.value;
		}
		else
		{
			return false;
		}
	}

}

class MeleeLeapEvents extends MeleeEventsTransition
{
	var m_textLayerId : Uint32;

	public override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		if( !( LeapToTarget( stateContext, scriptInterface ) ) )
		{
			Leap( stateContext, scriptInterface );
		}
		super.OnEnter( stateContext, scriptInterface );
	}

	public override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		ClearDebugText( scriptInterface, m_textLayerId );
		super.OnExit( stateContext, scriptInterface );
	}

	public override function OnForcedExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		ClearDebugText( scriptInterface, m_textLayerId );
		super.OnForcedExit( stateContext, scriptInterface );
	}

	private function LeapToTarget( stateContext : StateContext, scriptInterface : StateGameScriptInterface ) : Bool
	{
		var adjustPosition : Vector4;
		var vecToTarget : Vector4;
		var safetyDisplacement : Vector4;
		var scaledSafetyDisplacement : Vector4;
		var playerPuppetOrientation : Quaternion;
		var horizontalDistanceFromTarget : Float;
		var additionalHorizontalDistance : Float;
		var target : GameObject;
		var slideDuration : Float;
		var leapAngle : EulerAngles;
		var exitTime : Float;
		target = GetTargetObject( scriptInterface, GetStaticFloatParameterDefault( "maxDistToTarget", 5.0 ) );
		if( !( target ) )
		{
			return false;
		}
		vecToTarget = target.GetWorldPosition() - scriptInterface.executionOwner.GetWorldPosition();
		playerPuppetOrientation = scriptInterface.executionOwner.GetWorldOrientation();
		leapAngle = Vector4.ToRotation( vecToTarget );
		if( -( leapAngle.Pitch ) > GetStaticFloatParameterDefault( "leapMaxPitch", 45.0 ) )
		{
			return false;
		}
		if( GetStaticBoolParameterDefault( "useSafetyDisplacement", false ) )
		{
			safetyDisplacement.Y = GetStaticFloatParameterDefault( "safetyDisplacement", 2.0 );
			if( vecToTarget.Z > 0.0 )
			{
				safetyDisplacement.Y = safetyDisplacement.Y * -1.0;
			}
			horizontalDistanceFromTarget = Vector4.Length2D( vecToTarget );
			additionalHorizontalDistance = MaxF( safetyDisplacement.Y - horizontalDistanceFromTarget, 0.0 );
			scaledSafetyDisplacement = safetyDisplacement * additionalHorizontalDistance;
			adjustPosition = Quaternion.Transform( playerPuppetOrientation, scaledSafetyDisplacement );
		}
		slideDuration = CalculateAdjustmentDuration( Vector4.Length( vecToTarget ) );
		exitTime = slideDuration - GetStaticFloatParameterDefault( "attackStartupDuration", 0.0 );
		stateContext.SetConditionFloatParameter( 'LeapExitTime', exitTime, true );
		RequestPlayerPositionAdjustment( stateContext, scriptInterface, target, slideDuration, 0.89999998, -1.0, adjustPosition, true );
		return true;
	}

	private function Leap( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var adjustPosition : Vector4;
		var vecToTarget : Vector4;
		var slideDuration : Float;
		var cameraWorldTransform : Transform;
		var leapAngle : EulerAngles;
		var exitTime : Float;
		cameraWorldTransform = scriptInterface.GetCameraWorldTransform();
		leapAngle = Transform.ToEulerAngles( cameraWorldTransform );
		if( leapAngle.Pitch > GetStaticFloatParameterDefault( "noTargetMaxPitch", 45.0 ) )
		{
			leapAngle.Pitch = GetStaticFloatParameterDefault( "noTargetMaxPitch", 45.0 );
			Transform.SetOrientationEuler( cameraWorldTransform, leapAngle );
		}
		vecToTarget = Transform.GetForward( cameraWorldTransform ) * GetStaticFloatParameterDefault( "noTargetLeapDistance", 5.0 );
		adjustPosition = scriptInterface.executionOwner.GetWorldPosition() + vecToTarget;
		slideDuration = CalculateAdjustmentDuration( GetStaticFloatParameterDefault( "noTargetLeapDistance", 5.0 ) );
		exitTime = slideDuration - GetStaticFloatParameterDefault( "attackStartupDuration", 0.0 );
		stateContext.SetConditionFloatParameter( 'LeapExitTime', exitTime, true );
		RequestPlayerPositionAdjustment( stateContext, scriptInterface, NULL, slideDuration, 0.0, -1.0, adjustPosition, true );
	}

	private function CalculateAdjustmentDuration( distance : Float ) : Float
	{
		var minDist, maxDist : Float;
		var minDur, maxDur : Float;
		var duration : Float;
		minDist = GetStaticFloatParameterDefault( "minDistToTarget", 1.0 );
		maxDist = GetStaticFloatParameterDefault( "maxDistToTarget", 1.0 );
		minDur = GetStaticFloatParameterDefault( "minAdjustmentDuration", 1.0 );
		maxDur = GetStaticFloatParameterDefault( "maxAdjustmentDuration", 1.0 );
		distance -= minDist;
		maxDist -= minDist;
		duration = LerpF( distance / maxDist, minDur, maxDur, true );
		return duration;
	}

}

class MeleeDashDecisions extends MeleeTransition
{

	protected export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var performCheck : Bool;
		if( stateContext.IsStateActive( 'Locomotion', 'sprint' ) )
		{
			performCheck = true;
		}
		if( !( scriptInterface.IsOnGround() ) && ( Get2DLinearSpeed( scriptInterface ) > 5.0 ) )
		{
			performCheck = true;
		}
		if( !( AnyMeleeAttackPressed( scriptInterface ) ) )
		{
			performCheck = false;
		}
		if( !( performCheck ) )
		{
			return false;
		}
		if( !( scriptInterface.IsOnGround() ) )
		{
			return false;
		}
		if( !( HasWeaponStatFlag( scriptInterface, gamedataStatType.CanWeaponDash ) ) )
		{
			return false;
		}
		if( !( scriptInterface.HasStatFlag( gamedataStatType.CanMeleeDash ) ) )
		{
			return false;
		}
		if( !( GetWeaponObject( scriptInterface ).GetAttack( 'MeleeSprintAttack0' ) ) )
		{
			return false;
		}
		if( GetTargetObject( scriptInterface, GetStaticFloatParameterDefault( "minTargetDistanceToDash", 2.0 ) ) )
		{
			return false;
		}
		if( !( CheckDashCollision( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		return true;
	}

	protected const function CheckDashCollision( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var geometryDescription : GeometryDescriptionQuery;
		var staticQueryFilter : QueryFilter;
		var geometryDescriptionResult : GeometryDescriptionResult;
		var cameraWorldTransform : Transform;
		cameraWorldTransform = scriptInterface.GetCameraWorldTransform();
		QueryFilter.AddGroup( staticQueryFilter, 'Static' );
		geometryDescription = new GeometryDescriptionQuery;
		geometryDescription.refPosition = Transform.GetPosition( cameraWorldTransform );
		geometryDescription.refDirection = Transform.GetForward( cameraWorldTransform );
		geometryDescription.filter = staticQueryFilter;
		geometryDescription.primitiveDimension = Vector4( 0.1, 0.1, 0.1, 0.0 );
		geometryDescription.maxDistance = 5.0;
		geometryDescription.maxExtent = 5.0;
		geometryDescription.probingPrecision = 0.05;
		geometryDescription.probingMaxDistanceDiff = 5.0;
		geometryDescription.AddFlag( worldgeometryDescriptionQueryFlags.DistanceVector );
		geometryDescriptionResult = scriptInterface.GetSpatialQueriesSystem().GetGeometryDescriptionSystem().QueryExtents( geometryDescription );
		if( geometryDescriptionResult.queryStatus == worldgeometryDescriptionQueryStatus.NoGeometry )
		{
			return true;
		}
		return false;
	}

	protected const function ToMeleeSprintAttack( stateContext : StateContext, scriptInterface : StateGameScriptInterface ) : Bool
	{
		var attackData : MeleeAttackData;
		var duration : Float;
		if( GetWeaponObject( scriptInterface ).GetAttack( 'MeleeSprintAttack0' ) )
		{
			duration = GetStaticFloatParameterDefault( "slideDuration", 1.0 ) - attackData.attackEffectDelay;
		}
		else
		{
			duration = GetStaticFloatParameterDefault( "timeToStartAttack", 1.0 );
		}
		if( GetInStateTime() >= duration )
		{
			return true;
		}
		return false;
	}

	protected const function ToMeleeIdle( stateContext : StateContext, scriptInterface : StateGameScriptInterface ) : Bool
	{
		return GetInStateTime() >= GetStaticFloatParameterDefault( "timeout", 1.0 );
	}

}

class MeleeDashEvents extends MeleeEventsTransition
{

	public override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		if( !( DashToTarget( stateContext, scriptInterface ) ) )
		{
			Dash( stateContext, scriptInterface );
		}
		super.OnEnter( stateContext, scriptInterface );
	}

	private function DashToTarget( stateContext : StateContext, scriptInterface : StateGameScriptInterface ) : Bool
	{
		var adjustPosition : Vector4;
		var vecToTarget : Vector4;
		var safetyDisplacement : Vector4;
		var scaledSafetyDisplacement : Vector4;
		var playerPuppetOrientation : Quaternion;
		var horizontalDistanceFromTarget : Float;
		var additionalHorizontalDistance : Float;
		var target : GameObject;
		var slideDuration : Float;
		var leapAngle : EulerAngles;
		target = GetTargetObject( scriptInterface, GetStaticFloatParameterDefault( "maxDistToAquireTarget", 5.0 ) );
		if( !( target ) )
		{
			return false;
		}
		vecToTarget = target.GetWorldPosition() - scriptInterface.executionOwner.GetWorldPosition();
		playerPuppetOrientation = scriptInterface.executionOwner.GetWorldOrientation();
		leapAngle = Vector4.ToRotation( vecToTarget );
		if( -( leapAngle.Pitch ) > GetStaticFloatParameterDefault( "dashMaxPitch", 45.0 ) )
		{
			return false;
		}
		safetyDisplacement.Y = 2.0;
		if( vecToTarget.Z > 0.0 )
		{
			safetyDisplacement.Y = safetyDisplacement.Y * -1.0;
		}
		horizontalDistanceFromTarget = Vector4.Length2D( vecToTarget );
		additionalHorizontalDistance = MaxF( safetyDisplacement.Y - horizontalDistanceFromTarget, 0.0 );
		scaledSafetyDisplacement = safetyDisplacement * additionalHorizontalDistance;
		adjustPosition = Quaternion.Transform( playerPuppetOrientation, scaledSafetyDisplacement );
		slideDuration = GetStaticFloatParameterDefault( "slideDuration", 0.30000001 );
		RequestPlayerPositionAdjustment( stateContext, scriptInterface, target, slideDuration, 0.89999998, -1.0, adjustPosition );
		return true;
	}

	private function Dash( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var adjustPosition : Vector4;
		var vecToTarget : Vector4;
		var slideDuration : Float;
		var cameraWorldTransform : Transform;
		var leapAngle : EulerAngles;
		cameraWorldTransform = scriptInterface.GetCameraWorldTransform();
		leapAngle = Transform.ToEulerAngles( cameraWorldTransform );
		if( leapAngle.Pitch > GetStaticFloatParameterDefault( "noTargetMaxPitch", 45.0 ) )
		{
			leapAngle.Pitch = GetStaticFloatParameterDefault( "noTargetMaxPitch", 45.0 );
			Transform.SetOrientationEuler( cameraWorldTransform, leapAngle );
		}
		vecToTarget = Transform.GetForward( cameraWorldTransform ) * GetStaticFloatParameterDefault( "noTargetDashDistance", 5.0 );
		adjustPosition = scriptInterface.executionOwner.GetWorldPosition() + vecToTarget;
		slideDuration = GetStaticFloatParameterDefault( "slideDuration", 0.30000001 );
		RequestPlayerPositionAdjustment( stateContext, scriptInterface, NULL, slideDuration, 0.0, -1.0, adjustPosition );
	}

}

class MeleeBlockAttackDecisions extends MeleeAttackGenericDecisions
{

	protected export const override function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( IsBlockHeld( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		if( !( AnyMeleeAttackPressed( scriptInterface ) || stateContext.GetConditionBool( 'LightMeleeAttackPressed' ) ) )
		{
			return false;
		}
		if( !( HasAttackRecord( scriptInterface ) ) )
		{
			return false;
		}
		return true;
	}

	protected export const override function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var attackData : MeleeAttackData;
		var inStateTime : Float;
		attackData = GetAttackData( stateContext );
		inStateTime = GetInStateTime();
		if( IsBlockHeld( stateContext, scriptInterface ) )
		{
			if( ( attackData.blockTransitionTime > 0.0 ) && ( inStateTime >= attackData.blockTransitionTime ) )
			{
				return true;
			}
		}
		if( stateContext.GetConditionBool( 'LightMeleeAttackPressed' ) && ( inStateTime >= attackData.attackWindowClosed ) )
		{
			return true;
		}
		if( inStateTime >= attackData.idleTransitionTime )
		{
			return true;
		}
		return false;
	}

}

class MeleeBlockAttackEvents extends MeleeAttackGenericEvents
{

	protected override final function GetAttackType() : EMeleeAttackType
	{
		return EMeleeAttackType.Block;
	}

	public export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		ResetAttackNumber( stateContext );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.BlockAttack ) ) );
		super.OnEnter( stateContext, scriptInterface );
	}

	public export override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		super.OnExit( stateContext, scriptInterface );
	}

}

class MeleeCrouchAttackDecisions extends MeleeAttackGenericDecisions
{

	protected export const override function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( stateContext.IsStateActive( 'Locomotion', 'crouch' ) || stateContext.IsStateActive( 'Locomotion', 'slide' ) ) )
		{
			return false;
		}
		if( !( WantsToLightAttack( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		if( !( HasAttackRecord( scriptInterface ) ) )
		{
			return false;
		}
		return true;
	}

}

class MeleeCrouchAttackEvents extends MeleeAttackGenericEvents
{

	protected override final function GetAttackType() : EMeleeAttackType
	{
		return EMeleeAttackType.Crouch;
	}

	public export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		ResetAttackNumber( stateContext );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.CrouchAttack ) ) );
		super.OnEnter( stateContext, scriptInterface );
	}

	public export override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		super.OnExit( stateContext, scriptInterface );
	}

}

class MeleeJumpAttackDecisions extends MeleeAttackGenericDecisions
{

	protected export const override function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( ( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.Locomotion ) == ( ( Int32 )( gamePSMLocomotionStates.Jump ) ) ) || stateContext.IsStateActive( 'Locomotion', 'fall' ) ) )
		{
			return false;
		}
		if( !( WantsToLightAttack( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		if( !( super.EnterCondition( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		return true;
	}

}

class MeleeJumpAttackEvents extends MeleeAttackGenericEvents
{

	protected override final function GetAttackType() : EMeleeAttackType
	{
		return EMeleeAttackType.Jump;
	}

	public export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		ResetAttackNumber( stateContext );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.JumpAttack ) ) );
		super.OnEnter( stateContext, scriptInterface );
	}

	public export override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		super.OnExit( stateContext, scriptInterface );
	}

}

class MeleeSprintAttackDecisions extends MeleeAttackGenericDecisions
{

	protected export const override function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var performCheck : Bool;
		if( stateContext.IsStateActive( 'Locomotion', 'sprint' ) )
		{
			performCheck = true;
		}
		if( !( scriptInterface.IsOnGround() ) && ( Get2DLinearSpeed( scriptInterface ) > 5.0 ) )
		{
			performCheck = true;
		}
		if( !( performCheck ) )
		{
			return false;
		}
		if( !( WantsToLightAttack( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		if( !( HasAttackRecord( scriptInterface ) ) )
		{
			return false;
		}
		return true;
	}

}

class MeleeSprintAttackEvents extends MeleeAttackGenericEvents
{

	protected override final function GetAttackType() : EMeleeAttackType
	{
		return EMeleeAttackType.Sprint;
	}

	public function OnEnterFromMeleeDash( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		OnEnter( stateContext, scriptInterface );
		m_blockImpulseCreation = true;
	}

	public override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		ResetAttackNumber( stateContext );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.SprintAttack ) ) );
		super.OnEnter( stateContext, scriptInterface );
	}

	public override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		super.OnExit( stateContext, scriptInterface );
	}

}

class MeleeEquipAttackDecisions extends MeleeAttackGenericDecisions
{

	protected export const override function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( EquipAttackCondition( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		if( !( HasAttackRecord( scriptInterface ) ) )
		{
			return false;
		}
		return true;
	}

}

class MeleeEquipAttackEvents extends MeleeAttackGenericEvents
{

	protected override final function GetAttackType() : EMeleeAttackType
	{
		return EMeleeAttackType.Equip;
	}

	public override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		ResetAttackNumber( stateContext );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.MeleeWeapon, ( ( Int32 )( gamePSMMeleeWeapon.EquipAttack ) ) );
		super.OnEnter( stateContext, scriptInterface );
	}

	public override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		super.OnExit( stateContext, scriptInterface );
	}

}

enum EMeleeAttackType
{
	Combo = 0,
	Strong = 1,
	Final = 2,
	Block = 3,
	Safe = 4,
	Slide = 5,
	Crouch = 6,
	Jump = 7,
	Sprint = 8,
	Fall = 9,
	Throw = 10,
	Dodge = 11,
	Equip = 12,
}

enum EMoveAssistLevel
{
	Off = 0,
	SpecialAttacks = 1,
	AllAttacks = 2,
}

enum meleeMoveDirection
{
	Forward = 0,
	Right = 1,
	Back = 2,
	Left = 3,
}

enum meleeQueuedAttack
{
	Block = 0,
	Combo = 1,
	Crouch = 2,
	Final = 3,
	Jump = 4,
	Safe = 5,
	Sprint = 6,
	Strong = 7,
	Throw = 8,
}

