abstract class VehicleTransition extends DefaultTransition
{
	const var stateMachineInitData : weak< VehicleTransitionInitData >;

	public static function CanEnterDriverCombat() : Bool
	{
		return TDB.GetBool( T"player.vehicle.canEnterDriverCombat", false );
	}

	protected const function IsPlayerAllowedToEnterCombat( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsNoCombatActionsForced( scriptInterface ) )
		{
			return false;
		}
		if( StatusEffectSystem.ObjectHasStatusEffectWithTag( scriptInterface.executionOwner, 'VehicleCombat' ) )
		{
			return true;
		}
		return true;
	}

	protected const function IsPlayerAllowedToExitCombat( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( StatusEffectSystem.ObjectHasStatusEffectWithTag( scriptInterface.executionOwner, 'VehicleCombatBlockExit' ) )
		{
			return false;
		}
		return true;
	}

	protected const function IsPlayerAllowedToExitVehicle( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( StatusEffectSystem.ObjectHasStatusEffectWithTag( scriptInterface.executionOwner, 'VehicleScene' ) )
		{
			return false;
		}
		if( StatusEffectSystem.ObjectHasStatusEffectWithTag( scriptInterface.executionOwner, 'VehicleCombat' ) )
		{
			return false;
		}
		if( StatusEffectSystem.ObjectHasStatusEffectWithTag( scriptInterface.executionOwner, 'VehicleBlockExit' ) )
		{
			return false;
		}
		if( IsInPhotoMode( scriptInterface ) )
		{
			return false;
		}
		if( GameInstance.GetRacingSystem( scriptInterface.GetGame() ).IsRaceInProgress() )
		{
			return false;
		}
		return true;
	}

	protected const function PlayerWantsToExitVehicle( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var stateTime : Float;
		if( scriptInterface.IsActionJustHeld( 'Exit' ) )
		{
			stateTime = GetInStateTime();
			if( stateTime >= 0.30000001 )
			{
				return true;
			}
		}
		return false;
	}

	protected function SetOneHandedFirearmsGameplayRestriction( scriptInterface : StateGameScriptInterface, shouleAdd : Bool )
	{
		if( shouleAdd == true )
		{
			StatusEffectHelper.ApplyStatusEffect( scriptInterface.executionOwner, T"GameplayRestriction.OneHandedFirearms" );
		}
		else
		{
			StatusEffectHelper.RemoveStatusEffect( scriptInterface.executionOwner, T"GameplayRestriction.OneHandedFirearms" );
		}
	}

	protected function SetFirearmsGameplayRestriction( scriptInterface : StateGameScriptInterface, shouleAdd : Bool )
	{
		if( shouleAdd == true )
		{
			StatusEffectHelper.ApplyStatusEffect( scriptInterface.executionOwner, T"GameplayRestriction.Firearms" );
		}
		else
		{
			StatusEffectHelper.RemoveStatusEffect( scriptInterface.executionOwner, T"GameplayRestriction.Firearms" );
		}
	}

	protected const function IsDriverInVehicle( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return scriptInterface.IsDriverInVehicle();
	}

	protected const function IsPassengerInVehicle( const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return scriptInterface.IsPassengerInVehicle();
	}

	protected function SendAnimFeature( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var animFeature : AnimFeature_VehicleData;
		var vehicleDataPackage : VehicleDataPackage_Record;
		animFeature = new AnimFeature_VehicleData;
		vehicleDataPackage = GetVehicleDataPackage( stateContext );
		animFeature.isInVehicle = stateContext.GetBoolParameter( 'isInVehicle', true );
		animFeature.isDriver = stateContext.GetBoolParameter( 'isDriver', true );
		animFeature.vehType = stateContext.GetIntParameter( 'vehType', true );
		animFeature.vehSlot = stateContext.GetIntParameter( 'vehSlot', true );
		animFeature.isInCombat = stateContext.GetBoolParameter( 'isInVehCombat', true );
		animFeature.isInWindowCombat = stateContext.GetBoolParameter( 'isInVehWindowCombat', true );
		animFeature.isInDriverCombat = stateContext.GetBoolParameter( 'isInDriverCombat', true );
		animFeature.vehClass = stateContext.GetIntParameter( 'vehClass', true );
		animFeature.isEnteringCombat = stateContext.GetBoolParameter( 'isEnteringCombat', true );
		animFeature.enteringCombatDuration = vehicleDataPackage.ToCombat();
		animFeature.isExitingCombat = stateContext.GetBoolParameter( 'isExitingCombat', true );
		animFeature.exitingCombatDuration = vehicleDataPackage.FromCombat();
		animFeature.isEnteringVehicle = stateContext.GetBoolParameter( 'isEnteringVehicle', true );
		animFeature.isExitingVehicle = stateContext.GetBoolParameter( 'isExitingVehicle', true );
		animFeature.isWorldRenderPlane = stateContext.GetBoolParameter( 'isWorldRenderPlane', true );
		scriptInterface.SetAnimationParameterFeature( 'VehicleData', animFeature, scriptInterface.executionOwner );
		scriptInterface.SetAnimationParameterFeature( 'VehicleData', animFeature );
	}

	protected function ResetAnimFeature( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var animFeature : AnimFeature_VehicleData;
		animFeature = new AnimFeature_VehicleData;
		scriptInterface.SetAnimationParameterFeature( 'VehicleData', animFeature, scriptInterface.executionOwner );
		scriptInterface.SetAnimationParameterFeature( 'VehicleData', animFeature );
	}

	protected function ResetVehParams( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		SetIsInVehicle( stateContext, false );
		SetIsVehicleDriver( stateContext, false );
		SetVehicleType( stateContext, 0 );
		SetIsInVehicleCombat( stateContext, false );
		SetIsInVehicleWindowCombat( stateContext, false );
		SetIsInVehicleDriverCombat( stateContext, false );
		SetVehicleClass( stateContext, 0 );
		SetIsEnteringCombat( stateContext, false );
		SetIsExitingCombat( stateContext, false );
		SetIsWorldRenderPlane( stateContext, false );
		SetIsCar( stateContext, false );
		SetWasStolen( stateContext, false );
		stateContext.SetPermanentIntParameter( 'vehSlot', 0, true );
		stateContext.SetPermanentIntParameter( 'vehUnmountDir', 0, true );
	}

	protected function SendIsCar( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var animFeature : AnimFeature_VehiclePassenger;
		animFeature = new AnimFeature_VehiclePassenger;
		animFeature.isCar = stateContext.GetBoolParameter( 'isCar', true );
		scriptInterface.SetAnimationParameterFeature( 'VehiclePassenger', animFeature, scriptInterface.executionOwner );
	}

	protected function ResetIsCar( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var animFeature : AnimFeature_VehiclePassenger;
		animFeature = new AnimFeature_VehiclePassenger;
		animFeature.isCar = false;
		scriptInterface.SetAnimationParameterFeature( 'VehiclePassenger', animFeature, scriptInterface.executionOwner );
	}

	protected function SetIsInVehicle( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'isInVehicle', value, true );
	}

	protected function SetIsVehicleDriver( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'isDriver', value, true );
	}

	protected function SetVehicleType( stateContext : StateContext, value : Int32 )
	{
		stateContext.SetPermanentIntParameter( 'vehType', value, true );
	}

	protected function SetIsInVehicleCombat( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'isInVehCombat', value, true );
	}

	protected function SetIsInVehicleWindowCombat( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'isInVehWindowCombat', value, true );
	}

	protected function SetIsInVehicleDriverCombat( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'isInDriverCombat', value, true );
	}

	protected function SetVehicleClass( stateContext : StateContext, value : Int32 )
	{
		stateContext.SetPermanentIntParameter( 'vehClass', value, true );
	}

	protected function SetIsEnteringCombat( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'isEnteringCombat', value, true );
	}

	protected function SetIsExitingCombat( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'isExitingCombat', value, true );
	}

	protected function SetIsWorldRenderPlane( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'isWorldRenderPlane', value, true );
	}

	protected function SetIsCar( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'isCar', value, true );
	}

	protected function SetWasStolen( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'wasStolen', value, true );
	}

	protected const function SetWasCombatForced( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'wasCombatForced', value, true );
	}

	protected const function SetRequestedTPPCamera( stateContext : StateContext, value : Bool )
	{
		stateContext.SetPermanentBoolParameter( 'requestedTPPCamera', value, true );
	}

	protected function SetSide( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var value : Int32;
		var slotName : CName;
		var mountingInfo : MountingInfo;
		mountingInfo = scriptInterface.GetMountingInfo( scriptInterface.executionOwner );
		slotName = mountingInfo.slotId.id;
		if( slotName == 'seat_front_left' )
		{
			value = 1;
		}
		else if( slotName == 'seat_back_left' )
		{
			value = 1;
		}
		else if( slotName == 'seat_front_right' )
		{
			value = 2;
		}
		else if( slotName == 'seat_back_right' )
		{
			value = 2;
		}
		else
		{
			value = 0;
		}
		stateContext.SetPermanentIntParameter( 'vehSlot', value, true );
	}

	protected function IsUnmountDirectionClosest( stateContext : StateContext, unmountDirection : vehicleExitDirection ) : Bool
	{
		var side : Int32;
		side = stateContext.GetIntParameter( 'vehSlot', true );
		if( ( side == 1 ) && unmountDirection == vehicleExitDirection.Left )
		{
			return true;
		}
		if( ( side == 2 ) && unmountDirection == vehicleExitDirection.Right )
		{
			return true;
		}
		return false;
	}

	protected function IsUnmountDirectionOpposite( stateContext : StateContext, unmountDirection : vehicleExitDirection ) : Bool
	{
		var side : Int32;
		side = stateContext.GetIntParameter( 'vehSlot', true );
		if( ( side == 1 ) && unmountDirection == vehicleExitDirection.Right )
		{
			return true;
		}
		if( ( side == 2 ) && unmountDirection == vehicleExitDirection.Left )
		{
			return true;
		}
		return false;
	}

	public static function CheckVehicleDesiredTag( const scriptInterface : StateGameScriptInterface, desiredTag : CName ) : Bool
	{
		var recordID : TweakDBID;
		var vehicleRecord : Vehicle_Record;
		var tags : array< CName >;
		recordID = ( ( VehicleObject )( scriptInterface.owner ) ).GetRecordID();
		vehicleRecord = TweakDBInterface.GetVehicleRecord( recordID );
		if( !( vehicleRecord ) )
		{
			return false;
		}
		tags = vehicleRecord.Tags();
		if( tags.Contains( desiredTag ) )
		{
			return true;
		}
		return false;
	}

	protected function SetVehFppCameraParams( stateContext : StateContext, scriptInterface : StateGameScriptInterface, isPassenger : Bool, optional side : Bool, optional combat : Bool )
	{
		var recordID : TweakDBID;
		var vehicleRecord : Vehicle_Record;
		var camBodyOffset : AnimFeature_CameraBodyOffset;
		var camGameplay : AnimFeature_CameraGameplay;
		var vehCamParamsRecord : VehicleFPPCameraParams_Record;
		recordID = ( ( VehicleObject )( scriptInterface.owner ) ).GetRecordID();
		vehicleRecord = TweakDBInterface.GetVehicleRecord( recordID );
		camBodyOffset = new AnimFeature_CameraBodyOffset;
		camGameplay = new AnimFeature_CameraGameplay;
		if( combat )
		{
			if( !( isPassenger ) )
			{
				vehCamParamsRecord = vehicleRecord.VehDriverCombat_FPPCameraParams();
			}
			if( isPassenger )
			{
				if( side == true )
				{
					vehCamParamsRecord = vehicleRecord.VehPassCombatL_FPPCameraParams();
				}
				else
				{
					vehCamParamsRecord = vehicleRecord.VehPassCombatR_FPPCameraParams();
				}
			}
		}
		else
		{
			if( !( isPassenger ) )
			{
				vehCamParamsRecord = vehicleRecord.VehDriver_FPPCameraParams();
			}
			if( isPassenger )
			{
				if( side == true )
				{
					vehCamParamsRecord = vehicleRecord.VehPassL_FPPCameraParams();
				}
				else
				{
					vehCamParamsRecord = vehicleRecord.VehPassR_FPPCameraParams();
				}
			}
		}
		camBodyOffset.lookat_pitch_forward_offset = vehCamParamsRecord.Lookat_pitch_forward_offset();
		camBodyOffset.lookat_pitch_forward_down_ratio = vehCamParamsRecord.Lookat_pitch_forward_down_ratio();
		camBodyOffset.lookat_yaw_left_offset = vehCamParamsRecord.Lookat_yaw_left_offset();
		camBodyOffset.lookat_yaw_left_up_offset = vehCamParamsRecord.Lookat_yaw_left_up_offset();
		camBodyOffset.lookat_yaw_right_offset = vehCamParamsRecord.Lookat_yaw_right_offset();
		camBodyOffset.lookat_yaw_right_up_offset = vehCamParamsRecord.Lookat_yaw_right_up_offset();
		camBodyOffset.lookat_yaw_offset_active_angle = vehCamParamsRecord.Lookat_yaw_offset_active_angle();
		camBodyOffset.is_paralax = vehCamParamsRecord.Is_paralax();
		camBodyOffset.paralax_radius = vehCamParamsRecord.Paralax_radius();
		camBodyOffset.paralax_forward_offset = vehCamParamsRecord.Paralax_forward_offset();
		camBodyOffset.lookat_offset_vertical = vehCamParamsRecord.Lookat_offset_vertical();
		camGameplay.is_forward_offset = vehCamParamsRecord.Is_forward_offset();
		camGameplay.forward_offset_value = vehCamParamsRecord.Forward_offset_value();
		camGameplay.upperbody_pitch_weight = vehCamParamsRecord.Upperbody_pitch_weight();
		camGameplay.upperbody_yaw_weight = vehCamParamsRecord.Upperbody_yaw_weight();
		camGameplay.is_pitch_off = vehCamParamsRecord.Is_pitch_off();
		camGameplay.is_yaw_off = vehCamParamsRecord.Is_yaw_off();
		scriptInterface.SetAnimationParameterFeature( 'CameraBodyOffset', camBodyOffset, scriptInterface.executionOwner );
		scriptInterface.SetAnimationParameterFeature( 'CameraGameplay', camGameplay, scriptInterface.executionOwner );
	}

	protected function ResetVehFppCameraParams( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		scriptInterface.SetAnimationParameterFeature( 'CameraBodyOffset', new AnimFeature_CameraBodyOffset, scriptInterface.executionOwner );
		scriptInterface.SetAnimationParameterFeature( 'CameraGameplay', new AnimFeature_CameraGameplay, scriptInterface.executionOwner );
	}

	protected function GetVehType( stateContext : StateContext, scriptInterface : StateGameScriptInterface ) : Int32
	{
		var recordID : TweakDBID;
		var vehicleRecord : Vehicle_Record;
		var vehicleDataPackage : weak< VehicleDataPackage_Record >;
		var templateName : CName;
		recordID = ( ( VehicleObject )( scriptInterface.owner ) ).GetRecordID();
		vehicleRecord = TweakDBInterface.GetVehicleRecord( recordID );
		vehicleDataPackage = vehicleRecord.VehDataPackage();
		templateName = vehicleDataPackage.SeatingTemplateOverride();
		if( templateName == 'standard_vehicle' )
		{
			return 0;
		}
		else if( templateName == 'sport_vehicle' || templateName == 'sport1_vehicle' )
		{
			return 1;
		}
		return 0;
	}

	protected function GetVehClass( stateContext : StateContext, scriptInterface : StateGameScriptInterface ) : Int32
	{
		var recordID : TweakDBID;
		var vehicleRecord : Vehicle_Record;
		var vehTypeRecord : VehicleType_Record;
		var vehClassName : String;
		var vehClassInt : Int32;
		recordID = ( ( VehicleObject )( scriptInterface.owner ) ).GetRecordID();
		vehicleRecord = TweakDBInterface.GetVehicleRecord( recordID );
		vehTypeRecord = vehicleRecord.Type();
		vehClassName = vehTypeRecord.EnumName();
		switch( vehClassName )
		{
			case "Car":
				vehClassInt = 0;
			break;
			case "Bike":
				vehClassInt = 1;
			break;
			case "Panzer":
				vehClassInt = 2;
			break;
			default:
				vehClassInt = 0;
			break;
		}
		return vehClassInt;
	}

	protected function GetAdjacentSeat( slotName : CName, out nextSlotName : CName ) : Bool
	{
		if( !( IsNameValid( slotName ) ) )
		{
			return false;
		}
		switch( slotName )
		{
			case 'seat_front_left':
				nextSlotName = 'seat_front_right';
			break;
			case 'seat_front_right':
				nextSlotName = 'seat_front_left';
			break;
			case 'seat_back_left':
				nextSlotName = 'seat_back_right';
			break;
			case 'seat_back_right':
				nextSlotName = 'seat_back_left';
			break;
		}
		return true;
	}

	protected function IsAdjacentSeatAvailable( stateContext : StateContext, scriptInterface : StateGameScriptInterface, slotName : CName ) : Bool
	{
		var vehicle : weak< VehicleObject >;
		var seatInteractionAvailable : Bool;
		var adjacentSeat : CName;
		var doorName : EVehicleDoor;
		if( !( IsNameValid( slotName ) ) )
		{
			return false;
		}
		vehicle = ( ( VehicleObject )( scriptInterface.owner ) );
		GetAdjacentSeat( slotName, adjacentSeat );
		vehicle.GetVehiclePS().GetVehicleDoorEnum( doorName, adjacentSeat );
		seatInteractionAvailable = vehicle.GetVehiclePS().GetDoorInteractionState( doorName ) != VehicleDoorInteractionState.Disabled;
		if( !( seatInteractionAvailable ) )
		{
			return false;
		}
		if( !( VehicleComponent.IsSlotAvailable( scriptInterface.GetGame(), vehicle, 'seat_front_left' ) ) )
		{
			return false;
		}
		return true;
	}

	protected function SendEquipToHandsRequest( scriptInterface : StateGameScriptInterface, itemID : ItemID )
	{
		var equipmentSystem : EquipmentSystem;
		var equipRequest : EquipRequest;
		var drawItemRequest : DrawItemRequest;
		equipmentSystem = ( ( EquipmentSystem )( scriptInterface.GetScriptableSystem( 'EquipmentSystem' ) ) );
		equipRequest = new EquipRequest;
		equipRequest.itemID = itemID;
		equipRequest.addToInventory = true;
		equipRequest.owner = scriptInterface.executionOwner;
		equipmentSystem.QueueRequest( equipRequest );
		drawItemRequest = new DrawItemRequest;
		drawItemRequest.owner = scriptInterface.executionOwner;
		drawItemRequest.itemID = itemID;
		equipmentSystem.QueueRequest( drawItemRequest );
	}

	protected function RequestToggleVehicleCamera( scriptInterface : StateGameScriptInterface )
	{
		var camEvent : vehicleRequestCameraPerspectiveEvent;
		if( scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.Vision ) == ( ( Int32 )( gamePSMVision.Focus ) ) )
		{
			return;
		}
		camEvent = new vehicleRequestCameraPerspectiveEvent;
		switch( ( ( VehicleObject )( scriptInterface.owner ) ).GetCameraManager().GetActivePerspective() )
		{
			case vehicleCameraPerspective.FPP:
				camEvent.cameraPerspective = vehicleCameraPerspective.TPPFar;
			break;
			case vehicleCameraPerspective.TPPClose:
				camEvent.cameraPerspective = vehicleCameraPerspective.FPP;
			break;
			case vehicleCameraPerspective.TPPFar:
				camEvent.cameraPerspective = vehicleCameraPerspective.TPPClose;
			break;
		}
		scriptInterface.executionOwner.QueueEvent( camEvent );
	}

	protected function ResetVehicleCamera( scriptInterface : StateGameScriptInterface )
	{
		var camEvent : vehicleCameraResetEvent;
		camEvent = new vehicleCameraResetEvent;
		scriptInterface.executionOwner.QueueEvent( camEvent );
	}

	protected function ToggleWindowForOccupiedSeat( scriptInterface : StateGameScriptInterface, slotName : CName, shouldopen : Bool )
	{
		var VehWindowRequestEvent : VehicleExternalWindowRequestEvent;
		VehWindowRequestEvent = new VehicleExternalWindowRequestEvent;
		VehWindowRequestEvent.slotName = slotName;
		VehWindowRequestEvent.shouldOpen = shouldopen;
		scriptInterface.owner.QueueEvent( VehWindowRequestEvent );
	}

	protected const function GetUnmountingEvent( const stateContext : StateContext ) : MountEventData
	{
		var unmountEvent : MountEventData;
		unmountEvent = ( ( MountEventData )( stateContext.GetPermanentScriptableParameter( 'Unmount' ) ) );
		return unmountEvent;
	}

	protected const function IsExitForced( const stateContext : StateContext ) : Bool
	{
		return GetUnmountingEvent( stateContext );
	}

	protected function RemoveUnmountingRequest( stateContext : StateContext )
	{
		stateContext.RemovePermanentScriptableParameter( 'Unmount' );
	}

	protected function RemoveMountingRequest( stateContext : StateContext )
	{
		stateContext.RemovePermanentScriptableParameter( 'Mount' );
	}

	protected function StartLeavingVehicle( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var unmountEvent : MountEventData;
		var isInstant : Bool;
		var evt : VehicleStartedMountingEvent;
		var vehicle : VehicleObject;
		var vehicleUpsideDown : Bool;
		evt = new VehicleStartedMountingEvent;
		vehicle = ( ( VehicleObject )( scriptInterface.owner ) );
		unmountEvent = GetUnmountingEvent( stateContext );
		if( unmountEvent )
		{
			isInstant = unmountEvent.isInstant;
		}
		else
		{
			isInstant = false;
		}
		vehicleUpsideDown = vehicle.IsVehicleUpsideDown();
		if( !( isInstant ) && vehicleUpsideDown )
		{
			ExitWorkspot( stateContext, scriptInterface, isInstant, true );
		}
		else
		{
			ExitWorkspot( stateContext, scriptInterface, isInstant );
		}
		SetIsInVehicle( stateContext, false );
		SendAnimFeature( stateContext, scriptInterface );
		evt.slotID = vehicle.GetSlotIdForMountedObject( scriptInterface.executionOwner );
		evt.isMounting = false;
		evt.character = scriptInterface.executionOwner;
		vehicle.QueueEvent( evt );
	}

	protected function PlayVehicleExitDoorAnimation( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var mountInfo : MountingInfo;
		var VehDoorRequestEvent : VehicleExternalDoorRequestEvent;
		var vehicle : VehicleObject;
		var tempDisableAutoCloseDoor : SetIgnoreAutoDoorCloseEvent;
		vehicle = ( ( VehicleObject )( scriptInterface.owner ) );
		mountInfo = scriptInterface.GetMountingFacility().GetMountingInfoSingleWithObjects( scriptInterface.executionOwner );
		VehDoorRequestEvent = new VehicleExternalDoorRequestEvent;
		VehDoorRequestEvent.slotName = mountInfo.slotId.id;
		VehDoorRequestEvent.autoCloseTime = GetVehicleDataPackage( stateContext ).Normal_open();
		VehDoorRequestEvent.autoClose = !( VehicleComponent.IsDestroyed( scriptInterface.GetGame(), mountInfo.parentId ) );
		tempDisableAutoCloseDoor = new SetIgnoreAutoDoorCloseEvent;
		tempDisableAutoCloseDoor.set = true;
		vehicle.QueueEvent( tempDisableAutoCloseDoor );
		vehicle.QueueEvent( VehDoorRequestEvent );
	}

	protected virtual function ExitWorkspot( stateContext : StateContext, scriptInterface : StateGameScriptInterface, isInstant : Bool, optional upsideDown : Bool )
	{
		var workspotSystem : WorkspotGameSystem;
		var exitSlotName : CName;
		var unmountDirResult : StateResultInt;
		exitSlotName = 'default';
		SetSide( stateContext, scriptInterface );
		unmountDirResult = stateContext.GetPermanentIntParameter( 'vehUnmountDir' );
		if( upsideDown )
		{
			exitSlotName = 'exit_upside_down';
		}
		else if( unmountDirResult.valid && IsUnmountDirectionOpposite( stateContext, ( ( vehicleExitDirection )( unmountDirResult.value ) ) ) )
		{
			exitSlotName = 'exit_opposite';
		}
		workspotSystem = scriptInterface.GetWorkspotSystem();
		workspotSystem.UnmountFromVehicle( scriptInterface.owner, scriptInterface.executionOwner, isInstant, , , exitSlotName );
	}

	protected function PlayerStateChange( scriptInterface : StateGameScriptInterface, newstate : Int32 )
	{
		var activeVehicleBlackboard : IBlackboard;
		var data : VehEntityPlayerStateData;
		data.entID = scriptInterface.ownerEntityID;
		data.state = newstate;
		activeVehicleBlackboard = GetVehicleBlackboard( scriptInterface );
		activeVehicleBlackboard.SetVariant( GetAllBlackboardDefs().UI_ActiveVehicleData.VehPlayerStateData, data );
	}

	private function GetVehicleBlackboard( scriptInterface : StateGameScriptInterface ) : IBlackboard
	{
		var owner : GameObject;
		owner = scriptInterface.executionOwner;
		return GameInstance.GetBlackboardSystem( owner.GetGame() ).Get( GetAllBlackboardDefs().UI_ActiveVehicleData );
	}

	protected function SetupVehicleDataPackage( stateContext : StateContext, scriptInterface : StateGameScriptInterface ) : weak< VehicleDataPackage_Record >
	{
		var recordID : TweakDBID;
		var vehicleRecord : Vehicle_Record;
		var vehicleDataPackage : weak< VehicleDataPackage_Record >;
		recordID = ( ( VehicleObject )( scriptInterface.owner ) ).GetRecordID();
		vehicleRecord = TweakDBInterface.GetVehicleRecord( recordID );
		vehicleDataPackage = vehicleRecord.VehDataPackage();
		stateContext.SetConditionWeakScriptableParameter( 'VehicleDataPackage', vehicleDataPackage, true );
		return vehicleDataPackage;
	}

	protected const function GetVehicleDataPackage( const stateContext : StateContext ) : weak< VehicleDataPackage_Record >
	{
		return ( ( VehicleDataPackage_Record )( stateContext.GetConditionWeakScriptableParameter( 'VehicleDataPackage' ) ) );
	}

	protected function GetVehicleInventory( scriptInterface : StateGameScriptInterface ) {}

	protected final function SetVehicleCameraParameters( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var param : StateResultCName;
		var paramSecondary : StateResultCName;
		var vehClass : Int32;
		var cameraParamName : CName;
		param = GetStaticCNameParameter( "onEnterCameraParamsName" );
		paramSecondary = GetStaticCNameParameter( "onEnterCameraParamsNameSecondary" );
		vehClass = GetVehClass( stateContext, scriptInterface );
		if( ( vehClass == 1 ) && paramSecondary.valid )
		{
			cameraParamName = paramSecondary.value;
		}
		if( ( ( ( vehClass == 2 ) || ( vehClass == 0 ) ) && param.valid ) || ( ( vehClass == 1 ) && !( paramSecondary.valid ) ) )
		{
			cameraParamName = param.value;
		}
		stateContext.SetPermanentCNameParameter( 'VehicleCameraParams', cameraParamName, true );
		UpdateCameraParams( stateContext, scriptInterface );
	}

	protected const final function GetPuppetVehicleSceneTransition( const stateContext : StateContext ) : PuppetVehicleState
	{
		var puppetVehicleState : StateResultInt;
		var puppetVehicleStateValue : PuppetVehicleState;
		puppetVehicleState = stateContext.GetTemporaryIntParameter( 'scenePuppetVehicleState' );
		if( puppetVehicleState.valid )
		{
			puppetVehicleStateValue = ( ( PuppetVehicleState )( puppetVehicleState.value ) );
			return puppetVehicleStateValue;
		}
		puppetVehicleState = stateContext.GetPermanentIntParameter( 'scenePuppetVehicleState' );
		if( puppetVehicleState.valid )
		{
			puppetVehicleStateValue = ( ( PuppetVehicleState )( puppetVehicleState.value ) );
			return puppetVehicleStateValue;
		}
		return PuppetVehicleState.IdleMounted;
	}

	protected const function TryToStopVehicle( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface, optional force : Bool )
	{
		var vehicle : weak< VehicleObject >;
		var vehicleBlackboard : IBlackboard;
		var speed : Float;
		vehicle = ( ( VehicleObject )( scriptInterface.owner ) );
		vehicleBlackboard = vehicle.GetBlackboard();
		speed = vehicleBlackboard.GetFloat( GetAllBlackboardDefs().Vehicle.SpeedValue );
		if( force )
		{
			vehicle.ForceBrakesUntilStoppedOrFor( 4.0 );
		}
		else if( speed <= 25.0 )
		{
			vehicle.ForceBrakesUntilStoppedOrFor( 2.0 );
		}
	}

	protected const function IsInScene( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var highLevel : Int32;
		highLevel = scriptInterface.localBlackboard.GetInt( GetAllBlackboardDefs().PlayerStateMachine.HighLevel );
		return ( highLevel >= ( ( Int32 )( gamePSMHighLevel.SceneTier3 ) ) ) && ( highLevel <= ( ( Int32 )( gamePSMHighLevel.SceneTier5 ) ) );
	}

	public function GetVehicleObject( scriptInterface : StateGameScriptInterface ) : weak< VehicleObject >
	{
		return ( ( VehicleObject )( scriptInterface.owner ) );
	}

	public function GetVehiclePS( scriptInterface : StateGameScriptInterface ) : weak< VehicleComponentPS >
	{
		return ( ( VehicleObject )( scriptInterface.owner ) ).GetVehiclePS();
	}

	public const function IsInVehicleWorkspot( const scriptInterface : StateGameScriptInterface, slotName : CName ) : Bool
	{
		var workspotSystem : WorkspotGameSystem;
		var res : Bool;
		workspotSystem = scriptInterface.GetWorkspotSystem();
		res = workspotSystem.IsInVehicleWorkspot( scriptInterface.owner, scriptInterface.executionOwner, slotName );
		return res;
	}

	protected const function DriverSwitchSeatsCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var questForceSwitchSeats : StateResultBool;
		var seatInteractionAvailable : Bool;
		var vehicle : weak< VehicleObject >;
		var switchExitRequest : StateResultBool;
		var exitAfterRequest : StateResultBool;
		questForceSwitchSeats = stateContext.GetTemporaryBoolParameter( 'switchSeats' );
		switchExitRequest = stateContext.GetPermanentBoolParameter( 'validSwitchSeatExitRequest' );
		exitAfterRequest = stateContext.GetPermanentBoolParameter( 'validExitAfterSwitchRequest' );
		if( switchExitRequest.value && exitAfterRequest.value )
		{
			return true;
		}
		if( questForceSwitchSeats.value )
		{
			vehicle = ( ( VehicleObject )( scriptInterface.owner ) );
			seatInteractionAvailable = vehicle.GetVehiclePS().GetDoorInteractionState( EVehicleDoor.seat_front_right ) != VehicleDoorInteractionState.Disabled;
			if( seatInteractionAvailable )
			{
				if( VehicleComponent.IsSlotAvailable( scriptInterface.GetGame(), ( ( VehicleObject )( scriptInterface.owner ) ), 'seat_front_right' ) && ( GetInStateTime() >= 0.2 ) )
				{
					return true;
				}
			}
		}
		return false;
	}

	protected const function PassangerSwitchSeatsCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var switchSeatsDisabled : Bool;
		var slotName : CName;
		var seatInteractionAvailable : Bool;
		var vehicle : weak< VehicleObject >;
		var questForceSwitchSeats : StateResultBool;
		var debugBB : IBlackboard;
		var switchExitRequest : StateResultBool;
		var exitAfterRequest : StateResultBool;
		questForceSwitchSeats = stateContext.GetTemporaryBoolParameter( 'switchSeats' );
		switchSeatsDisabled = GetVehicleDataPackage( stateContext ).DisableSwitchSeats();
		debugBB = scriptInterface.GetBlackboardSystem().Get( GetAllBlackboardDefs().DebugData );
		if( switchSeatsDisabled || debugBB.GetBool( GetAllBlackboardDefs().DebugData.Vehicle_BlockSwitchSeats ) )
		{
			return false;
		}
		VehicleComponent.GetMountedSlotName( scriptInterface.GetGame(), scriptInterface.executionOwner, slotName );
		switchExitRequest = stateContext.GetPermanentBoolParameter( 'validSwitchSeatExitRequest' );
		exitAfterRequest = stateContext.GetPermanentBoolParameter( 'validExitAfterSwitchRequest' );
		if( switchExitRequest.value && exitAfterRequest.value )
		{
			return true;
		}
		if( exitAfterRequest.value )
		{
			return false;
		}
		if( slotName == 'seat_front_right' )
		{
			vehicle = ( ( VehicleObject )( scriptInterface.owner ) );
			seatInteractionAvailable = vehicle.GetVehiclePS().GetDoorInteractionState( EVehicleDoor.seat_front_left ) != VehicleDoorInteractionState.Disabled;
			if( seatInteractionAvailable )
			{
				if( VehicleComponent.IsSlotAvailable( scriptInterface.GetGame(), ( ( VehicleObject )( scriptInterface.owner ) ), 'seat_front_left' ) && ( GetInStateTime() >= 0.2 ) )
				{
					return true;
				}
			}
		}
		if( questForceSwitchSeats.value )
		{
			if( slotName == 'seat_back_left' )
			{
				vehicle = ( ( VehicleObject )( scriptInterface.owner ) );
				seatInteractionAvailable = vehicle.GetVehiclePS().GetDoorInteractionState( EVehicleDoor.seat_back_right ) != VehicleDoorInteractionState.Disabled;
				if( seatInteractionAvailable )
				{
					if( VehicleComponent.IsSlotAvailable( scriptInterface.GetGame(), ( ( VehicleObject )( scriptInterface.owner ) ), 'seat_back_right' ) && ( GetInStateTime() >= 0.2 ) )
					{
						return true;
					}
				}
			}
			else if( slotName == 'seat_back_right' )
			{
				vehicle = ( ( VehicleObject )( scriptInterface.owner ) );
				seatInteractionAvailable = vehicle.GetVehiclePS().GetDoorInteractionState( EVehicleDoor.seat_back_left ) != VehicleDoorInteractionState.Disabled;
				if( seatInteractionAvailable )
				{
					if( VehicleComponent.IsSlotAvailable( scriptInterface.GetGame(), ( ( VehicleObject )( scriptInterface.owner ) ), 'seat_back_left' ) && ( GetInStateTime() >= 0.2 ) )
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	protected function PauseStateMachines( stateContext : StateContext, executionOwner : GameObject )
	{
		var upperBody : PSMStopStateMachine;
		var equipmentRightHand : PSMStopStateMachine;
		var equipmentLeftHand : PSMStopStateMachine;
		var coverAction : PSMStopStateMachine;
		var stamina : PSMStopStateMachine;
		var crosshair : PSMStopStateMachine;
		var cameraContext : PSMStopStateMachine;
		upperBody = new PSMStopStateMachine;
		equipmentRightHand = new PSMStopStateMachine;
		equipmentLeftHand = new PSMStopStateMachine;
		coverAction = new PSMStopStateMachine;
		stamina = new PSMStopStateMachine;
		crosshair = new PSMStopStateMachine;
		cameraContext = new PSMStopStateMachine;
		if( stateContext.IsStateActive( 'UpperBody', 'forceEmptyHands' ) )
		{
			upperBody.stateMachineIdentifier.definitionName = 'UpperBody';
			executionOwner.QueueEvent( upperBody );
		}
		equipmentRightHand.stateMachineIdentifier.referenceName = 'RightHand';
		equipmentRightHand.stateMachineIdentifier.definitionName = 'Equipment';
		executionOwner.QueueEvent( equipmentRightHand );
		equipmentLeftHand.stateMachineIdentifier.referenceName = 'LeftHand';
		equipmentLeftHand.stateMachineIdentifier.definitionName = 'Equipment';
		executionOwner.QueueEvent( equipmentLeftHand );
		coverAction.stateMachineIdentifier.definitionName = 'CoverAction';
		executionOwner.QueueEvent( coverAction );
		if( GetBlackboardIntVariable( executionOwner, GetAllBlackboardDefs().PlayerStateMachine.Stamina ) == ( ( Int32 )( gamePSMStamina.Rested ) ) )
		{
			stamina.stateMachineIdentifier.definitionName = 'Stamina';
			executionOwner.QueueEvent( stamina );
		}
		crosshair.stateMachineIdentifier.definitionName = 'Crosshair';
		executionOwner.QueueEvent( crosshair );
		cameraContext.stateMachineIdentifier.definitionName = 'CameraContext';
		executionOwner.QueueEvent( cameraContext );
	}

	protected function ResumeStateMachines( executionOwner : GameObject )
	{
		var upperBody : PSMStartStateMachine;
		var equipmentRightHand : PSMStartStateMachine;
		var equipmentLeftHand : PSMStartStateMachine;
		var coverAction : PSMStartStateMachine;
		var stamina : PSMStartStateMachine;
		var locomotion : PSMStartStateMachine;
		var crosshair : PSMStartStateMachine;
		var cameraContext : PSMStartStateMachine;
		upperBody = new PSMStartStateMachine;
		equipmentRightHand = new PSMStartStateMachine;
		equipmentLeftHand = new PSMStartStateMachine;
		coverAction = new PSMStartStateMachine;
		stamina = new PSMStartStateMachine;
		locomotion = new PSMStartStateMachine;
		crosshair = new PSMStartStateMachine;
		cameraContext = new PSMStartStateMachine;
		upperBody.stateMachineIdentifier.definitionName = 'UpperBody';
		executionOwner.QueueEvent( upperBody );
		equipmentRightHand.stateMachineIdentifier.referenceName = 'RightHand';
		equipmentRightHand.stateMachineIdentifier.definitionName = 'Equipment';
		executionOwner.QueueEvent( equipmentRightHand );
		equipmentLeftHand.stateMachineIdentifier.referenceName = 'LeftHand';
		equipmentLeftHand.stateMachineIdentifier.definitionName = 'Equipment';
		executionOwner.QueueEvent( equipmentLeftHand );
		coverAction.stateMachineIdentifier.definitionName = 'CoverAction';
		executionOwner.QueueEvent( coverAction );
		stamina.stateMachineIdentifier.definitionName = 'Stamina';
		executionOwner.QueueEvent( stamina );
		locomotion.stateMachineIdentifier.definitionName = 'Locomotion';
		executionOwner.QueueEvent( locomotion );
		crosshair.stateMachineIdentifier.definitionName = 'Crosshair';
		executionOwner.QueueEvent( crosshair );
		cameraContext.stateMachineIdentifier.definitionName = 'CameraContext';
		executionOwner.QueueEvent( cameraContext );
	}

}

abstract class VehicleEventsTransition extends VehicleTransition
{
	protected var isCameraTogglePressed : Bool;
	private var cameraToggleHoldToResetTimeSeconds : Float;
	default cameraToggleHoldToResetTimeSeconds = 0.35f;

	protected virtual function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var animFeature : AnimFeature_Mounting;
		var exitActionPressCount : Uint32;
		animFeature = new AnimFeature_Mounting;
		animFeature.mountingState = 1;
		scriptInterface.SetAnimationParameterFeature( 'Mounting', animFeature );
		exitActionPressCount = scriptInterface.GetActionPressCount( 'Exit' );
		stateContext.SetPermanentIntParameter( 'exitPressCountOnEnter', ( ( Int32 )( exitActionPressCount ) ), true );
		SetupVehicleDataPackage( stateContext, scriptInterface );
		SetVehicleCameraParameters( stateContext, scriptInterface );
	}

	public export virtual function OnForcedExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var workspotSystem : WorkspotGameSystem;
		var animFeatureMounting : AnimFeature_Mounting;
		var wasSwitchingSeat : StateResultBool;
		isCameraTogglePressed = false;
		wasSwitchingSeat = stateContext.GetPermanentBoolParameter( 'wasSwitching' );
		if( wasSwitchingSeat.value )
		{
			return;
		}
		animFeatureMounting = new AnimFeature_Mounting;
		animFeatureMounting.mountingState = 0;
		scriptInterface.SetAnimationParameterFeature( 'Mounting', animFeatureMounting );
		ResetVehParams( stateContext, scriptInterface );
		ResetAnimFeature( stateContext, scriptInterface );
		ResetForceFlags( stateContext );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Vehicle, ( ( Int32 )( gamePSMVehicle.Default ) ) );
		workspotSystem = scriptInterface.GetWorkspotSystem();
		workspotSystem.UnmountFromVehicle( scriptInterface.owner, scriptInterface.executionOwner, true );
		SetOneHandedFirearmsGameplayRestriction( scriptInterface, false );
		DisableCameraBobbing( stateContext, scriptInterface, false );
		SetWasStolen( stateContext, false );
		SetWasCombatForced( stateContext, false );
		SetRequestedTPPCamera( stateContext, false );
		stateContext.SetPermanentBoolParameter( 'teleportExitActive', false, true );
		ResetVehFppCameraParams( stateContext, scriptInterface );
		SetVehicleCameraParameters( stateContext, scriptInterface );
	}

	protected function HandleCameraInput( scriptInterface : StateGameScriptInterface )
	{
		if( scriptInterface.IsActionJustPressed( 'ToggleVehCamera' ) && !( IsVehicleCameraChangeBlocked( scriptInterface ) ) )
		{
			RequestToggleVehicleCamera( scriptInterface );
		}
		if( scriptInterface.IsActionJustTapped( 'VehicleCameraInverse' ) )
		{
			ResetVehicleCamera( scriptInterface );
		}
	}

	protected function HandleExitRequest( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var stateTime : Float;
		var inputStateTime : Float;
		var currentTime : Float;
		var vehicleSubmergedTime : Float;
		var exitActionPressCount : Uint32;
		var exitPressCountResult : StateResultInt;
		var vehicle : weak< VehicleObject >;
		var validUnmount : vehicleUnmountPosition;
		var isTeleportExiting : StateResultBool;
		var isScheduledExit : StateResultBool;
		var isSwitchingSeats : StateResultBool;
		var mountingInfo : MountingInfo;
		var isSlotOccupied : Bool;
		var adjacentSeat : CName;
		var onDifferentExitPress : Bool;
		var shouldExitOnSubmerged : Bool;
		var vehiclePS : VehicleComponentPS;
		shouldExitOnSubmerged = false;
		isTeleportExiting = stateContext.GetPermanentBoolParameter( 'teleportExitActive' );
		isScheduledExit = stateContext.GetPermanentBoolParameter( 'validExitAfterSwitchRequest' );
		isSwitchingSeats = stateContext.GetPermanentBoolParameter( 'validSwitchSeatExitRequest' );
		if( ( isTeleportExiting.value || isScheduledExit.value ) || isSwitchingSeats.value )
		{
			return;
		}
		vehicle = ( ( VehicleObject )( scriptInterface.owner ) );
		vehiclePS = vehicle.GetVehiclePS();
		if( vehiclePS.GetIsSubmerged() && !( GameInstance.GetRacingSystem( scriptInterface.GetGame() ).IsRaceInProgress() ) )
		{
			vehicleSubmergedTime = vehiclePS.GetSubmergedTimestamp();
			currentTime = EngineTime.ToFloat( scriptInterface.GetTimeSystem().GetSimTime() );
			shouldExitOnSubmerged = ( currentTime - vehicleSubmergedTime ) > 0.5;
		}
		if( shouldExitOnSubmerged || IsPlayerAllowedToExitVehicle( scriptInterface ) )
		{
			stateTime = GetInStateTime();
			exitActionPressCount = scriptInterface.GetActionPressCount( 'Exit' );
			exitPressCountResult = stateContext.GetPermanentIntParameter( 'exitPressCountOnEnter' );
			onDifferentExitPress = !( exitPressCountResult.valid ) || ( exitPressCountResult.value != ( ( Int32 )( exitActionPressCount ) ) );
			if( shouldExitOnSubmerged || ( ( onDifferentExitPress && ( stateTime >= 0.30000001 ) ) && ( scriptInterface.GetActionValue( 'Exit' ) > 0.0 ) ) )
			{
				inputStateTime = scriptInterface.GetActionStateTime( 'Exit' );
				validUnmount = vehicle.CanUnmount( true, scriptInterface.executionOwner );
				stateContext.SetPermanentIntParameter( 'vehUnmountDir', ( ( Int32 )( validUnmount.direction ) ), true );
				if( shouldExitOnSubmerged || scriptInterface.IsActionJustHeld( 'Exit' ) )
				{
					if( ( vehicle != ( ( CarObject )( vehicle ) ) ) && ( vehicle != ( ( BikeObject )( vehicle ) ) ) )
					{
						stateContext.SetPermanentBoolParameter( 'validExitRequest', true, true );
						return;
					}
					SetSide( stateContext, scriptInterface );
					if( IsUnmountDirectionClosest( stateContext, validUnmount.direction ) )
					{
						stateContext.SetPermanentBoolParameter( 'validExitRequest', true, true );
						return;
					}
					if( ( vehicle == ( ( BikeObject )( vehicle ) ) ) && IsUnmountDirectionOpposite( stateContext, validUnmount.direction ) )
					{
						stateContext.SetPermanentBoolParameter( 'validExitRequest', true, true );
						return;
					}
				}
				if( shouldExitOnSubmerged || ( scriptInterface.GetActionValue( 'Exit' ) > 0.0 ) )
				{
					if( ( inputStateTime >= 0.5 ) && ( vehicle == ( ( CarObject )( vehicle ) ) ) )
					{
						SetSide( stateContext, scriptInterface );
						if( IsUnmountDirectionOpposite( stateContext, validUnmount.direction ) )
						{
							mountingInfo = scriptInterface.GetMountingInfo( scriptInterface.executionOwner );
							GetAdjacentSeat( mountingInfo.slotId.id, adjacentSeat );
							isSlotOccupied = VehicleComponent.IsSlotOccupied( scriptInterface.GetGame(), scriptInterface.ownerEntityID, adjacentSeat );
							TryToStopVehicle( stateContext, scriptInterface, true );
							if( !( isSlotOccupied ) )
							{
								stateContext.SetPermanentBoolParameter( 'validSwitchSeatExitRequest', true, true );
								stateContext.SetPermanentBoolParameter( 'validExitAfterSwitchRequest', true, true );
							}
							else
							{
								ExitWithTeleport( stateContext, scriptInterface, validUnmount, true );
							}
						}
					}
					if( shouldExitOnSubmerged || ( inputStateTime >= 1.0 ) )
					{
						if( ( ( validUnmount.direction == vehicleExitDirection.Front || validUnmount.direction == vehicleExitDirection.Back ) || validUnmount.direction == vehicleExitDirection.Top ) || validUnmount.direction == vehicleExitDirection.NoDirection )
						{
							TryToStopVehicle( stateContext, scriptInterface, true );
							ExitWithTeleport( stateContext, scriptInterface, validUnmount );
						}
					}
				}
			}
			return;
		}
	}

	protected function ExitWithTeleport( stateContext : StateContext, scriptInterface : StateGameScriptInterface, validUnmountDirection : vehicleUnmountPosition, optional moveVehicle : Bool, optional skipUnmount : Bool )
	{
		var unmountEvent : UnmountingRequest;
		var mountingInfo : MountingInfo;
		var teleportPosition : Vector4;
		var worldPos : Vector4;
		var vehicleTeleportPosition : Vector4;
		stateContext.SetPermanentBoolParameter( 'teleportExitActive', true, true );
		mountingInfo = scriptInterface.GetMountingInfo( scriptInterface.executionOwner );
		unmountEvent = new UnmountingRequest;
		unmountEvent.lowLevelMountingInfo = mountingInfo;
		unmountEvent.mountData = new MountEventData;
		unmountEvent.mountData.isInstant = true;
		scriptInterface.GetMountingFacility().Unmount( unmountEvent );
		if( validUnmountDirection.direction == vehicleExitDirection.NoDirection )
		{
			worldPos = scriptInterface.executionOwner.GetWorldPosition();
			worldPos.Z = worldPos.Z + 2.0;
			teleportPosition = worldPos;
		}
		else
		{
			teleportPosition = WorldPosition.ToVector4( validUnmountDirection.position );
		}
		if( moveVehicle )
		{
			vehicleTeleportPosition = scriptInterface.owner.GetWorldPosition();
			vehicleTeleportPosition.Z = vehicleTeleportPosition.Z + 0.25;
			WorldTransform.GetRight( scriptInterface.owner.GetWorldTransform() );
			teleportPosition = teleportPosition + WorldTransform.GetRight( scriptInterface.owner.GetWorldTransform() );
			vehicleTeleportPosition = vehicleTeleportPosition + WorldTransform.GetRight( scriptInterface.owner.GetWorldTransform() );
			GameInstance.GetTeleportationFacility( scriptInterface.GetGame() ).Teleport( scriptInterface.owner, vehicleTeleportPosition, Quaternion.ToEulerAngles( scriptInterface.owner.GetWorldOrientation() ) );
		}
		GameInstance.GetTeleportationFacility( scriptInterface.GetGame() ).Teleport( scriptInterface.executionOwner, teleportPosition, Quaternion.ToEulerAngles( scriptInterface.owner.GetWorldOrientation() ) );
	}

}

struct VehEntityPlayerStateData
{
	var entID : EntityID;
	var state : Int32;
}

class IdleDecisions extends VehicleTransition
{

	public export const function ToExit( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsExitForced( stateContext ) || !( scriptInterface.owner ) )
		{
			return true;
		}
		return false;
	}

}

class IdleEvents extends VehicleEventsTransition
{

	protected export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var vehType : Int32;
		var vehClass : Int32;
		super.OnEnter( stateContext, scriptInterface );
		vehType = GetVehType( stateContext, scriptInterface );
		SetVehicleType( stateContext, vehType );
		vehClass = GetVehClass( stateContext, scriptInterface );
		SetVehicleClass( stateContext, vehClass );
		VehicleComponent.SetAnimsetOverrideForPassenger( scriptInterface.executionOwner, 1.0 );
		if( !( IsInRpgContext( scriptInterface ) ) )
		{
			stateContext.SetPermanentBoolParameter( 'VisionToggled', false, true );
			ForceDisableVisionMode( stateContext );
		}
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Vehicle, ( ( Int32 )( gamePSMVehicle.Transition ) ) );
		PlayerStateChange( scriptInterface, 4 );
		DisableCameraBobbing( stateContext, scriptInterface, true );
		stateContext.SetPermanentBoolParameter( 'validExitRequest', false, true );
		stateContext.SetPermanentBoolParameter( 'validSwitchSeatExitRequest', false, true );
		stateContext.SetPermanentBoolParameter( 'teleportExitActive', false, true );
		stateContext.RemoveConditionBoolParameter( 'CrouchToggled' );
	}

}

class EnteringDecisions extends VehicleTransition
{

	public export const function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var currentTime : Float;
		var targetTime : Float;
		var wasStolen : StateResultBool;
		wasStolen = stateContext.GetPermanentBoolParameter( 'wasStolen' );
		if( wasStolen.value )
		{
			currentTime = GetInStateTime();
			targetTime = 3.70000005;
			return ( currentTime > targetTime ) || ( stateMachineInitData.instant && stateContext.IsStateActive( 'Locomotion', 'workspot' ) );
		}
		else
		{
			currentTime = GetInStateTime();
			targetTime = GetVehicleDataPackage( stateContext ).Entering();
			return ( currentTime > targetTime ) || ( stateMachineInitData.instant && stateContext.IsStateActive( 'Locomotion', 'workspot' ) );
		}
	}

	public export const function ToExiting( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsExitForced( stateContext ) || !( scriptInterface.owner ) )
		{
			return true;
		}
		return false;
	}

	public export const function ToSwitchSeats( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsDriverInVehicle( scriptInterface ) )
		{
			return DriverSwitchSeatsCondition( stateContext, scriptInterface );
		}
		if( IsPassengerInVehicle( scriptInterface ) )
		{
			return PassangerSwitchSeatsCondition( stateContext, scriptInterface );
		}
		return false;
	}

}

class EnteringEvents extends VehicleEventsTransition
{

	protected export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var workspotSystem : WorkspotGameSystem;
		var mountingInfo : MountingInfo;
		var slideDuration : Float;
		var syncObjects : array< EntityID >;
		var animVariables : array< CName >;
		var entrySlotName : CName;
		var exitEvent : AIEvent;
		super.OnEnter( stateContext, scriptInterface );
		stateContext.SetPermanentBoolParameter( 'VisionToggled', false, true );
		ForceDisableVisionMode( stateContext );
		ForceDisableRadialWheel( scriptInterface );
		SendEquipmentSystemWeaponManipulationRequest( scriptInterface, EquipmentManipulationAction.UnequipAll );
		ForceIdleVehicle( stateContext );
		slideDuration = GetVehicleDataPackage( stateContext ).SlideDuration();
		if( stateMachineInitData.instant )
		{
			slideDuration = 0.0;
		}
		mountingInfo = scriptInterface.GetMountingInfo( scriptInterface.executionOwner );
		workspotSystem = scriptInterface.GetWorkspotSystem();
		animVariables = VehicleComponent.SetAnimsetOverrideForPassenger( scriptInterface.executionOwner, 1.0 );
		if( EntityID.IsDefined( stateMachineInitData.entityID ) )
		{
			syncObjects.PushBack( stateMachineInitData.entityID );
			workspotSystem.StopNpcInWorkspot( scriptInterface.executionOwner );
			if( stateMachineInitData.alive )
			{
				entrySlotName = 'stealing';
			}
			else
			{
				entrySlotName = 'deadstealing';
			}
			workspotSystem.MountToVehicle( scriptInterface.owner, scriptInterface.executionOwner, slideDuration, slideDuration, 'OccupantSlots', mountingInfo.slotId.id, syncObjects, entrySlotName, animVariables );
			SetWasStolen( stateContext, true );
		}
		else
		{
			workspotSystem.StopNpcInWorkspot( scriptInterface.executionOwner );
			workspotSystem.MountToVehicle( scriptInterface.owner, scriptInterface.executionOwner, slideDuration, slideDuration, 'OccupantSlots', mountingInfo.slotId.id, , 'default', animVariables );
		}
		if( stateMachineInitData.occupiedByNeutral )
		{
			exitEvent = new AIEvent;
			exitEvent.name = 'ExitVehicleInPanic';
			VehicleComponent.QueueEventToAllNonFriendlyActivePassengers( scriptInterface.GetGame(), scriptInterface.ownerEntityID, exitEvent, scriptInterface.executionOwner, true );
		}
		if( !( VehicleComponent.IsDriverSlot( mountingInfo.slotId.id ) ) )
		{
			VehicleComponent.QueueHijackExitEventToInactiveDriver( scriptInterface.owner.GetGame(), ( ( VehicleObject )( scriptInterface.owner ) ) );
		}
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Vehicle, ( ( Int32 )( gamePSMVehicle.Transition ) ) );
		PlayerStateChange( scriptInterface, 4 );
	}

}

class PassengerDecisions extends VehicleTransition
{

	public export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsPassengerInVehicle( scriptInterface ) )
		{
			return true;
		}
		return false;
	}

	public export const function ToCombat( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( GetPuppetVehicleSceneTransition( stateContext ) == PuppetVehicleState.CombatSeated )
		{
			return true;
		}
		return false;
	}

	public export const function ToSwitchSeats( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return PassangerSwitchSeatsCondition( stateContext, scriptInterface );
	}

}

class PassengerEvents extends VehicleEventsTransition
{

	protected export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var audioEvt : VehicleAudioEvent;
		var mountingInfo : MountingInfo;
		var fppCamParamsSide : Bool;
		super.OnEnter( stateContext, scriptInterface );
		mountingInfo = scriptInterface.GetMountingInfo( scriptInterface.executionOwner );
		SetSide( stateContext, scriptInterface );
		ForceIdleVehicle( stateContext );
		SetIsInVehicle( stateContext, true );
		SetIsCar( stateContext, true );
		if( mountingInfo.slotId.id == 'seat_back_left' )
		{
			fppCamParamsSide = true;
		}
		SetVehFppCameraParams( stateContext, scriptInterface, true, fppCamParamsSide );
		SendAnimFeature( stateContext, scriptInterface );
		SendIsCar( stateContext, scriptInterface );
		audioEvt = new VehicleAudioEvent;
		audioEvt.action = vehicleAudioEventAction.OnPlayerPassenger;
		scriptInterface.owner.QueueEvent( audioEvt );
		if( stateContext.GetBoolParameter( 'requestedTPPCamera', true ) )
		{
			RequestVehicleCameraPerspective( scriptInterface, vehicleCameraPerspective.TPPClose );
			SetRequestedTPPCamera( stateContext, false );
		}
		RemoveMountingRequest( stateContext );
		SetOneHandedFirearmsGameplayRestriction( scriptInterface, true );
		PlayerStateChange( scriptInterface, 3 );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Vehicle, ( ( Int32 )( gamePSMVehicle.Passenger ) ) );
	}

	public export function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		isCameraTogglePressed = false;
		ResetVehFppCameraParams( stateContext, scriptInterface );
		if( GetPuppetVehicleSceneTransition( stateContext ) == PuppetVehicleState.CombatSeated )
		{
			SendEquipmentSystemWeaponManipulationRequest( scriptInterface, EquipmentManipulationAction.RequestLastUsedOrFirstAvailableWeapon );
			stateContext.SetTemporaryBoolParameter( 'vehicleWindowedCombat', false, true );
		}
	}

	public export function OnUpdate( timeDelta : Float, stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		SetSide( stateContext, scriptInterface );
		HandleExitRequest( stateContext, scriptInterface );
	}

}

class GunnerDecisions extends VehicleTransition
{

	public export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var lowLevelMountingInfo : MountingInfo;
		var currentSlot : CName;
		lowLevelMountingInfo = scriptInterface.GetMountingFacility().GetMountingInfoSingleWithObjects( scriptInterface.executionOwner );
		currentSlot = lowLevelMountingInfo.slotId.id;
		if( currentSlot == 'gunner_back_left' || currentSlot == 'gunner_back_right' )
		{
			return true;
		}
		return false;
	}

	public const function ToExiting( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsExitForced( stateContext ) || !( scriptInterface.owner ) )
		{
			return true;
		}
		return false;
	}

}

class GunnerEvents extends VehicleEventsTransition
{

	protected override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var audioEvt : VehicleAudioEvent;
		super.OnEnter( stateContext, scriptInterface );
		stateContext.SetPermanentIntParameter( 'vehSlot', 3, true );
		ForceIdleVehicle( stateContext );
		SetIsInVehicle( stateContext, true );
		SetIsCar( stateContext, true );
		ResetVehFppCameraParams( stateContext, scriptInterface );
		SendIsCar( stateContext, scriptInterface );
		audioEvt = new VehicleAudioEvent;
		audioEvt.action = vehicleAudioEventAction.OnPlayerPassenger;
		scriptInterface.owner.QueueEvent( audioEvt );
		RemoveMountingRequest( stateContext );
		PlayerStateChange( scriptInterface, 3 );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Vehicle, ( ( Int32 )( gamePSMVehicle.Combat ) ) );
		SetIsInVehicleCombat( stateContext, true );
		SendEquipmentSystemWeaponManipulationRequest( scriptInterface, EquipmentManipulationAction.RequestLastUsedOrFirstAvailableRangedWeapon );
		SendAnimFeature( stateContext, scriptInterface );
		if( GetVehClass( stateContext, scriptInterface ) == 1 )
		{
			SetOneHandedFirearmsGameplayRestriction( scriptInterface, false );
		}
	}

	public function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		ResetVehFppCameraParams( stateContext, scriptInterface );
		if( GetPuppetVehicleSceneTransition( stateContext ) == PuppetVehicleState.CombatSeated )
		{
			SendEquipmentSystemWeaponManipulationRequest( scriptInterface, EquipmentManipulationAction.RequestLastUsedOrFirstAvailableWeapon );
			stateContext.SetTemporaryBoolParameter( 'vehicleWindowedCombat', false, true );
		}
	}

	public override function OnForcedExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		super.OnForcedExit( stateContext, scriptInterface );
	}

}

class DriveDecisions extends VehicleTransition
{

	public export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsDriverInVehicle( scriptInterface ) )
		{
			return true;
		}
		return false;
	}

	public export const function ToDriverCombat( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( CanEnterDriverCombat() && IsPlayerAllowedToEnterCombat( scriptInterface ) )
		{
			if( UpperBodyTransition.HasAnyWeaponEquipped( scriptInterface ) )
			{
				return true;
			}
			if( GetPuppetVehicleSceneTransition( stateContext ) == PuppetVehicleState.CombatSeated )
			{
				return true;
			}
		}
		return false;
	}

	public export const function ToSwitchSeats( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return DriverSwitchSeatsCondition( stateContext, scriptInterface );
	}

}

class DriveEvents extends VehicleEventsTransition
{

	protected export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var audioEvt : VehicleAudioEvent;
		super.OnEnter( stateContext, scriptInterface );
		SetSide( stateContext, scriptInterface );
		SetIsInVehicle( stateContext, true );
		SetIsVehicleDriver( stateContext, true );
		ForceIdleVehicle( stateContext );
		PlayerStateChange( scriptInterface, 1 );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Vehicle, ( ( Int32 )( gamePSMVehicle.Driving ) ) );
		SendAnimFeature( stateContext, scriptInterface );
		SetVehFppCameraParams( stateContext, scriptInterface, false );
		audioEvt = new VehicleAudioEvent;
		audioEvt.action = vehicleAudioEventAction.OnPlayerDriving;
		scriptInterface.owner.QueueEvent( audioEvt );
		if( stateContext.GetBoolParameter( 'requestedTPPCamera', true ) )
		{
			RequestVehicleCameraPerspective( scriptInterface, vehicleCameraPerspective.TPPClose );
			SetRequestedTPPCamera( stateContext, false );
		}
		if( !( CanEnterDriverCombat() ) )
		{
			stateContext.SetPermanentBoolParameter( 'ForceEmptyHands', true, true );
		}
		RemoveMountingRequest( stateContext );
		PauseStateMachines( stateContext, scriptInterface.executionOwner );
		GameInstance.GetRazerChromaEffectsSystem( scriptInterface.executionOwner.GetGame() ).SetIdleAnimation( 'Driving', true );
	}

	public export function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var transition : PuppetVehicleState;
		transition = GetPuppetVehicleSceneTransition( stateContext );
		if( transition == PuppetVehicleState.CombatSeated || transition == PuppetVehicleState.CombatWindowed )
		{
			SendEquipmentSystemWeaponManipulationRequest( scriptInterface, EquipmentManipulationAction.RequestLastUsedOrFirstAvailableWeapon );
		}
		SetIsVehicleDriver( stateContext, false );
		SendAnimFeature( stateContext, scriptInterface );
		ResetVehFppCameraParams( stateContext, scriptInterface );
		isCameraTogglePressed = false;
		stateContext.SetPermanentBoolParameter( 'ForceEmptyHands', false, true );
		ResumeStateMachines( scriptInterface.executionOwner );
		GameInstance.GetRazerChromaEffectsSystem( scriptInterface.executionOwner.GetGame() ).SetIdleAnimation( 'HotKeys', true );
	}

	public override function OnForcedExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		super.OnForcedExit( stateContext, scriptInterface );
		ResumeStateMachines( scriptInterface.executionOwner );
	}

	public export function OnUpdate( timeDelta : Float, stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		SendAnimFeature( stateContext, scriptInterface );
		HandleCameraInput( scriptInterface );
		HandleExitRequest( stateContext, scriptInterface );
	}

}

class SwitchSeatsDecisions extends VehicleTransition
{

	public constexpr const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return true;
	}

	public const function ToDrive( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var mountingRequest : MountingRequest;
		var lowLevelMountingInfo : MountingInfo;
		var mountData : MountEventData;
		var mountOptions : MountEventOptions;
		var currentSlot : CName;
		lowLevelMountingInfo = scriptInterface.GetMountingFacility().GetMountingInfoSingleWithIds( scriptInterface.executionOwnerEntityID,  );
		currentSlot = lowLevelMountingInfo.slotId.id;
		if( GetInStateTime() >= GetVehicleDataPackage( stateContext ).SwitchSeats() )
		{
			mountingRequest = new MountingRequest;
			mountData = new MountEventData;
			mountOptions = new MountEventOptions;
			lowLevelMountingInfo.parentId = scriptInterface.ownerEntityID;
			lowLevelMountingInfo.childId = scriptInterface.executionOwnerEntityID;
			mountData.isInstant = true;
			mountOptions.silentUnmount = true;
			if( currentSlot == 'seat_front_right' )
			{
				lowLevelMountingInfo.slotId.id = 'seat_front_left';
				mountingRequest.lowLevelMountingInfo = lowLevelMountingInfo;
				mountingRequest.mountData = mountData;
				mountingRequest.mountData.mountEventOptions = mountOptions;
				scriptInterface.GetMountingFacility().Mount( mountingRequest );
				VehicleComponent.CloseDoor( ( ( VehicleObject )( scriptInterface.owner ) ), lowLevelMountingInfo.slotId );
				return true;
			}
		}
		return false;
	}

	public const function ToPassenger( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var mountingRequest : MountingRequest;
		var lowLevelMountingInfo : MountingInfo;
		var mountData : MountEventData;
		var mountOptions : MountEventOptions;
		var currentSlot : CName;
		lowLevelMountingInfo = scriptInterface.GetMountingFacility().GetMountingInfoSingleWithIds( scriptInterface.executionOwnerEntityID,  );
		currentSlot = lowLevelMountingInfo.slotId.id;
		if( GetInStateTime() >= GetVehicleDataPackage( stateContext ).SwitchSeats() )
		{
			mountingRequest = new MountingRequest;
			mountData = new MountEventData;
			mountOptions = new MountEventOptions;
			lowLevelMountingInfo.parentId = scriptInterface.ownerEntityID;
			lowLevelMountingInfo.childId = scriptInterface.executionOwnerEntityID;
			mountData.isInstant = true;
			mountOptions.silentUnmount = true;
			if( currentSlot == 'seat_back_left' )
			{
				lowLevelMountingInfo.slotId.id = 'seat_back_right';
				mountingRequest.lowLevelMountingInfo = lowLevelMountingInfo;
				mountingRequest.mountData = mountData;
				mountingRequest.mountData.mountEventOptions = mountOptions;
				scriptInterface.GetMountingFacility().Mount( mountingRequest );
				return true;
			}
			if( currentSlot == 'seat_back_right' )
			{
				lowLevelMountingInfo.slotId.id = 'seat_back_left';
				mountingRequest.lowLevelMountingInfo = lowLevelMountingInfo;
				mountingRequest.mountData = mountData;
				mountingRequest.mountData.mountEventOptions = mountOptions;
				scriptInterface.GetMountingFacility().Mount( mountingRequest );
				return true;
			}
			if( currentSlot == 'seat_front_left' )
			{
				lowLevelMountingInfo.slotId.id = 'seat_front_right';
				mountingRequest.lowLevelMountingInfo = lowLevelMountingInfo;
				mountingRequest.mountData = mountData;
				mountingRequest.mountData.mountEventOptions = mountOptions;
				scriptInterface.GetMountingFacility().Mount( mountingRequest );
				return true;
			}
		}
		return false;
	}

}

class SwitchSeatsEvents extends VehicleEventsTransition
{
	var workspotSystem : WorkspotGameSystem;
	var enabledSceneMode : Bool;

	protected override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var animVariablesActivate : array< CName >;
		var animVariablesDeactivate : array< CName >;
		var vehicle : weak< VehicleObject >;
		var evtNextSeat : AnimWrapperWeightSetter;
		var evtPrevSeat : AnimWrapperWeightSetter;
		var mountingInfo : MountingInfo;
		var curSlotName : CName;
		var nextSlotName : CName;
		stateContext.SetPermanentBoolParameter( 'validSwitchSeatExitRequest', false, true );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Vehicle, ( ( Int32 )( gamePSMVehicle.Transition ) ) );
		vehicle = GetVehicleObject( scriptInterface );
		mountingInfo = scriptInterface.GetMountingInfo( scriptInterface.executionOwner );
		curSlotName = mountingInfo.slotId.id;
		GetAdjacentSeat( curSlotName, nextSlotName );
		SetRequestedTPPCamera( stateContext, false );
		evtNextSeat = new AnimWrapperWeightSetter;
		evtNextSeat.key = vehicle.GetAnimsetOverrideForPassenger( nextSlotName );
		evtNextSeat.value = 1.0;
		animVariablesActivate.PushBack( evtNextSeat.key );
		scriptInterface.executionOwner.QueueEvent( evtNextSeat );
		evtPrevSeat = new AnimWrapperWeightSetter;
		evtPrevSeat.key = vehicle.GetAnimsetOverrideForPassenger( curSlotName );
		evtPrevSeat.value = 0.0;
		animVariablesDeactivate.PushBack( evtPrevSeat.key );
		scriptInterface.executionOwner.QueueEvent( evtPrevSeat );
		workspotSystem = scriptInterface.GetWorkspotSystem();
		workspotSystem.SwitchSeatVehicle( scriptInterface.owner, scriptInterface.executionOwner, 'OccupantSlots', nextSlotName, 'switch_seat', animVariablesActivate, animVariablesDeactivate );
		SetVehicleCameraSceneMode( scriptInterface, true );
		enabledSceneMode = true;
		super.OnEnter( stateContext, scriptInterface );
	}

	public function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		if( enabledSceneMode )
		{
			SetVehicleCameraSceneMode( scriptInterface, false );
			enabledSceneMode = false;
		}
	}

	public function OnUpdate( timeDelta : Float, stateContext : StateContext, scriptInterface : StateGameScriptInterface ) {}
}

class EnteringCombatDecisions extends VehicleTransition
{

	public export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var audioEvt : VehicleAudioEvent;
		var questForceEnableCombat : StateResultBool;
		var hasTurret : Bool;
		var scenePuppetVehicleTransition : PuppetVehicleState;
		if( !( IsPlayerAllowedToEnterCombat( scriptInterface ) ) )
		{
			return false;
		}
		questForceEnableCombat = stateContext.GetTemporaryBoolParameter( 'startVehicleCombat' );
		hasTurret = CheckVehicleDesiredTag( scriptInterface, 'Turret' );
		scenePuppetVehicleTransition = GetPuppetVehicleSceneTransition( stateContext );
		if( hasTurret )
		{
			return false;
		}
		if( questForceEnableCombat.value && !( hasTurret ) )
		{
			SetWasCombatForced( stateContext, true );
			return true;
		}
		if( scenePuppetVehicleTransition == PuppetVehicleState.CombatWindowed )
		{
			SetWasCombatForced( stateContext, true );
			return true;
		}
		audioEvt = new VehicleAudioEvent;
		audioEvt.action = vehicleAudioEventAction.OnPlayerExitCombat;
		scriptInterface.owner.QueueEvent( audioEvt );
		if( UpperBodyTransition.HasAnyWeaponEquipped( scriptInterface ) )
		{
			return true;
		}
		return false;
	}

	public const function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return GetInStateTime() > GetVehicleDataPackage( stateContext ).ToCombat();
	}

}

class EnteringCombatEvents extends VehicleEventsTransition
{

	protected override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var weaponID : ItemID;
		var equipmentManipulationAction : EquipmentManipulationAction;
		var equipmentSystem : EquipmentSystem;
		var drawItemRequest : DrawItemRequest;
		super.OnEnter( stateContext, scriptInterface );
		if( stateContext.GetBoolParameter( 'wasCombatForced', true ) && !( UpperBodyTransition.HasRangedWeaponEquipped( scriptInterface.executionOwner ) ) )
		{
			if( StatusEffectSystem.ObjectHasStatusEffectWithTag( scriptInterface.executionOwner, 'OneHandedFirearms' ) )
			{
				weaponID = EquipmentSystem.GetData( scriptInterface.executionOwner ).GetLastUsedOrFirstAvailableOneHandedRangedWeapon();
				equipmentManipulationAction = EquipmentManipulationAction.RequestLastUsedOrFirstAvailableOneHandedRangedWeapon;
			}
			else
			{
				weaponID = EquipmentSystem.GetData( scriptInterface.executionOwner ).GetLastUsedOrFirstAvailableRangedWeapon();
				equipmentManipulationAction = EquipmentManipulationAction.RequestLastUsedOrFirstAvailableRangedWeapon;
			}
			if( ItemID.IsValid( weaponID ) )
			{
				SendEquipmentSystemWeaponManipulationRequest( scriptInterface, equipmentManipulationAction );
			}
			else
			{
				equipmentSystem = ( ( EquipmentSystem )( scriptInterface.GetScriptableSystem( 'EquipmentSystem' ) ) );
				drawItemRequest = new DrawItemRequest;
				drawItemRequest.owner = scriptInterface.executionOwner;
				drawItemRequest.itemID = ItemID.CreateQuery( T"Items.Preset_V_Unity_Cutscene" );
				equipmentSystem.QueueRequest( drawItemRequest );
			}
		}
		SetIsEnteringCombat( stateContext, true );
		SendAnimFeature( stateContext, scriptInterface );
		PlayerStateChange( scriptInterface, 2 );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Vehicle, ( ( Int32 )( gamePSMVehicle.Transition ) ) );
		SetVehicleCameraSceneMode( scriptInterface, true );
	}

	public function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		SetIsEnteringCombat( stateContext, false );
		SendAnimFeature( stateContext, scriptInterface );
		if( !( stateContext.GetBoolParameter( 'wasCombatForced', true ) ) )
		{
			SendEquipmentSystemWeaponManipulationRequest( scriptInterface, EquipmentManipulationAction.RequestLastUsedOrFirstAvailableWeapon );
		}
		stateContext.SetTemporaryBoolParameter( 'vehicleWindowedCombat', true, true );
		SetWasCombatForced( stateContext, false );
		SetVehicleCameraSceneMode( scriptInterface, false );
	}

}

class ExitingCombatDecisions extends VehicleTransition
{

	public const function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return GetInStateTime() > GetVehicleDataPackage( stateContext ).FromCombat();
	}

}

class ExitingCombatEvents extends VehicleEventsTransition
{

	protected override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var audioEvt : VehicleAudioEvent;
		super.OnEnter( stateContext, scriptInterface );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Vehicle, ( ( Int32 )( gamePSMVehicle.Transition ) ) );
		SendEquipmentSystemWeaponManipulationRequest( scriptInterface, EquipmentManipulationAction.UnequipAll );
		SetVehicleCameraSceneMode( scriptInterface, true );
		SetIsExitingCombat( stateContext, true );
		SendAnimFeature( stateContext, scriptInterface );
		audioEvt = new VehicleAudioEvent;
		audioEvt.action = vehicleAudioEventAction.OnPlayerExitCombat;
		scriptInterface.owner.QueueEvent( audioEvt );
	}

	public function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		SetVehicleCameraSceneMode( scriptInterface, false );
		SetIsExitingCombat( stateContext, false );
		SendAnimFeature( stateContext, scriptInterface );
	}

}

class SceneExitingCombatDecisions extends VehicleTransition
{

	public const function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( ( GetInStateTime() >= 0.5 ) || !( scriptInterface.IsSceneAnimationActive() ) )
		{
			return true;
		}
		return false;
	}

}

class SceneExitingCombatEvents extends VehicleEventsTransition
{

	protected override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var mountingInfo : MountingInfo;
		var slotName : CName;
		super.OnEnter( stateContext, scriptInterface );
		SetVehicleCameraSceneMode( scriptInterface, true );
		mountingInfo = scriptInterface.GetMountingInfo( scriptInterface.executionOwner );
		slotName = mountingInfo.slotId.id;
		SetIsInVehicleCombat( stateContext, true );
		SetIsInVehicleWindowCombat( stateContext, true );
		SetIsWorldRenderPlane( stateContext, true );
		SendAnimFeature( stateContext, scriptInterface );
		ToggleWindowForOccupiedSeat( scriptInterface, slotName, true );
		SetFirearmsGameplayRestriction( scriptInterface, true );
		SetVehFppCameraParams( stateContext, scriptInterface, true, false, true );
	}

	public function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var mountingInfo : MountingInfo;
		var slotName : CName;
		SetIsInVehicleCombat( stateContext, false );
		SetIsInVehicleWindowCombat( stateContext, false );
		SetIsWorldRenderPlane( stateContext, true );
		SetVehicleCameraSceneMode( scriptInterface, false );
		SetIsExitingCombat( stateContext, false );
		SendAnimFeature( stateContext, scriptInterface );
		mountingInfo = scriptInterface.GetMountingInfo( scriptInterface.executionOwner );
		slotName = mountingInfo.slotId.id;
		ToggleWindowForOccupiedSeat( scriptInterface, slotName, false );
		SetFirearmsGameplayRestriction( scriptInterface, false );
		ResetVehFppCameraParams( stateContext, scriptInterface );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Vehicle, ( ( Int32 )( gamePSMVehicle.Transition ) ) );
		SendEquipmentSystemWeaponManipulationRequest( scriptInterface, EquipmentManipulationAction.UnequipAll );
	}

}

class CombatDecisions extends VehicleTransition
{

	public const function ToExitingCombat( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var questForceDisableCombat : StateResultBool;
		questForceDisableCombat = stateContext.GetTemporaryBoolParameter( 'stopVehicleCombat' );
		if( questForceDisableCombat.value )
		{
			return true;
		}
		if( !( IsPlayerAllowedToExitCombat( scriptInterface ) ) )
		{
			return false;
		}
		if( IsInEmptyHandsState( stateContext ) && ( GetInStateTime() >= 0.5 ) )
		{
			return true;
		}
		if( scriptInterface.IsActionJustPressed( 'Exit' ) )
		{
			return true;
		}
		if( scriptInterface.IsActionJustPressed( 'ToggleVehCamera' ) )
		{
			SetRequestedTPPCamera( stateContext, true );
			return true;
		}
		if( !( IsPlayerAllowedToEnterCombat( scriptInterface ) ) )
		{
			return true;
		}
		return false;
	}

	public const function ToSceneExitingCombat( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsPlayerAllowedToExitCombat( scriptInterface ) )
		{
			return false;
		}
		if( !( IsInScene( stateContext, scriptInterface ) ) )
		{
			return false;
		}
		if( !( scriptInterface.IsSceneAnimationActive() ) )
		{
			return false;
		}
		return true;
	}

}

class CombatEvents extends VehicleEventsTransition
{

	protected override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var mountingInfo : MountingInfo;
		var slotName : CName;
		var fppCamParamsSide : Bool;
		super.OnEnter( stateContext, scriptInterface );
		mountingInfo = scriptInterface.GetMountingInfo( scriptInterface.executionOwner );
		slotName = mountingInfo.slotId.id;
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Vehicle, ( ( Int32 )( gamePSMVehicle.Combat ) ) );
		SetIsWorldRenderPlane( stateContext, false );
		SetIsInVehicleCombat( stateContext, true );
		SetIsInVehicleWindowCombat( stateContext, stateContext.GetBoolParameter( 'vehicleWindowedCombat', false ) );
		SendAnimFeature( stateContext, scriptInterface );
		ToggleWindowForOccupiedSeat( scriptInterface, slotName, true );
		SetFirearmsGameplayRestriction( scriptInterface, true );
		if( mountingInfo.slotId.id == 'seat_back_left' )
		{
			fppCamParamsSide = true;
		}
		SetVehFppCameraParams( stateContext, scriptInterface, true, fppCamParamsSide, true );
	}

	public function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var mountingInfo : MountingInfo;
		var slotName : CName;
		mountingInfo = scriptInterface.GetMountingInfo( scriptInterface.executionOwner );
		slotName = mountingInfo.slotId.id;
		SetIsInVehicleCombat( stateContext, false );
		SetIsInVehicleWindowCombat( stateContext, false );
		SetIsWorldRenderPlane( stateContext, true );
		SendAnimFeature( stateContext, scriptInterface );
		ToggleWindowForOccupiedSeat( scriptInterface, slotName, false );
		SetFirearmsGameplayRestriction( scriptInterface, false );
		ResetVehFppCameraParams( stateContext, scriptInterface );
	}

}

class DriverCombatDecisions extends VehicleTransition
{

	public const function ToDrive( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( stateContext.IsStateActive( 'UpperBody', 'emptyHands' ) && ( GetInStateTime() >= 0.5 ) )
		{
			return true;
		}
		if( !( IsPlayerAllowedToEnterCombat( scriptInterface ) ) )
		{
			return true;
		}
		return false;
	}

}

class DriverCombatEvents extends VehicleEventsTransition
{

	protected override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var mountingInfo : MountingInfo;
		var slotName : CName;
		super.OnEnter( stateContext, scriptInterface );
		mountingInfo = scriptInterface.GetMountingInfo( scriptInterface.executionOwner );
		slotName = mountingInfo.slotId.id;
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Vehicle, ( ( Int32 )( gamePSMVehicle.DriverCombat ) ) );
		SetIsInVehicleDriverCombat( stateContext, true );
		SetVehFppCameraParams( stateContext, scriptInterface, false, , true );
		SetIsWorldRenderPlane( stateContext, true );
		SendAnimFeature( stateContext, scriptInterface );
		SetVehicleCameraSceneMode( scriptInterface, true );
		ToggleWindowForOccupiedSeat( scriptInterface, slotName, true );
	}

	protected function OnUpdate( timeDelta : Float, stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		if( scriptInterface.IsActionJustPressed( 'Exit' ) )
		{
			SendEquipmentSystemWeaponManipulationRequest( scriptInterface, EquipmentManipulationAction.UnequipAll );
		}
		if( scriptInterface.IsActionJustPressed( 'ToggleVehCamera' ) )
		{
			SetRequestedTPPCamera( stateContext, true );
			SendEquipmentSystemWeaponManipulationRequest( scriptInterface, EquipmentManipulationAction.UnequipAll );
		}
	}

	public function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var mountingInfo : MountingInfo;
		var slotName : CName;
		mountingInfo = scriptInterface.GetMountingInfo( scriptInterface.executionOwner );
		slotName = mountingInfo.slotId.id;
		SetVehicleCameraSceneMode( scriptInterface, false );
		ToggleWindowForOccupiedSeat( scriptInterface, slotName, false );
		SendEquipmentSystemWeaponManipulationRequest( scriptInterface, EquipmentManipulationAction.UnequipAll );
		SetIsInVehicleDriverCombat( stateContext, false );
		ResetVehFppCameraParams( stateContext, scriptInterface );
		SetIsWorldRenderPlane( stateContext, true );
		SendAnimFeature( stateContext, scriptInterface );
	}

}

class ExitingDecisions extends VehicleTransition
{

	public export const virtual function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var exitRequest : StateResultBool;
		var exitAfterRequest : StateResultBool;
		var switchExitRequest : StateResultBool;
		exitRequest = stateContext.GetPermanentBoolParameter( 'validExitRequest' );
		switchExitRequest = stateContext.GetPermanentBoolParameter( 'validSwitchSeatExitRequest' );
		exitAfterRequest = stateContext.GetPermanentBoolParameter( 'validExitAfterSwitchRequest' );
		if( exitRequest.value )
		{
			return true;
		}
		if( ( !( switchExitRequest.value ) && exitAfterRequest.value ) && ( GetInStateTime() >= 0.05 ) )
		{
			return true;
		}
		if( IsExitForced( stateContext ) || !( scriptInterface.owner ) )
		{
			return true;
		}
		return false;
	}

	public export const function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var unmountData : MountEventData;
		if( IsExitForced( stateContext ) )
		{
			unmountData = GetUnmountingEvent( stateContext );
			return !( IsInVehicleWorkspot( scriptInterface, unmountData.slotName ) );
		}
		else
		{
			return !( scriptInterface.GetWorkspotSystem().IsActorInWorkspot( scriptInterface.executionOwner ) );
		}
	}

}

class ExitingEventsBase extends VehicleEventsTransition
{

	protected override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		super.OnEnter( stateContext, scriptInterface );
		stateContext.SetPermanentBoolParameter( 'validExitRequest', false, true );
		stateContext.SetPermanentBoolParameter( 'validExitAfterSwitchRequest', false, true );
		stateContext.SetConditionBoolParameter( 'VisionToggled', false, true );
		ForceDisableVisionMode( stateContext );
		TryToStopVehicle( stateContext, scriptInterface );
		PlayVehicleExitDoorAnimation( stateContext, scriptInterface );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Vehicle, ( ( Int32 )( gamePSMVehicle.Transition ) ) );
		PlayerStateChange( scriptInterface, 4 );
	}

	public export virtual function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		SetOneHandedFirearmsGameplayRestriction( scriptInterface, false );
		SendAnimFeature( stateContext, scriptInterface );
		if( IsPlayerInCombat( scriptInterface ) )
		{
			SendEquipmentSystemWeaponManipulationRequest( scriptInterface, EquipmentManipulationAction.RequestLastUsedWeapon );
		}
	}

	protected function StartExiting( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var audioEvt : VehicleAudioEvent;
		StartLeavingVehicle( stateContext, scriptInterface );
		audioEvt = new VehicleAudioEvent;
		audioEvt.action = vehicleAudioEventAction.OnPlayerExitVehicle;
		scriptInterface.owner.QueueEvent( audioEvt );
		stateContext.SetPermanentBoolParameter( 'startedExiting', true, true );
	}

}

class ExitingEvents extends ExitingEventsBase
{

	protected export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var exitDelay : Float;
		super.OnEnter( stateContext, scriptInterface );
		exitDelay = GetVehicleDataPackage( stateContext ).ExitDelay();
		if( exitDelay == 0.0 )
		{
			StartExiting( stateContext, scriptInterface );
		}
	}

	public export function OnUpdate( timeDelta : Float, stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var exitDelay : Float;
		var startedExiting : StateResultBool;
		var vehicle : weak< VehicleObject >;
		var validUnmount : vehicleUnmountPosition;
		var unmountDirResult : StateResultInt;
		var isTeleportExiting : StateResultBool;
		var oldExitDirection : vehicleExitDirection;
		exitDelay = GetVehicleDataPackage( stateContext ).ExitDelay();
		startedExiting = stateContext.GetPermanentBoolParameter( 'startedExiting' );
		isTeleportExiting = stateContext.GetPermanentBoolParameter( 'teleportExitActive' );
		if( exitDelay > 0.0 )
		{
			if( ( GetInStateTime() >= exitDelay ) && !( startedExiting.value ) )
			{
				StartExiting( stateContext, scriptInterface );
			}
		}
		if( ( startedExiting.value && !( isTeleportExiting.value ) ) && ( GetInStateTime() >= 1.0 ) )
		{
			vehicle = ( ( VehicleObject )( scriptInterface.owner ) );
			unmountDirResult = stateContext.GetPermanentIntParameter( 'vehUnmountDir' );
			if( unmountDirResult.valid )
			{
				oldExitDirection = ( ( vehicleExitDirection )( unmountDirResult.value ) );
				validUnmount = vehicle.CanUnmount( true, scriptInterface.executionOwner, oldExitDirection );
				if( validUnmount.direction != oldExitDirection )
				{
					validUnmount = vehicle.CanUnmount( true, scriptInterface.executionOwner, vehicleExitDirection.Back );
					validUnmount = vehicle.CanUnmount( true, scriptInterface.executionOwner, vehicleExitDirection.Back );
					if( validUnmount.direction == vehicleExitDirection.NoDirection )
					{
						validUnmount = vehicle.CanUnmount( true, scriptInterface.executionOwner );
					}
					if( validUnmount.direction != vehicleExitDirection.NoDirection )
					{
						scriptInterface.GetWorkspotSystem().StopNpcInWorkspot( scriptInterface.executionOwner );
						ExitWithTeleport( stateContext, scriptInterface, validUnmount, false, true );
					}
				}
			}
		}
	}

}

class ImmediateExitWithForceEvents extends ExitingEventsBase
{
	var exitForce : StateResultVector;
	var bikeForce : StateResultVector;
	var knockOverBike : KnockOverBikeEvent;

	protected override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		super.OnEnter( stateContext, scriptInterface );
		knockOverBike = new KnockOverBikeEvent;
		knockOverBike.forceKnockdown = true;
		Unmount( scriptInterface, stateContext );
		scriptInterface.owner.QueueEvent( knockOverBike );
		exitForce = stateContext.GetTemporaryVectorParameter( 'ExitForce' );
		bikeForce = stateContext.GetTemporaryVectorParameter( 'BikeForce' );
	}

	public override function OnForcedExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		super.OnForcedExit( stateContext, scriptInterface );
		ApplyCounterForce( scriptInterface, stateContext );
	}

	public override function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		super.OnExit( stateContext, scriptInterface );
		ApplyCounterForce( scriptInterface, stateContext );
	}

	protected override function ExitWorkspot( stateContext : StateContext, scriptInterface : StateGameScriptInterface, isInstant : Bool, optional isUpsidedown : Bool )
	{
		var workspotSystem : WorkspotGameSystem;
		workspotSystem = scriptInterface.GetWorkspotSystem();
		workspotSystem.StopNpcInWorkspot( scriptInterface.executionOwner );
	}

	protected function Unmount( scriptInterface : StateGameScriptInterface, stateContext : StateContext )
	{
		var unmountEvent : UnmountingRequest;
		var mountingInfo : MountingInfo;
		unmountEvent = new UnmountingRequest;
		mountingInfo.childId = scriptInterface.executionOwnerEntityID;
		unmountEvent.lowLevelMountingInfo = mountingInfo;
		unmountEvent.mountData = new MountEventData;
		unmountEvent.mountData.isInstant = true;
		scriptInterface.GetMountingFacility().Unmount( unmountEvent );
	}

	protected function ApplyCounterForce( scriptInterface : StateGameScriptInterface, stateContext : StateContext )
	{
		var impulseEvent : PSMImpulse;
		var bikeImpulseEvent : PhysicalImpulseEvent;
		var vehicle : weak< VehicleObject >;
		var tempVec4 : Vector4;
		if( exitForce.valid )
		{
			impulseEvent = new PSMImpulse;
			impulseEvent.id = 'impulse';
			impulseEvent.impulse = exitForce.value;
			scriptInterface.executionOwner.QueueEvent( impulseEvent );
		}
		if( bikeForce.valid )
		{
			vehicle = ( ( VehicleObject )( scriptInterface.owner ) );
			bikeImpulseEvent = new PhysicalImpulseEvent;
			tempVec4 = vehicle.GetWorldPosition();
			bikeImpulseEvent.worldPosition.X = tempVec4.X;
			bikeImpulseEvent.worldPosition.Y = tempVec4.Y;
			bikeImpulseEvent.worldPosition.Z = tempVec4.Z;
			tempVec4 = bikeForce.value;
			bikeImpulseEvent.worldImpulse.X = tempVec4.X;
			bikeImpulseEvent.worldImpulse.Y = tempVec4.Y;
			bikeImpulseEvent.worldImpulse.Z = tempVec4.Z;
			vehicle.QueueEvent( bikeImpulseEvent );
		}
	}

}

class CollisionExitingDecisions extends ExitingDecisions
{

	public export const override function EnterCondition( stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var recordID : TweakDBID;
		var vehicleRecord : Vehicle_Record;
		var vehicleDataPackage : weak< VehicleDataPackage_Record >;
		var vehicle : VehicleObject;
		var collisionForce : Vector4;
		var vehicleUp : Vector4;
		var collisionUp : Vector4;
		var impulse : Vector4;
		var collForceSqr : Float;
		var knockOffForceSqr : Float;
		if( stateContext.GetIntParameter( 'vehClass', true ) != 1 )
		{
			return false;
		}
		vehicle = ( ( VehicleObject )( scriptInterface.owner ) );
		if( vehicle )
		{
			collisionForce = vehicle.GetCollisionForce();
			collForceSqr = Vector4.LengthSquared( collisionForce );
			if( collForceSqr > 0.1 )
			{
				recordID = ( ( VehicleObject )( scriptInterface.owner ) ).GetRecordID();
				vehicleRecord = TweakDBInterface.GetVehicleRecord( recordID );
				vehicleDataPackage = vehicleRecord.VehDataPackage();
				knockOffForceSqr = vehicleDataPackage.KnockOffForce();
				knockOffForceSqr *= knockOffForceSqr;
				if( collForceSqr > knockOffForceSqr )
				{
					vehicleUp = vehicle.GetWorldUp();
					collisionUp = vehicleUp * Vector4.Dot( collisionForce, vehicleUp );
					collisionForce -= collisionUp;
					if( Vector4.LengthSquared( collisionForce ) > knockOffForceSqr )
					{
						impulse = -( collisionForce );
						impulse += ( 4.0 * vehicle.GetWorldUp() );
						stateContext.SetTemporaryVectorParameter( 'ExitForce', impulse, true );
						SetBikeForce( stateContext, vehicle, collisionForce );
						return true;
					}
				}
			}
		}
		return false;
	}

	public const function SetBikeForce( stateContext : StateContext, vehicle : VehicleObject, collisionForce : Vector4 )
	{
		var bikeImpulse : Vector4;
		var bikeMass : Float;
		bikeImpulse = collisionForce;
		bikeImpulse = Vector4.Normalize( bikeImpulse );
		bikeMass = vehicle.GetTotalMass();
		bikeImpulse *= ( bikeMass * 3.79999995 );
		stateContext.SetTemporaryVectorParameter( 'BikeForce', bikeImpulse, true );
	}

}

class CollisionExitingEvents extends ImmediateExitWithForceEvents
{
	var m_animFeatureStatusEffect : AnimFeature_StatusEffect;

	protected override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var impulse : StateResultVector;
		var collisionDirection : Vector4;
		var statusEffectRecord : weak< StatusEffect_Record >;
		var stackcount : Uint32;
		collisionDirection = Vector4( 0.0, 0.0, 0.0, 0.0 );
		stackcount = 1;
		super.OnEnter( stateContext, scriptInterface );
		impulse = stateContext.GetTemporaryVectorParameter( 'ExitForce' );
		if( impulse.valid )
		{
			collisionDirection = -( impulse.value );
		}
		statusEffectRecord = TweakDBInterface.GetStatusEffectRecord( T"BaseStatusEffect.BikeKnockdown" );
		GameInstance.GetStatusEffectSystem( scriptInterface.GetGame() ).ApplyStatusEffect( scriptInterface.executionOwnerEntityID, statusEffectRecord.GetID(), GameObject.GetTDBID( scriptInterface.owner ), scriptInterface.ownerEntityID, stackcount, collisionDirection );
		m_animFeatureStatusEffect = new AnimFeature_StatusEffect;
		StatusEffectHelper.PopulateStatusEffectAnimData( scriptInterface.executionOwner, statusEffectRecord, EKnockdownStates.Start, collisionDirection, m_animFeatureStatusEffect );
		scriptInterface.SetAnimationParameterFeature( 'StatusEffect', m_animFeatureStatusEffect, scriptInterface.executionOwner );
		stateContext.SetPermanentFloatParameter( StatusEffectHelper.GetStateStartTimeKey(), EngineTime.ToFloat( scriptInterface.GetTimeSystem().GetSimTime() ), true );
		stateContext.SetPermanentScriptableParameter( StatusEffectHelper.GetForceKnockdownKey(), statusEffectRecord, true );
		if( exitForce.valid )
		{
			stateContext.SetPermanentVectorParameter( StatusEffectHelper.GetForcedKnockdownImpulseKey(), exitForce.value, true );
		}
		PlaySound( 'v_mbike_dst_crash_fall', scriptInterface );
	}

}

class DeathExitingDecisions extends ExitingDecisions
{

	public export const override function EnterCondition( stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		var playerOwner : PlayerPuppet;
		var vehicle : VehicleObject;
		var impulse : Vector4;
		var vehicleVelocity : Vector4;
		if( stateContext.GetIntParameter( 'vehClass', true ) != 1 )
		{
			return false;
		}
		playerOwner = ( ( PlayerPuppet )( scriptInterface.executionOwner ) );
		if( playerOwner )
		{
			if( playerOwner.IsDead() )
			{
				vehicle = ( ( VehicleObject )( scriptInterface.owner ) );
				vehicleVelocity = vehicle.GetLinearVelocity();
				if( Vector4.LengthSquared( vehicleVelocity ) < 0.1 )
				{
					impulse = playerOwner.GetWorldForward();
				}
				else
				{
					impulse = Vector4.Normalize( vehicleVelocity );
				}
				impulse *= -9.0;
				stateContext.SetTemporaryVectorParameter( 'ExitForce', impulse, true );
				return true;
			}
		}
		return false;
	}

}

class DeathExitingEvents extends ImmediateExitWithForceEvents
{
}

class ExitEvents extends VehicleEventsTransition
{

	protected export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var unmountEvent : UnmountingRequest;
		var mountingInfo : MountingInfo;
		var startedExitingResult : StateResultBool;
		var startedExiting : Bool;
		super.OnEnter( stateContext, scriptInterface );
		startedExitingResult = stateContext.GetPermanentBoolParameter( 'startedExiting' );
		startedExiting = startedExitingResult.valid && startedExitingResult.value;
		stateContext.SetPermanentBoolParameter( 'startedExiting', false, true );
		VehicleComponent.SetAnimsetOverrideForPassenger( scriptInterface.executionOwner, 0.0 );
		RemoveUnmountingRequest( stateContext );
		unmountEvent = new UnmountingRequest;
		mountingInfo.childId = scriptInterface.executionOwnerEntityID;
		unmountEvent.lowLevelMountingInfo = mountingInfo;
		if( !( startedExiting ) )
		{
			unmountEvent.mountData = new MountEventData;
			unmountEvent.mountData.isInstant = true;
		}
		scriptInterface.GetMountingFacility().Unmount( unmountEvent );
		ResetAnimFeature( stateContext, scriptInterface );
		ResetIsCar( stateContext, scriptInterface );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Vehicle, ( ( Int32 )( gamePSMVehicle.Default ) ) );
		PlayerStateChange( scriptInterface, 0 );
		DisableCameraBobbing( stateContext, scriptInterface, false );
		SetWasStolen( stateContext, false );
		SetWasCombatForced( stateContext, false );
		SetRequestedTPPCamera( stateContext, false );
		stateContext.SetPermanentBoolParameter( 'validExitRequest', false, true );
		stateContext.SetPermanentBoolParameter( 'validExitAfterSwitchRequest', false, true );
		stateContext.SetPermanentBoolParameter( 'validSwitchSeatExitRequest', false, true );
		stateContext.SetPermanentBoolParameter( 'teleportExitActive', false, true );
	}

	protected export override function OnForcedExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface ) {}
}

class WaitingForSceneDecisions extends VehicleTransition
{

	public export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( stateContext.GetBoolParameter( 'sceneActionInProgress', false ) )
		{
			return true;
		}
		return false;
	}

	public export const function ToExit( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsExitForced( stateContext ) || !( scriptInterface.owner ) )
		{
			return true;
		}
		return false;
	}

	public export const function ToEntering( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( stateContext.GetBoolParameter( 'sceneActionFinished', false ) )
		{
			return true;
		}
		return false;
	}

}

class WaitingForSceneEvents extends VehicleTransition
{
}

class SceneDecisions extends VehicleTransition
{
	var m_sceneTierCallback : CallbackHandle;

	protected export function OnAttach( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface )
	{
		m_sceneTierCallback = scriptInterface.localBlackboard.RegisterListenerInt( GetAllBlackboardDefs().PlayerStateMachine.SceneTier, this, 'OnSceneTierChanged', true );
	}

	protected export function OnDetach( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface )
	{
		scriptInterface.localBlackboard.UnregisterListenerInt( GetAllBlackboardDefs().PlayerStateMachine.SceneTier, m_sceneTierCallback );
	}

	protected function OnSceneTierChanged( sceneTier : Int32 )
	{
		EnableOnEnterCondition( ( sceneTier >= ( ( Int32 )( gamePSMHighLevel.SceneTier3 ) ) ) && ( sceneTier <= ( ( Int32 )( gamePSMHighLevel.SceneTier5 ) ) ) );
	}

	public export const function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( ( IsExitForced( stateContext ) || !( IsInScene( stateContext, scriptInterface ) ) ) || !( scriptInterface.owner ) )
		{
			return true;
		}
		return false;
	}

	public const function ToVehicleTurret( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		return GetPuppetVehicleSceneTransition( stateContext ) == PuppetVehicleState.Turret;
	}

	public const function ToCombat( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsPassengerInVehicle( scriptInterface ) )
		{
			if( CanTransitionToCombat( stateContext ) )
			{
				return true;
			}
		}
		return false;
	}

	public const function ToDriverCombat( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsDriverInVehicle( scriptInterface ) && CanEnterDriverCombat() )
		{
			if( CanTransitionToCombat( stateContext ) )
			{
				return true;
			}
		}
		return false;
	}

	protected const function CanTransitionToCombat( const stateContext : StateContext ) : Bool
	{
		var puppetVehicleState : PuppetVehicleState;
		puppetVehicleState = GetPuppetVehicleSceneTransition( stateContext );
		if( puppetVehicleState == PuppetVehicleState.CombatSeated || puppetVehicleState == PuppetVehicleState.CombatWindowed )
		{
			if( !( IsInEmptyHandsState( stateContext ) ) )
			{
				return true;
			}
		}
		return false;
	}

}

class SceneEvents extends VehicleEventsTransition
{

	protected export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var mountingInfo : MountingInfo;
		mountingInfo = scriptInterface.GetMountingInfo( scriptInterface.executionOwner );
		SetSide( stateContext, scriptInterface );
		ForceIdleVehicle( stateContext );
		SetIsCar( stateContext, true );
		SendIsCar( stateContext, scriptInterface );
		PlayerStateChange( scriptInterface, 3 );
		SetVehicleCameraSceneMode( scriptInterface, true );
		SetBlackboardIntVariable( scriptInterface, GetAllBlackboardDefs().PlayerStateMachine.Vehicle, ( ( Int32 )( gamePSMVehicle.Scene ) ) );
		SendAnimFeature( stateContext, scriptInterface );
		if( !( scriptInterface.GetWorkspotSystem().IsActorInWorkspot( scriptInterface.executionOwner ) ) && !( scriptInterface.IsSceneAnimationActive() ) )
		{
			FallbackMountToWorkspot( scriptInterface, mountingInfo );
		}
	}

	protected export function OnUpdate( timeDelta : Float, stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var puppetVehicleState : StateResultInt;
		var sceneGameplayTransition : PuppetVehicleState;
		var isInVehicleCombat : Bool;
		var weaponItemID : ItemID;
		isInVehicleCombat = false;
		puppetVehicleState = stateContext.GetTemporaryIntParameter( 'scenePuppetVehicleState' );
		if( puppetVehicleState.valid )
		{
			stateContext.SetPermanentIntParameter( 'scenePuppetVehicleState', puppetVehicleState.value, true );
			sceneGameplayTransition = GetPuppetVehicleSceneTransition( stateContext );
			if( sceneGameplayTransition == PuppetVehicleState.GunnerSlot )
			{
				stateContext.SetPermanentIntParameter( 'vehSlot', 3, true );
				isInVehicleCombat = true;
			}
			else if( sceneGameplayTransition == PuppetVehicleState.CombatWindowed || sceneGameplayTransition == PuppetVehicleState.CombatSeated )
			{
				isInVehicleCombat = true;
			}
			if( ( sceneGameplayTransition == PuppetVehicleState.IdleMounted || sceneGameplayTransition == PuppetVehicleState.CombatWindowed ) || sceneGameplayTransition == PuppetVehicleState.CombatSeated )
			{
				SetSide( stateContext, scriptInterface );
			}
			if( isInVehicleCombat )
			{
				weaponItemID = EquipmentSystem.GetData( scriptInterface.executionOwner ).GetLastUsedOrFirstAvailableWeapon();
				if( WeaponObject.IsRanged( weaponItemID ) )
				{
					SendEquipmentSystemWeaponManipulationRequest( scriptInterface, EquipmentManipulationAction.RequestLastUsedOrFirstAvailableWeapon );
				}
				else
				{
					weaponItemID = EquipmentSystem.GetData( scriptInterface.executionOwner ).GetSlotActiveWeapon();
					if( WeaponObject.IsRanged( weaponItemID ) )
					{
						SendEquipmentSystemWeaponManipulationRequest( scriptInterface, EquipmentManipulationAction.RequestSlotActiveWeapon );
					}
					else
					{
						SendEquipmentSystemWeaponManipulationRequest( scriptInterface, EquipmentManipulationAction.RequestLastUsedOrFirstAvailableRangedWeapon );
					}
				}
			}
			SetIsInVehicleWindowCombat( stateContext, sceneGameplayTransition == PuppetVehicleState.CombatWindowed );
			SetIsInVehicle( stateContext, sceneGameplayTransition != PuppetVehicleState.IdleStand );
			SetIsInVehicleCombat( stateContext, isInVehicleCombat );
		}
		SendAnimFeature( stateContext, scriptInterface );
	}

	public export function OnExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var sceneGameplayTransition : PuppetVehicleState;
		sceneGameplayTransition = GetPuppetVehicleSceneTransition( stateContext );
		stateContext.RemovePermanentIntParameter( 'scenePuppetVehicleState' );
		stateContext.SetTemporaryBoolParameter( 'vehicleWindowedCombat', sceneGameplayTransition == PuppetVehicleState.CombatWindowed, true );
		stateContext.SetTemporaryIntParameter( 'scenePuppetVehicleState', ( ( Int32 )( sceneGameplayTransition ) ), true );
		SendAnimFeature( stateContext, scriptInterface );
		SetVehicleCameraSceneMode( scriptInterface, false );
		SetOneHandedFirearmsGameplayRestriction( scriptInterface, false );
	}

	protected export override function OnForcedExit( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		OnExit( stateContext, scriptInterface );
	}

	public function FallbackMountToWorkspot( scriptInterface : StateGameScriptInterface, mountingInfo : MountingInfo )
	{
		var workspotSystem : WorkspotGameSystem;
		workspotSystem = scriptInterface.GetWorkspotSystem();
		workspotSystem.MountToVehicle( scriptInterface.owner, scriptInterface.executionOwner, 0.0, 0.0, 'OccupantSlots', mountingInfo.slotId.id );
	}

}

class SceneExitingDecisions extends VehicleTransition
{

	public export const function EnterCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( IsExitForced( stateContext ) || !( scriptInterface.owner ) )
		{
			return true;
		}
		return false;
	}

	public export const function ExitCondition( const stateContext : StateContext, const scriptInterface : StateGameScriptInterface ) : Bool
	{
		if( !( scriptInterface.GetWorkspotSystem().IsActorInWorkspot( scriptInterface.executionOwner ) ) || !( scriptInterface.owner ) )
		{
			return true;
		}
		return false;
	}

}

class SceneExitingEvents extends VehicleEventsTransition
{

	protected export override function OnEnter( stateContext : StateContext, scriptInterface : StateGameScriptInterface )
	{
		var unmountEvent : MountEventData;
		var startedMountingEvent : VehicleStartedMountingEvent;
		super.OnEnter( stateContext, scriptInterface );
		unmountEvent = GetUnmountingEvent( stateContext );
		if( unmountEvent != NULL )
		{
			startedMountingEvent = new VehicleStartedMountingEvent;
			startedMountingEvent.slotID = unmountEvent.slotName;
			startedMountingEvent.isMounting = false;
			startedMountingEvent.character = scriptInterface.executionOwner;
			startedMountingEvent.instant = false;
			scriptInterface.owner.QueueEvent( startedMountingEvent );
			stateContext.SetPermanentBoolParameter( 'startedExiting', true, true );
		}
		if( IsExitForced( stateContext ) && scriptInterface.GetWorkspotSystem().IsActorInWorkspot( scriptInterface.executionOwner ) )
		{
			if( !( scriptInterface.IsSceneAnimationActive() ) )
			{
				ExitWorkspot( stateContext, scriptInterface, unmountEvent.isInstant );
				PlayVehicleExitDoorAnimation( stateContext, scriptInterface );
			}
		}
		SetIsInVehicle( stateContext, false );
		SendAnimFeature( stateContext, scriptInterface );
		RemoveUnmountingRequest( stateContext );
	}

}

exec function BlockSwitchSeats( gi : GameInstance, block : String )
{
	var debugBB : IBlackboard;
	debugBB = GameInstance.GetBlackboardSystem( gi ).Get( GetAllBlackboardDefs().DebugData );
	debugBB.SetBool( GetAllBlackboardDefs().DebugData.Vehicle_BlockSwitchSeats, StringToBool( block ) );
}

